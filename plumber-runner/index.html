<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Plumber Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
#wrap {
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  width: 100%; height: 100%;
}
canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  background: #5c94fc;
}
#ui {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
  display: flex; align-items: center; justify-content: center;
}
#overlay {
  display: none;
  flex-direction: column; align-items: center; gap: 16px;
  pointer-events: auto;
  background: rgba(0,0,0,0.7);
  padding: 32px 48px; border-radius: 12px;
  color: #fff; font-family: monospace; text-align: center;
}
#overlay h1 { font-size: 28px; }
#overlay p { font-size: 18px; }
#overlay button {
  font-family: monospace; font-size: 20px;
  padding: 12px 32px; border: none; border-radius: 8px;
  background: #e74c3c; color: #fff; cursor: pointer;
}
#overlay button:hover { background: #c0392b; }
#hud {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
}
#hud-top {
  display: flex; justify-content: space-between; align-items: flex-start;
  padding: 10px 16px;
  font-family: monospace; font-size: 18px;
  color: #fff; text-shadow: 2px 2px 0 #000;
}
#hud-left { text-align: left; }
#hud-right { text-align: right; }
#hud-time { font-size: 22px; font-weight: bold; }
#hud-level { font-size: 16px; margin-top: 2px; }
#score-display { font-size: 22px; }
#hud-level-bar {
  margin-top: 4px; width: 100px; height: 6px;
  background: rgba(255,255,255,0.25); border-radius: 3px;
  overflow: hidden;
}
#hud-level-fill {
  height: 100%; width: 0%; border-radius: 3px;
  transition: width 0.5s ease, background 0.5s ease;
}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
</div>
<div id="hud">
  <div id="hud-top">
    <div id="hud-left">
      <div id="hud-time">00:00</div>
      <div id="hud-level">Lv.1 EASY</div>
      <div id="hud-level-bar"><div id="hud-level-fill"></div></div>
    </div>
    <div id="hud-right">
      <div id="score-display">SCORE: 0</div>
    </div>
  </div>
</div>
<div id="ui">
  <div id="overlay">
    <h1 id="ol-title">Plumber Runner</h1>
    <p id="ol-msg">Press SPACE / Tap to Start</p>
    <p id="ol-score"></p>
    <button id="ol-btn">START</button>
  </div>
</div>

<script>
// ── Constants ──────────────────────────────────────────
const DESIGN_W = 800;
const DESIGN_H = 400;
const GROUND_H = 60;
const GRAVITY = 0.55;
const JUMP_INITIAL = -7.0;         // short-tap: small jump
const JUMP_HOLD_ACCEL = -0.55;     // long-press: stronger boost per frame
const JUMP_HOLD_MAX_T = 16;        // long-press: more frames of boost
const TALL_PIPE_THRESHOLD = 140;   // pipes >= this height trigger staircase logic
const SCROLL_SPEED_BASE = 3.5;
const SCROLL_ACCEL = 0.0003;
const PIPE_MIN_GAP = 240;
const PIPE_MAX_GAP = 360;
const PIPE_HEIGHTS_BOTTOM = [60, 90, 120, 150, 75, 105];
const PIPE_HEIGHTS_TOP = [60, 80, 100, 120, 140];
const PIPE_W = 48;
const LIP_W = 56;
const LIP_H = 16;
const CRUSH_THRESHOLD = 4; // pixels of squeeze to count as crushed

// ── Difficulty System ─────────────────────────────────
// 5 levels with smooth interpolation between them
// Each level defines target values; actual values lerp continuously
const DIFFICULTY_LEVELS = [
  { name: 'EASY',   time: 0,   speedMul: 1.0, gapMin: 280, gapMax: 380, pipeMaxH: 150, topMaxH: 140, pairChance: 0.35 },
  { name: 'NORMAL', time: 30,  speedMul: 1.25, gapMin: 250, gapMax: 340, pipeMaxH: 170, topMaxH: 155, pairChance: 0.40 },
  { name: 'HARD',   time: 75,  speedMul: 1.55, gapMin: 220, gapMax: 300, pipeMaxH: 195, topMaxH: 170, pairChance: 0.47 },
  { name: 'EXPERT', time: 140, speedMul: 1.85, gapMin: 195, gapMax: 270, pipeMaxH: 220, topMaxH: 190, pairChance: 0.52 },
  { name: 'INSANE', time: 240, speedMul: 2.15, gapMin: 175, gapMax: 245, pipeMaxH: 240, topMaxH: 200, pairChance: 0.55 },
];

// ── Canvas Setup ───────────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = DESIGN_W;
canvas.height = DESIGN_H;

function resizeCanvas() {
  const ww = window.innerWidth;
  const wh = window.innerHeight;
  const scale = Math.min(ww / DESIGN_W, wh / DESIGN_H);
  canvas.style.width = (DESIGN_W * scale) + 'px';
  canvas.style.height = (DESIGN_H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ── UI refs ────────────────────────────────────────────
const overlay = document.getElementById('overlay');
const olTitle = document.getElementById('ol-title');
const olMsg = document.getElementById('ol-msg');
const olScore = document.getElementById('ol-score');
const olBtn = document.getElementById('ol-btn');
const scoreDisplay = document.getElementById('score-display');
const hudTime = document.getElementById('hud-time');
const hudLevel = document.getElementById('hud-level');
const hudLevelFill = document.getElementById('hud-level-fill');

// ── Game State ─────────────────────────────────────────
let state = 'title'; // title | playing | dead
let score = 0;
let highScore = 0;
let frameCount = 0;
let scrollSpeed = SCROLL_SPEED_BASE;
let jumpPressed = false;
let jumpHoldFrames = 0;
let survivalTime = 0;       // seconds survived
let diffLevel = 0;          // current difficulty level index (0-4)
let diffProgress = 0;       // 0..1 progress within current level toward next

// ── Player ─────────────────────────────────────────────
const player = {
  x: 120, y: 0, w: 28, h: 36,
  vy: 0, onGround: true, frame: 0,
  animState: 'run',   // run | jump_up | fall | land
  landTimer: 0,       // frames remaining in land animation
  wasOnGround: true,  // track previous frame for landing detection
};

// ── Pipes ──────────────────────────────────────────────
// Each pipe: { x, h, fromTop (bool), scored }
let pipes = [];

// ── Clouds (decorative) ────────────────────────────────
let clouds = [];
function initClouds() {
  clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * DESIGN_W,
      y: 20 + Math.random() * 100,
      w: 50 + Math.random() * 60,
      speed: 0.3 + Math.random() * 0.5,
    });
  }
}

// ── Hills (decorative bg) ──────────────────────────────
let hills = [];
function initHills() {
  hills = [];
  for (let i = 0; i < 4; i++) {
    hills.push({
      x: i * 250,
      w: 180 + Math.random() * 100,
      h: 40 + Math.random() * 40,
    });
  }
}

// ── Drawing helpers ────────────────────────────────────

function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), w, h);
}

// ── Animation State Machine ───────────────────────────
// States: run, jump_up, fall, land
const LAND_DURATION = 6; // frames for land squash animation

function updateAnimState() {
  const prev = player.animState;

  // Landing detection: was airborne, now on ground
  if (!player.wasOnGround && player.onGround && prev !== 'land') {
    player.animState = 'land';
    player.landTimer = LAND_DURATION;
    player.wasOnGround = player.onGround;
    return;
  }

  player.wasOnGround = player.onGround;

  // Land animation countdown
  if (player.animState === 'land') {
    player.landTimer--;
    if (player.landTimer <= 0) {
      player.animState = 'run';
    }
    return;
  }

  // Airborne states
  if (!player.onGround) {
    if (player.vy < -0.5) {
      player.animState = 'jump_up';
    } else {
      player.animState = 'fall';
    }
    return;
  }

  // On ground and not landing
  player.animState = 'run';
}

// Draw the player character — original pixel adventurer with goggles
// 28x36 px, distinct from any Nintendo IP
function drawPlayer(px, py, frame) {
  const x = Math.round(px);
  const y = Math.round(py);
  const st = player.animState;

  // ── Color palette ──
  const HAIR   = '#4a2c0a';   // dark brown hair
  const SKIN   = '#e8b88a';   // warm skin
  const GOGGLE = '#42d4f4';   // cyan goggles
  const GFRAME = '#555';      // goggle frame
  const VEST   = '#e67e22';   // orange vest
  const SHIRT  = '#2c3e50';   // dark teal undershirt
  const PANTS  = '#7f8c8d';   // grey pants
  const BOOTS  = '#5d4037';   // brown boots
  const BELT   = '#f1c40f';   // yellow belt buckle

  if (st === 'land') {
    // ── LAND: squash pose (wider, shorter) ──
    // Hair (flat)
    drawPixelRect(x + 4, y + 4, 20, 4, HAIR);
    // Head
    drawPixelRect(x + 6, y + 8, 16, 8, SKIN);
    // Goggles
    drawPixelRect(x + 6, y + 9, 16, 5, GFRAME);
    drawPixelRect(x + 7, y + 10, 6, 3, GOGGLE);
    drawPixelRect(x + 15, y + 10, 6, 3, GOGGLE);
    // Mouth
    drawPixelRect(x + 11, y + 14, 6, 1, '#c0392b');
    // Body — wider squash
    drawPixelRect(x + 2, y + 16, 24, 4, VEST);
    drawPixelRect(x + 6, y + 16, 16, 4, SHIRT);
    // Belt
    drawPixelRect(x + 10, y + 20, 8, 2, BELT);
    // Legs — wide bent crouch
    drawPixelRect(x + 2, y + 22, 8, 6, PANTS);
    drawPixelRect(x + 18, y + 22, 8, 6, PANTS);
    // Boots — wide
    drawPixelRect(x + 0, y + 28, 10, 4, BOOTS);
    drawPixelRect(x + 18, y + 28, 10, 4, BOOTS);
    // Dust puff particles
    if (player.landTimer > 3) {
      ctx.fillStyle = 'rgba(200,180,150,0.5)';
      ctx.fillRect(x - 2, y + 31, 4, 3);
      ctx.fillRect(x + 26, y + 31, 4, 3);
    }
    return;
  }

  if (st === 'jump_up') {
    // ── JUMP UP: arms raised, legs tucked ──
    // Hair (spiky upward — wind)
    drawPixelRect(x + 6, y - 2, 4, 4, HAIR);
    drawPixelRect(x + 12, y - 3, 4, 5, HAIR);
    drawPixelRect(x + 18, y - 1, 4, 3, HAIR);
    drawPixelRect(x + 4, y + 2, 20, 4, HAIR);
    // Head
    drawPixelRect(x + 6, y + 6, 16, 8, SKIN);
    // Goggles
    drawPixelRect(x + 6, y + 7, 16, 5, GFRAME);
    drawPixelRect(x + 7, y + 8, 6, 3, GOGGLE);
    drawPixelRect(x + 15, y + 8, 6, 3, GOGGLE);
    // Mouth — open excited
    drawPixelRect(x + 12, y + 13, 4, 2, '#c0392b');
    // Body
    drawPixelRect(x + 6, y + 14, 16, 8, VEST);
    drawPixelRect(x + 8, y + 15, 12, 6, SHIRT);
    // Arms — raised up!
    drawPixelRect(x + 0, y + 6, 6, 4, SHIRT);
    drawPixelRect(x + 0, y + 4, 4, 4, SKIN);
    drawPixelRect(x + 22, y + 6, 6, 4, SHIRT);
    drawPixelRect(x + 24, y + 4, 4, 4, SKIN);
    // Belt
    drawPixelRect(x + 10, y + 22, 8, 2, BELT);
    // Legs — tucked up
    drawPixelRect(x + 6, y + 24, 6, 4, PANTS);
    drawPixelRect(x + 16, y + 24, 6, 4, PANTS);
    // Boots — tucked
    drawPixelRect(x + 5, y + 28, 8, 4, BOOTS);
    drawPixelRect(x + 15, y + 28, 8, 4, BOOTS);
    return;
  }

  if (st === 'fall') {
    // ── FALL: arms out wide, legs dangling ──
    // Hair (flat, blown back)
    drawPixelRect(x + 4, y + 2, 20, 4, HAIR);
    drawPixelRect(x + 22, y + 3, 4, 3, HAIR);
    // Head
    drawPixelRect(x + 6, y + 6, 16, 8, SKIN);
    // Goggles
    drawPixelRect(x + 6, y + 7, 16, 5, GFRAME);
    drawPixelRect(x + 7, y + 8, 6, 3, GOGGLE);
    drawPixelRect(x + 15, y + 8, 6, 3, GOGGLE);
    // Mouth — worried O
    drawPixelRect(x + 12, y + 12, 3, 3, '#c0392b');
    // Body
    drawPixelRect(x + 6, y + 14, 16, 8, VEST);
    drawPixelRect(x + 8, y + 15, 12, 6, SHIRT);
    // Arms — spread out
    drawPixelRect(x + 0, y + 14, 6, 4, SHIRT);
    drawPixelRect(x + 0, y + 14, 4, 2, SKIN);
    drawPixelRect(x + 22, y + 14, 6, 4, SHIRT);
    drawPixelRect(x + 24, y + 14, 4, 2, SKIN);
    // Belt
    drawPixelRect(x + 10, y + 22, 8, 2, BELT);
    // Legs — dangling, slightly apart
    drawPixelRect(x + 6, y + 24, 6, 8, PANTS);
    drawPixelRect(x + 16, y + 24, 6, 8, PANTS);
    // Boots — hanging
    drawPixelRect(x + 5, y + 32, 8, 4, BOOTS);
    drawPixelRect(x + 15, y + 32, 8, 4, BOOTS);
    return;
  }

  // ── RUN: 4-frame running cycle ──
  // Hair
  drawPixelRect(x + 4, y, 20, 4, HAIR);
  drawPixelRect(x + 6, y - 2, 4, 3, HAIR); // tuft
  // Head
  drawPixelRect(x + 6, y + 4, 16, 10, SKIN);
  // Goggles
  drawPixelRect(x + 6, y + 5, 16, 5, GFRAME);
  drawPixelRect(x + 7, y + 6, 6, 3, GOGGLE);
  drawPixelRect(x + 15, y + 6, 6, 3, GOGGLE);
  // Mouth — grin
  drawPixelRect(x + 12, y + 11, 5, 2, '#c0392b');
  // Body
  drawPixelRect(x + 6, y + 14, 16, 8, VEST);
  drawPixelRect(x + 8, y + 15, 12, 6, SHIRT);
  // Belt
  drawPixelRect(x + 10, y + 22, 8, 2, BELT);

  // Arms & Legs — 4-frame run cycle
  const phase = frame % 4;
  if (phase === 0) {
    // Arms: left forward, right back
    drawPixelRect(x + 22, y + 14, 6, 4, SHIRT);  // right arm back
    drawPixelRect(x + 24, y + 14, 4, 2, SKIN);
    drawPixelRect(x + 0, y + 16, 6, 4, SHIRT);   // left arm forward
    drawPixelRect(x + 0, y + 16, 4, 2, SKIN);
    // Legs: left forward, right back
    drawPixelRect(x + 4, y + 24, 6, 8, PANTS);
    drawPixelRect(x + 16, y + 26, 6, 6, PANTS);
    drawPixelRect(x + 2, y + 32, 8, 4, BOOTS);
    drawPixelRect(x + 16, y + 32, 8, 4, BOOTS);
  } else if (phase === 1) {
    // Contact — legs closer together
    drawPixelRect(x + 0, y + 16, 6, 3, SHIRT);
    drawPixelRect(x + 0, y + 16, 4, 2, SKIN);
    drawPixelRect(x + 22, y + 16, 6, 3, SHIRT);
    drawPixelRect(x + 24, y + 16, 4, 2, SKIN);
    drawPixelRect(x + 6, y + 24, 6, 8, PANTS);
    drawPixelRect(x + 16, y + 24, 6, 8, PANTS);
    drawPixelRect(x + 4, y + 32, 8, 4, BOOTS);
    drawPixelRect(x + 16, y + 32, 8, 4, BOOTS);
  } else if (phase === 2) {
    // Arms: right forward, left back (mirror of 0)
    drawPixelRect(x + 0, y + 14, 6, 4, SHIRT);   // left arm back
    drawPixelRect(x + 0, y + 14, 4, 2, SKIN);
    drawPixelRect(x + 22, y + 16, 6, 4, SHIRT);  // right arm forward
    drawPixelRect(x + 24, y + 16, 4, 2, SKIN);
    // Legs: right forward, left back
    drawPixelRect(x + 16, y + 24, 6, 8, PANTS);
    drawPixelRect(x + 4, y + 26, 6, 6, PANTS);
    drawPixelRect(x + 16, y + 32, 8, 4, BOOTS);
    drawPixelRect(x + 2, y + 32, 8, 4, BOOTS);
  } else {
    // phase === 3: passing — legs closer together again
    drawPixelRect(x + 22, y + 16, 6, 3, SHIRT);
    drawPixelRect(x + 24, y + 16, 4, 2, SKIN);
    drawPixelRect(x + 0, y + 16, 6, 3, SHIRT);
    drawPixelRect(x + 0, y + 16, 4, 2, SKIN);
    drawPixelRect(x + 8, y + 24, 6, 8, PANTS);
    drawPixelRect(x + 14, y + 24, 6, 8, PANTS);
    drawPixelRect(x + 6, y + 32, 8, 4, BOOTS);
    drawPixelRect(x + 14, y + 32, 8, 4, BOOTS);
  }
}

// Get pipe collision rectangles
// Returns { lipRect, bodyRect, topY (top of entire pipe visual) }
function getPipeRects(pipe) {
  const groundY = DESIGN_H - GROUND_H;
  const lipOffset = (LIP_W - PIPE_W) / 2;
  if (!pipe.fromTop) {
    // Bottom pipe
    const topY = groundY - pipe.h;
    return {
      lipRect: { x: pipe.x, y: topY, w: LIP_W, h: LIP_H },
      bodyRect: { x: pipe.x + lipOffset, y: topY + LIP_H, w: PIPE_W, h: pipe.h - LIP_H },
      standY: topY, // top surface Y for standing
    };
  } else {
    // Top (ceiling) pipe — hangs from y=0
    const bottomY = pipe.h;
    return {
      lipRect: { x: pipe.x, y: bottomY - LIP_H, w: LIP_W, h: LIP_H },
      bodyRect: { x: pipe.x + lipOffset, y: 0, w: PIPE_W, h: pipe.h - LIP_H },
      standY: null, // cannot stand on top pipes
    };
  }
}

// Draw a bottom pipe (green, with lip at top)
function drawBottomPipe(px, ph) {
  const x = Math.round(px);
  const groundY = DESIGN_H - GROUND_H;
  const lipOffset = (LIP_W - PIPE_W) / 2;
  const bodyY = groundY - ph + LIP_H;
  const bodyH = ph - LIP_H;
  const topY = groundY - ph;
  // Pipe body
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x + lipOffset, bodyY, PIPE_W, bodyH);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + lipOffset + 4, bodyY, 8, bodyH);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + lipOffset + PIPE_W - 8, bodyY, 8, bodyH);
  // Lip
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x, topY, LIP_W, LIP_H);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + 4, topY + 2, 8, LIP_H - 4);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + LIP_W - 8, topY + 2, 6, LIP_H - 4);
  ctx.fillStyle = '#196f3d';
  ctx.fillRect(x, topY, LIP_W, 2);
}

// Draw a top (ceiling) pipe (hanging from top, lip at bottom)
function drawTopPipe(px, ph) {
  const x = Math.round(px);
  const lipOffset = (LIP_W - PIPE_W) / 2;
  const bodyH = ph - LIP_H;
  const lipY = bodyH;
  // Pipe body
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x + lipOffset, 0, PIPE_W, bodyH);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + lipOffset + 4, 0, 8, bodyH);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + lipOffset + PIPE_W - 8, 0, 8, bodyH);
  // Lip (at bottom of top pipe)
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x, lipY, LIP_W, LIP_H);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + 4, lipY + 2, 8, LIP_H - 4);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + LIP_W - 8, lipY + 2, 6, LIP_H - 4);
  // Bottom line of lip
  ctx.fillStyle = '#196f3d';
  ctx.fillRect(x, lipY + LIP_H - 2, LIP_W, 2);
}

// Draw ground with brick pattern
function drawGround(offset) {
  const groundY = DESIGN_H - GROUND_H;
  ctx.fillStyle = '#c0784a';
  ctx.fillRect(0, groundY, DESIGN_W, GROUND_H);
  const brickW = 32;
  const brickH = 16;
  const startX = -(offset % brickW);
  ctx.fillStyle = '#a0603a';
  for (let row = 0; row < Math.ceil(GROUND_H / brickH); row++) {
    const rowOffset = (row % 2) * (brickW / 2);
    for (let col = -1; col < Math.ceil(DESIGN_W / brickW) + 2; col++) {
      const bx = startX + col * brickW + rowOffset;
      const by = groundY + row * brickH;
      ctx.fillRect(bx, by, brickW, 1);
      ctx.fillRect(bx, by, 1, brickH);
    }
  }
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, groundY, DESIGN_W, 3);
}

function drawCloud(cx, cy, cw) {
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  const h = cw * 0.4;
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.3, cy + h * 0.5, cw * 0.3, h * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.6, cy + h * 0.35, cw * 0.25, h * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.5, cy + h * 0.6, cw * 0.35, h * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawHill(hx, hw, hh) {
  const groundY = DESIGN_H - GROUND_H;
  ctx.fillStyle = '#3a9d5c';
  ctx.beginPath();
  ctx.moveTo(hx, groundY);
  ctx.quadraticCurveTo(hx + hw / 2, groundY - hh, hx + hw, groundY);
  ctx.fill();
}

// ── Collision ──────────────────────────────────────────
function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// Get player hitbox (slightly shrunken for fairness)
function getPlayerHitbox() {
  return {
    x: player.x + 4,
    y: player.y + 2,
    w: player.w - 8,
    h: player.h - 4,
  };
}

// Check if player is standing on any pipe top. Returns standY or null.
function checkPipeStanding() {
  const pb = getPlayerHitbox();
  const feetY = pb.y + pb.h;
  const groundY = DESIGN_H - GROUND_H;

  for (const pipe of pipes) {
    if (pipe.fromTop) continue; // can't stand on ceiling pipes
    const rects = getPipeRects(pipe);
    const standY = rects.standY;
    // Player feet must be near the pipe top surface, falling downward
    // and horizontally overlapping the lip
    if (player.vy >= 0 &&
        feetY >= standY && feetY <= standY + 10 &&
        pb.x + pb.w > pipe.x + 4 && pb.x < pipe.x + LIP_W - 4) {
      return standY;
    }
  }
  return null;
}

// Check for side collision with pipes — returns push-back amount or 0
function checkSideCollision() {
  const pb = getPlayerHitbox();
  let pushBack = 0;

  for (const pipe of pipes) {
    const rects = getPipeRects(pipe);
    // Check against lip rect
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h)) {
      // Determine if this is a side collision (player approaching from left)
      const playerRight = pb.x + pb.w;
      const pipeLeft = rects.lipRect.x;
      const overlapX = playerRight - pipeLeft;
      // Only treat as side hit if player center is to the left of pipe center
      // and the overlap is lateral (not landing on top)
      const playerBottom = pb.y + pb.h;
      const isAbove = playerBottom <= rects.lipRect.y + 6;
      if (!isAbove && overlapX > 0 && overlapX < pb.w) {
        pushBack = Math.max(pushBack, overlapX);
      }
    }
    // Check against body rect
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
      const playerRight = pb.x + pb.w;
      const pipeLeft = rects.bodyRect.x;
      const overlapX = playerRight - pipeLeft;
      if (overlapX > 0 && overlapX < pb.w) {
        pushBack = Math.max(pushBack, overlapX);
      }
    }
  }
  return pushBack;
}

// Check if player is being crushed (squeezed between obstacles)
function checkCrush() {
  const pb = getPlayerHitbox();

  // 1) Crushed against left screen edge by pipe pushing from right
  if (player.x <= 0) {
    // Check if any pipe body/lip overlaps horizontally
    for (const pipe of pipes) {
      const rects = getPipeRects(pipe);
      if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
          rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
          rectsOverlap(pb.x, pb.y, pb.w, pb.h,
          rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
        return true;
      }
    }
  }

  // 2) Vertically crushed between bottom pipe/ground and top pipe/ceiling
  // Find the highest floor surface under player and lowest ceiling above
  let floorY = DESIGN_H - GROUND_H; // ground
  let ceilY = 0; // screen top

  for (const pipe of pipes) {
    const rects = getPipeRects(pipe);
    // Check if pipe is horizontally relevant (overlaps player X)
    const horizOverlap = pb.x + pb.w > rects.lipRect.x + 4 &&
                         pb.x < rects.lipRect.x + rects.lipRect.w - 4;
    if (!horizOverlap) continue;

    if (!pipe.fromTop) {
      // Bottom pipe — acts as raised floor
      const pipeTop = rects.standY;
      if (pipeTop < floorY) floorY = pipeTop;
    } else {
      // Top pipe — acts as lowered ceiling
      const pipeBottom = pipe.h; // bottom of top pipe
      if (pipeBottom > ceilY) ceilY = pipeBottom;
    }
  }

  // If the available vertical space is less than player height, crushed
  const availableSpace = floorY - ceilY;
  if (availableSpace < pb.h - CRUSH_THRESHOLD) {
    // Only trigger if player is actually in this squeeze zone
    if (pb.y + pb.h >= floorY - 2 && pb.y <= ceilY + 2) {
      return true;
    }
  }

  // 3) Head hitting ceiling pipe while standing on bottom pipe
  for (const topPipe of pipes) {
    if (!topPipe.fromTop) continue;
    const topRects = getPipeRects(topPipe);
    // Check if player head overlaps top pipe
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        topRects.lipRect.x, topRects.lipRect.y, topRects.lipRect.w, topRects.lipRect.h) ||
        rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        topRects.bodyRect.x, topRects.bodyRect.y, topRects.bodyRect.w, topRects.bodyRect.h)) {
      // Player is also on a platform (ground or bottom pipe)
      if (player.onGround) return true;
    }
  }

  return false;
}

// ── Game Logic ─────────────────────────────────────────
let groundOffset = 0;

function resetGame() {
  player.y = DESIGN_H - GROUND_H - player.h;
  player.x = 120;
  player.vy = 0;
  player.onGround = true;
  player.frame = 0;
  player.animState = 'run';
  player.landTimer = 0;
  player.wasOnGround = true;
  pipes = [];
  score = 0;
  frameCount = 0;
  survivalTime = 0;
  diffLevel = 0;
  diffProgress = 0;
  scrollSpeed = SCROLL_SPEED_BASE;
  groundOffset = 0;
  jumpHoldFrames = 0;
  initClouds();
  initHills();
  // Seed first pipe pair far away
  spawnInitialPipes();
}

function spawnInitialPipes() {
  const x = DESIGN_W + 100;
  // Bottom pipe
  pipes.push({
    x: x,
    h: PIPE_HEIGHTS_BOTTOM[Math.floor(Math.random() * PIPE_HEIGHTS_BOTTOM.length)],
    fromTop: false,
    scored: false,
  });
}

// Get smoothly interpolated difficulty parameter at current survival time
function getDiffParam(key) {
  const levels = DIFFICULTY_LEVELS;
  const t = survivalTime;
  // Find which two levels we're between
  for (let i = levels.length - 1; i >= 0; i--) {
    if (t >= levels[i].time) {
      if (i === levels.length - 1) return levels[i][key]; // at max level
      const curr = levels[i];
      const next = levels[i + 1];
      const frac = (t - curr.time) / (next.time - curr.time);
      // Smooth step for less jarring transitions
      const s = frac * frac * (3 - 2 * frac);
      return curr[key] + (next[key] - curr[key]) * s;
    }
  }
  return levels[0][key];
}

function updateDifficultyInfo() {
  const levels = DIFFICULTY_LEVELS;
  const t = survivalTime;
  for (let i = levels.length - 1; i >= 0; i--) {
    if (t >= levels[i].time) {
      diffLevel = i;
      if (i < levels.length - 1) {
        diffProgress = (t - levels[i].time) / (levels[i + 1].time - levels[i].time);
      } else {
        diffProgress = 1;
      }
      break;
    }
  }
}

// Check if the last few bottom pipes already provide a staircase for a tall target
function needsStaircase(targetH) {
  if (targetH < TALL_PIPE_THRESHOLD) return false;
  // Look at recent bottom pipes (last 2) — if any is a mid-height step, no staircase needed
  const recentBottom = pipes.filter(p => !p.fromTop).slice(-2);
  for (const p of recentBottom) {
    if (p.h >= 60 && p.h < targetH - 20) return false; // already has a step
  }
  return true;
}

// Spawn staircase pipes before a tall bottom pipe
function spawnStaircaseFor(targetH, targetX, gapMin, gapMax) {
  // Create 1-2 stepping-stone pipes leading up to the tall one
  const steps = targetH >= 200 ? 2 : 1;
  let curX = targetX;
  const stepHeights = [];
  for (let i = steps; i >= 1; i--) {
    // Each step is roughly (i / (steps+1)) of the target height, with some variance
    const ratio = i / (steps + 1);
    const baseH = Math.round(targetH * ratio);
    const h = Math.max(50, Math.min(baseH + Math.floor(Math.random() * 20 - 10), targetH - 30));
    stepHeights.unshift(h);
  }
  // Place steps before the target, working backwards
  for (let i = stepHeights.length - 1; i >= 0; i--) {
    const stepGap = gapMin * 0.7 + Math.random() * (gapMax - gapMin) * 0.4;
    curX -= stepGap;
    pipes.push({
      x: curX,
      h: stepHeights[i],
      fromTop: false,
      scored: false,
    });
  }
  return curX; // returns leftmost step X so we know where steps start
}

function spawnPipe() {
  const lastPipe = pipes[pipes.length - 1];
  const gapMin = getDiffParam('gapMin');
  const gapMax = getDiffParam('gapMax');
  const gap = gapMin + Math.random() * (gapMax - gapMin);
  const newX = lastPipe.x + gap;

  const pipeMaxH = getDiffParam('pipeMaxH');
  const topMaxH = getDiffParam('topMaxH');
  const pairChance = getDiffParam('pairChance');

  // Build height pools dynamically based on current difficulty
  const bottomHeights = PIPE_HEIGHTS_BOTTOM.filter(h => h <= pipeMaxH);
  if (pipeMaxH >= 170) bottomHeights.push(170);
  if (pipeMaxH >= 195) bottomHeights.push(195);
  if (pipeMaxH >= 220) bottomHeights.push(220);
  if (pipeMaxH >= 240) bottomHeights.push(240);

  const topHeights = PIPE_HEIGHTS_TOP.filter(h => h <= topMaxH);
  if (topMaxH >= 155) topHeights.push(155);
  if (topMaxH >= 170) topHeights.push(170);
  if (topMaxH >= 190) topHeights.push(190);
  if (topMaxH >= 200) topHeights.push(200);

  // Decide what to spawn
  const roll = Math.random();
  const topOnlyChance = 0.20;
  const bottomOnlyChance = 1 - topOnlyChance - pairChance;

  if (roll < bottomOnlyChance) {
    // Bottom pipe only
    const h = bottomHeights[Math.floor(Math.random() * bottomHeights.length)];
    // Staircase: if this pipe is tall and no recent step exists, insert stepping pipes
    if (needsStaircase(h)) {
      spawnStaircaseFor(h, newX, gapMin, gapMax);
    }
    pipes.push({ x: newX, h, fromTop: false, scored: false });
  } else if (roll < bottomOnlyChance + topOnlyChance) {
    // Top pipe only
    pipes.push({
      x: newX,
      h: topHeights[Math.floor(Math.random() * topHeights.length)],
      fromTop: true,
      scored: false,
    });
  } else {
    // Both top and bottom — create a passable gap
    const groundY = DESIGN_H - GROUND_H;
    const bottomH = bottomHeights[Math.floor(Math.random() * bottomHeights.length)];
    // Staircase for tall bottom in pair
    if (needsStaircase(bottomH)) {
      spawnStaircaseFor(bottomH, newX, gapMin, gapMax);
    }
    const bottomTopY = groundY - bottomH;
    const diffFrac = Math.min(survivalTime / DIFFICULTY_LEVELS[DIFFICULTY_LEVELS.length - 1].time, 1);
    const minGapSize = player.h + 30 + (1 - diffFrac) * 30;
    const maxTopH = bottomTopY - minGapSize;
    if (maxTopH >= 50) {
      const topH = 50 + Math.floor(Math.random() * (Math.min(maxTopH, topMaxH) - 50));
      pipes.push({ x: newX, h: bottomH, fromTop: false, scored: false });
      pipes.push({ x: newX, h: Math.max(50, topH), fromTop: true, scored: false });
    } else {
      pipes.push({ x: newX, h: bottomH, fromTop: false, scored: false });
    }
  }
}

function update() {
  if (state !== 'playing') return;

  frameCount++;
  survivalTime = frameCount / 60; // assume ~60fps
  updateDifficultyInfo();
  const speedMul = getDiffParam('speedMul');
  scrollSpeed = (SCROLL_SPEED_BASE + frameCount * SCROLL_ACCEL) * speedMul;
  groundOffset += scrollSpeed;

  const groundY = DESIGN_H - GROUND_H - player.h;

  // Jump initiation
  if (jumpPressed && player.onGround) {
    player.vy = JUMP_INITIAL;
    player.onGround = false;
    jumpHoldFrames = 0;
  }

  // Variable jump: hold to go higher
  if (jumpPressed && !player.onGround && jumpHoldFrames < JUMP_HOLD_MAX_T && player.vy < 0) {
    player.vy += JUMP_HOLD_ACCEL;
    jumpHoldFrames++;
  }

  player.vy += GRAVITY;
  player.y += player.vy;

  // Ground collision
  if (player.y >= groundY) {
    player.y = groundY;
    player.vy = 0;
    player.onGround = true;
    jumpHoldFrames = 0;
  }

  // Pipe top standing
  if (!player.onGround || player.vy > 0) {
    const standY = checkPipeStanding();
    if (standY !== null) {
      player.y = standY - player.h + 2; // +2 to account for hitbox shrink
      player.vy = 0;
      player.onGround = true;
      jumpHoldFrames = 0;
    }
  }

  // If player is standing on a pipe that has moved, check if still supported
  if (player.onGround && player.y < groundY - 5) {
    const stillOnPipe = checkPipeStanding();
    if (stillOnPipe === null) {
      player.onGround = false; // fell off pipe edge
    }
  }

  // Ceiling pipe collision — push player down
  const pb = getPlayerHitbox();
  for (const pipe of pipes) {
    if (!pipe.fromTop) continue;
    const rects = getPipeRects(pipe);
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h)) {
      // Push player below the lip
      const pushTo = rects.lipRect.y + rects.lipRect.h - 2;
      if (player.y < pushTo) {
        player.y = pushTo;
        if (player.vy < 0) player.vy = 0;
      }
    }
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
      const pushTo = rects.bodyRect.y + rects.bodyRect.h - 2;
      if (player.y < pushTo) {
        player.y = pushTo;
        if (player.vy < 0) player.vy = 0;
      }
    }
  }

  // Side collision — push player back
  const sideOverlap = checkSideCollision();
  if (sideOverlap > 0) {
    player.x -= sideOverlap + 1;
  }

  // Clamp player X (don't go off-screen right)
  if (player.x < -10) player.x = -10;

  // Check crush death
  if (checkCrush()) {
    state = 'dead';
    if (score > highScore) highScore = score;
    const tMins = Math.floor(survivalTime / 60);
    const tSecs = Math.floor(survivalTime % 60);
    const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
    showOverlay('Game Over', `Score: ${score}  |  Time: ${timeStr}  |  ${DIFFICULTY_LEVELS[diffLevel].name}`, score);
    return;
  }

  // If player pushed too far left off screen, also die
  if (player.x + player.w < -5) {
    state = 'dead';
    if (score > highScore) highScore = score;
    const tMins = Math.floor(survivalTime / 60);
    const tSecs = Math.floor(survivalTime % 60);
    const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
    showOverlay('Game Over', `Score: ${score}  |  Time: ${timeStr}  |  ${DIFFICULTY_LEVELS[diffLevel].name}`, score);
    return;
  }

  // Animation state machine
  updateAnimState();

  // Animation frame (run cycle only advances on ground)
  if (player.animState === 'run') {
    if (frameCount % 6 === 0) player.frame = (player.frame + 1) % 4;
  }

  // Move pipes
  for (const pipe of pipes) {
    pipe.x -= scrollSpeed;
  }

  // Score: passed pipe (only count bottom pipes or solo top pipes)
  for (const pipe of pipes) {
    if (!pipe.scored && pipe.x + LIP_W < player.x) {
      pipe.scored = true;
      score++;
    }
  }

  // Remove off-screen pipes
  pipes = pipes.filter(p => p.x > -LIP_W - 10);

  // Spawn pipes — check only among the rightmost pipe
  if (pipes.length > 0) {
    const rightmost = pipes.reduce((a, b) => a.x > b.x ? a : b);
    if (rightmost.x < DESIGN_W) {
      spawnPipe();
    }
  } else {
    spawnInitialPipes();
  }

  // Recover player X towards default position when not being pushed
  if (sideOverlap === 0 && player.x < 120) {
    player.x += Math.min(1.5, 120 - player.x);
  }

  // Update clouds
  for (const c of clouds) {
    c.x -= c.speed;
    if (c.x + c.w < 0) {
      c.x = DESIGN_W + Math.random() * 100;
      c.y = 20 + Math.random() * 100;
    }
  }

  // Update hills
  for (const h of hills) {
    h.x -= scrollSpeed * 0.3;
    if (h.x + h.w < 0) {
      const last = hills.reduce((a, b) => a.x > b.x ? a : b);
      h.x = last.x + 200 + Math.random() * 100;
      h.w = 180 + Math.random() * 100;
      h.h = 40 + Math.random() * 40;
    }
  }

  scoreDisplay.textContent = `SCORE: ${score}`;

  // Update HUD
  const mins = Math.floor(survivalTime / 60);
  const secs = Math.floor(survivalTime % 60);
  hudTime.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

  const lvl = DIFFICULTY_LEVELS[diffLevel];
  hudLevel.textContent = `Lv.${diffLevel + 1} ${lvl.name}`;

  const fillPct = diffLevel >= DIFFICULTY_LEVELS.length - 1 ? 100 : Math.round(diffProgress * 100);
  hudLevelFill.style.width = fillPct + '%';
  // Color gradient: green → yellow → orange → red → purple
  const levelColors = ['#2ecc71', '#f1c40f', '#e67e22', '#e74c3c', '#9b59b6'];
  hudLevelFill.style.background = levelColors[diffLevel];
}

function draw() {
  // Sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, DESIGN_H - GROUND_H);
  grad.addColorStop(0, '#5c94fc');
  grad.addColorStop(1, '#92c4f8');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, DESIGN_W, DESIGN_H);

  // Clouds
  for (const c of clouds) {
    drawCloud(c.x, c.y, c.w);
  }

  // Hills
  for (const h of hills) {
    drawHill(h.x, h.w, h.h);
  }

  // Ground
  drawGround(groundOffset);

  // Pipes
  for (const pipe of pipes) {
    if (pipe.fromTop) {
      drawTopPipe(pipe.x, pipe.h);
    } else {
      drawBottomPipe(pipe.x, pipe.h);
    }
  }

  // Player
  if (state === 'playing' || state === 'dead') {
    drawPlayer(player.x, player.y, player.frame);
  } else {
    drawPlayer(player.x, DESIGN_H - GROUND_H - player.h, 0);
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// ── Overlay ────────────────────────────────────────────
function showOverlay(title, msg, sc) {
  olTitle.textContent = title;
  olMsg.textContent = msg;
  if (sc !== undefined) {
    olScore.textContent = `High Score: ${highScore}`;
    olScore.style.display = 'block';
  } else {
    olScore.style.display = 'none';
  }
  olBtn.textContent = state === 'title' ? 'START' : 'RESTART';
  overlay.style.display = 'flex';
}

function hideOverlay() {
  overlay.style.display = 'none';
}

olBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  startGame();
});

function startGame() {
  hideOverlay();
  resetGame();
  state = 'playing';
}

// ── Input ──────────────────────────────────────────────
function onInputDown(e) {
  if (state === 'dead') {
    startGame();
    return;
  }
  if (state === 'title') {
    startGame();
    jumpPressed = true;
    return;
  }
  jumpPressed = true;
}
function onInputUp() {
  jumpPressed = false;
}

// Keyboard
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    onInputDown(e);
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    onInputUp();
  }
});

// Touch
document.addEventListener('touchstart', (e) => {
  if (e.target === olBtn) return;
  e.preventDefault();
  onInputDown(e);
}, { passive: false });
document.addEventListener('touchend', (e) => {
  onInputUp();
}, { passive: false });

// Mouse (for desktop testing)
canvas.addEventListener('mousedown', (e) => {
  onInputDown(e);
});
document.addEventListener('mouseup', () => {
  onInputUp();
});

// ── Init ───────────────────────────────────────────────
initClouds();
initHills();
showOverlay('Plumber Runner', 'Press SPACE / Tap to Start');
gameLoop();
</script>
</body>
</html>
