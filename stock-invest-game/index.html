<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>è‚¡å¸‚æŠ•è³‡ç­–ç•¥æ¨¡æ“¬å™¨ï¼ˆå°è‚¡ç›¤ä¸­è¦å‰‡ç‰ˆï¼‰</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans TC",sans-serif;background:#0f172a;color:#e2e8f0;padding:12px}
.wrap{max-width:520px;margin:0 auto}
h1{font-size:1.2rem;margin-bottom:4px}
.ver{font-size:.7rem;color:#64748b}
.sim-badge{display:none;background:#f59e0b;color:#000;font-weight:700;padding:2px 8px;border-radius:6px;font-size:.75rem;margin-left:6px}
.sim-badge.on{display:inline}

/* inputs */
.row{display:flex;gap:8px;margin:10px 0;flex-wrap:wrap}
.row input,.row select{background:#1e293b;border:1px solid #334155;color:#e2e8f0;border-radius:8px;padding:8px 10px;font-size:.95rem}
.row input{flex:1;min-width:80px}
.row select{min-width:100px}
button{background:#2563eb;color:#fff;border:none;border-radius:8px;padding:8px 16px;font-size:.9rem;cursor:pointer;font-weight:600}
button:disabled{opacity:.4;cursor:default}
button.stop{background:#dc2626}
button.reset{background:#475569}
button.clear-save{background:#7c2d12}

/* status panel */
.panel{background:#1e293b;border:1px solid #334155;border-radius:12px;padding:12px;margin:10px 0}
.panel h2{font-size:.95rem;margin-bottom:8px;color:#94a3b8}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:6px 16px}
.grid .lbl{font-size:.75rem;color:#64748b}
.grid .val{font-size:1rem;font-weight:700}
.val.up{color:#22c55e}
.val.down{color:#ef4444}
.val.neutral{color:#94a3b8}

/* stats */
.stats{display:grid;grid-template-columns:repeat(2,1fr);gap:6px 16px}

/* log */
.log-box{background:#111827;border:1px solid #334155;border-radius:10px;padding:10px;max-height:200px;overflow-y:auto;font-size:.78rem;line-height:1.5}
.log-box .entry{border-bottom:1px solid #1e293b;padding:3px 0}
.log-box .entry:last-child{border:none}
.log-entry-up{color:#22c55e}
.log-entry-down{color:#ef4444}

/* market status bar */
.market-bar{text-align:center;padding:6px;border-radius:8px;font-size:.8rem;font-weight:600;margin:8px 0}
.market-bar.open{background:#14532d;color:#4ade80}
.market-bar.closed{background:#422006;color:#fbbf24}

.back{display:inline-block;margin-bottom:8px;color:#38bdf8;text-decoration:none;font-size:.85rem}

/* inventory query button */
button.query{background:#0d9488}
button.manual-sell{background:#f97316}
button.manual-sell:disabled{opacity:.4;cursor:default}
button.manual-buy{background:#7c3aed}
button.manual-buy:disabled{opacity:.4;cursor:default}
.manual-buy-row{display:flex;gap:8px;margin:6px 0;flex-wrap:wrap;align-items:center}
.manual-buy-row input{background:#1e293b;border:1px solid #334155;color:#e2e8f0;border-radius:8px;padding:8px 10px;font-size:.95rem;width:110px}
.manual-buy-row label{font-size:.8rem;color:#94a3b8;white-space:nowrap}
.time-row{display:flex;gap:8px;margin:6px 0;flex-wrap:wrap;align-items:center}
.time-row input{background:#1e293b;border:1px solid #334155;color:#e2e8f0;border-radius:8px;padding:6px 8px;font-size:.9rem;width:80px}
.time-row label{font-size:.8rem;color:#94a3b8;white-space:nowrap}

/* inventory modal overlay */
.inv-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);z-index:100;justify-content:center;align-items:center}
.inv-overlay.show{display:flex}
.inv-modal{background:#1e293b;border:1px solid #475569;border-radius:14px;padding:16px;max-width:460px;width:92%;max-height:85vh;overflow-y:auto;position:relative}
.inv-modal h2{font-size:1rem;margin-bottom:10px;color:#e2e8f0}
.inv-modal .close-btn{position:absolute;top:10px;right:14px;background:none;border:none;color:#94a3b8;font-size:1.3rem;cursor:pointer;padding:0}
.inv-modal .inv-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px 16px}
.inv-modal .lbl{font-size:.75rem;color:#64748b}
.inv-modal .val{font-size:.95rem;font-weight:700}
.inv-modal .section-title{font-size:.82rem;color:#94a3b8;margin:12px 0 6px;border-top:1px solid #334155;padding-top:8px}
.inv-modal .no-pos{text-align:center;color:#94a3b8;padding:16px 0;font-size:.9rem}
.inv-modal .last-trade{background:#111827;border-radius:8px;padding:10px;margin-top:8px;font-size:.82rem;line-height:1.6}
</style>
</head>
<body>
<div class="wrap">
  <a class="back" href="../index.html">â† å›é¦–é </a>
  <h1>ğŸ“ˆ è‚¡å¸‚æŠ•è³‡ç­–ç•¥æ¨¡æ“¬å™¨ <span class="ver">v0.1.5</span></h1>
  <span id="simBadge" class="sim-badge">æ¨¡æ“¬æ¨¡å¼</span>

  <div id="marketBar" class="market-bar closed">éç›¤ä¸­æ™‚æ®µ â€” ç­‰å¾…é–‹ç›¤</div>
  <div id="sourceBar" style="text-align:center;padding:4px;font-size:.75rem;color:#94a3b8;margin:4px 0">ä¾†æºï¼šâ€” ï½œ æ›´æ–°ï¼šâ€”</div>

  <!-- poll interval -->
  <div class="row" style="align-items:center">
    <label style="font-size:.8rem;color:#94a3b8;white-space:nowrap">è¼ªè©¢é–“éš”</label>
    <input id="pollInput" type="number" min="3" max="60" value="5" style="width:60px;flex:none"/> <span style="font-size:.8rem;color:#94a3b8">ç§’</span>
  </div>

  <!-- monitoring time window -->
  <div class="time-row">
    <label>ç›£æ§æ™‚çª—</label>
    <input id="monitorStart" type="text" value="09:10" placeholder="09:10"/>
    <span style="font-size:.8rem;color:#94a3b8">~</span>
    <input id="monitorEnd" type="text" value="12:00" placeholder="12:00"/>
    <span style="font-size:.75rem;color:#64748b">(Asia/Taipei)</span>
  </div>

  <!-- stock input -->
  <div class="row">
    <input id="stockInput" type="text" placeholder="è‚¡ç¥¨ä»£è™Ÿ" value="2330"/>
    <select id="stockSelect">
      <option value="2330">2330 å°ç©é›»</option>
      <option value="2317">2317 é´»æµ·</option>
      <option value="0050">0050 å…ƒå¤§å°ç£50</option>
      <option value="2454">2454 è¯ç™¼ç§‘</option>
    </select>
  </div>
  <div class="row">
    <button id="btnStart">é–‹å§‹ç›£æ§</button>
    <button id="btnStop" class="stop" disabled>åœæ­¢ç›£æ§</button>
    <button id="btnManualSell" class="manual-sell" disabled>æ‰‹å‹•è³£å‡º</button>
    <button id="btnReset" class="reset">é‡ç½®</button>
    <button id="btnClearSave" class="reset" style="background:#7c2d12">æ¸…é™¤å­˜æª”</button>
    <button id="btnQuery" class="query">æŸ¥è©¢åº«å­˜</button>
  </div>
  <!-- manual buy -->
  <div class="manual-buy-row">
    <label>æ‰‹å‹•è²·å…¥åƒ¹</label>
    <input id="manualBuyPrice" type="number" step="0.01" min="0" placeholder="ç•™ç©º=ç¾åƒ¹"/>
    <label>è‚¡æ•¸</label>
    <input id="manualBuyShares" type="number" min="1" value="1000" style="width:80px"/>
    <button id="btnManualBuy" class="manual-buy">æ‰‹å‹•è²·å…¥</button>
  </div>
  <div id="loadNotice" style="display:none;background:#1e3a5f;color:#93c5fd;border-radius:8px;padding:8px 12px;margin:6px 0;font-size:.82rem;text-align:center"></div>

  <!-- status -->
  <div class="panel">
    <h2>å³æ™‚ç‹€æ…‹</h2>
    <div class="grid">
      <div><div class="lbl">è‚¡ç¥¨</div><div class="val" id="dStock">â€”</div></div>
      <div><div class="lbl">ç¾åƒ¹</div><div class="val" id="dPrice">â€”</div></div>
      <div><div class="lbl">è²·å…¥åƒ¹</div><div class="val" id="dBuy">â€”</div></div>
      <div><div class="lbl">æœ€é«˜åƒ¹</div><div class="val" id="dHigh">â€”</div></div>
      <div><div class="lbl">è‚¡æ•¸</div><div class="val" id="dShares">â€”</div></div>
      <div><div class="lbl">è²·å…¥ä¾†æº</div><div class="val" id="dBuySource">â€”</div></div>
      <div><div class="lbl">ç‹€æ…‹</div><div class="val neutral" id="dState">ç­‰å¾…ä¸­</div></div>
      <div><div class="lbl">å ±é…¬ç‡</div><div class="val neutral" id="dReturn">â€”</div></div>
      <div><div class="lbl">ç›£æ§æ™‚çª—</div><div class="val" id="dTimeWindow" style="font-size:.85rem">â€”</div></div>
    </div>
  </div>

  <!-- cumulative stats -->
  <div class="panel">
    <h2>ç´¯ç©çµ±è¨ˆ</h2>
    <div class="stats">
      <div><div class="lbl">äº¤æ˜“æ¬¡æ•¸</div><div class="val" id="sTrades">0</div></div>
      <div><div class="lbl">å‹ç‡</div><div class="val" id="sWinRate">â€”</div></div>
      <div><div class="lbl">å¹³å‡å ±é…¬ç‡</div><div class="val" id="sAvgReturn">â€”</div></div>
      <div><div class="lbl">ç´¯ç©æç›Š</div><div class="val neutral" id="sTotalPnl">$0</div></div>
    </div>
  </div>

  <!-- trade log -->
  <div class="panel">
    <h2>äº¤æ˜“æ—¥èªŒ</h2>
    <div class="log-box" id="logBox"><div class="entry" style="color:#64748b">å°šç„¡äº¤æ˜“è¨˜éŒ„</div></div>
  </div>
</div>

<!-- inventory query modal -->
<div id="invOverlay" class="inv-overlay">
  <div class="inv-modal">
    <button class="close-btn" id="invClose">&times;</button>
    <h2>åº«å­˜æŸ¥è©¢</h2>
    <div id="invContent"></div>
  </div>
</div>

<script>
/* â”€â”€ Config â”€â”€ */
let SHARES = 1000;           // default shares (can be overridden by manual buy)
const STOP_LOSS = 0.9;       // sell if price <= buyPrice * 0.9
const ENTER_TP = 1.1;        // enter trailing-stop mode at +10%
const NEAR_HIGH = 0.998;     // treat as new high if >= highest * 0.998
const TP_EXIT = 0.92;        // sell if price <= highestPrice * 0.92
let POLL_MS = 5000;          // poll interval (configurable)
const POLL_MIN = 3000;
/* Configurable monitoring time window (HH:MM format, Asia/Taipei) */
let MONITOR_START = '09:10';
let MONITOR_END = '12:00';

/* â”€â”€ Price source tracking â”€â”€ */
let lastSource = 'â€”';
let lastUpdateTime = 'â€”';

/* â”€â”€ State â”€â”€ */
let state = resetState();
let timer = null;
let simMode = false;
let simPrice = 0;

function resetState() {
  return {
    stock: '2330',
    phase: 'idle',       // idle | holding | trailing | sold
    buyPrice: 0,
    highestPrice: 0,
    currentPrice: 0,
    shares: 1000,        // current position shares
    buySource: '',       // '' | 'auto' | 'manual'
    trades: [],          // {buyPrice, sellPrice, pnl, returnPct, reason, shares, buySource}
  };
}

/* â”€â”€ localStorage persistence â”€â”€ */
const SAVE_KEY = 'stockInvestGame_v1';

function saveState() {
  try {
    const data = {
      stock: state.stock,
      phase: state.phase,
      buyPrice: state.buyPrice,
      highestPrice: state.highestPrice,
      currentPrice: state.currentPrice,
      shares: state.shares,
      buySource: state.buySource,
      trades: (state.trades || []).slice(-100),
      source: lastSource,
      sourceTime: lastUpdateTime,
      pollSec: POLL_MS / 1000,
      monitorStart: MONITOR_START,
      monitorEnd: MONITOR_END,
      savedAt: Date.now(),
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
  } catch (_) { /* localStorage unavailable â€” silently ignore */ }
}

function loadState() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return null;
    const d = JSON.parse(raw);
    if (!d || typeof d !== 'object') return null;
    return {
      stock:        typeof d.stock === 'string' && d.stock ? d.stock : '2330',
      phase:        ['idle','holding','trailing','sold'].includes(d.phase) ? d.phase : 'idle',
      buyPrice:     typeof d.buyPrice === 'number' && d.buyPrice >= 0 ? d.buyPrice : 0,
      highestPrice: typeof d.highestPrice === 'number' && d.highestPrice >= 0 ? d.highestPrice : 0,
      currentPrice: typeof d.currentPrice === 'number' && d.currentPrice >= 0 ? d.currentPrice : 0,
      shares:       typeof d.shares === 'number' && d.shares > 0 ? d.shares : 1000,
      buySource:    typeof d.buySource === 'string' ? d.buySource : '',
      trades:       Array.isArray(d.trades) ? d.trades.slice(-100) : [],
      source:       typeof d.source === 'string' ? d.source : 'â€”',
      sourceTime:   typeof d.sourceTime === 'string' ? d.sourceTime : 'â€”',
      pollSec:      typeof d.pollSec === 'number' && d.pollSec >= POLL_MIN/1000 ? d.pollSec : 5,
      monitorStart: typeof d.monitorStart === 'string' && /^\d{2}:\d{2}$/.test(d.monitorStart) ? d.monitorStart : '09:10',
      monitorEnd:   typeof d.monitorEnd === 'string' && /^\d{2}:\d{2}$/.test(d.monitorEnd) ? d.monitorEnd : '12:00',
    };
  } catch (_) { return null; }
}

function clearSave() {
  try { localStorage.removeItem(SAVE_KEY); } catch (_) { /* ignore */ }
}

/* â”€â”€ DOM refs â”€â”€ */
const $ = id => document.getElementById(id);
const btnStart = $('btnStart'), btnStop = $('btnStop'), btnReset = $('btnReset');
const btnClearSave = $('btnClearSave');
const stockInput = $('stockInput'), stockSelect = $('stockSelect');

stockSelect.addEventListener('change', () => { stockInput.value = stockSelect.value; });
stockInput.addEventListener('input', () => {
  const v = stockInput.value.trim();
  if ([...stockSelect.options].some(o => o.value === v)) stockSelect.value = v;
});

const btnQuery = $('btnQuery');
const btnManualSell = $('btnManualSell');
const btnManualBuy = $('btnManualBuy');

btnStart.addEventListener('click', startMonitor);
btnStop.addEventListener('click', stopMonitor);
btnReset.addEventListener('click', doReset);
btnClearSave.addEventListener('click', doClearSave);
btnQuery.addEventListener('click', showInventory);
btnManualBuy.addEventListener('click', doManualBuy);
btnManualSell.addEventListener('click', doManualSell);
$('invClose').addEventListener('click', () => { $('invOverlay').classList.remove('show'); });
$('invOverlay').addEventListener('click', e => { if (e.target === $('invOverlay')) $('invOverlay').classList.remove('show'); });

/* â”€â”€ Market hours check (Asia/Taipei) â”€â”€ */
function taipeiNow() {
  return new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Taipei' }));
}
function parseHHMM(s) {
  const [h, m] = s.split(':').map(Number);
  return h * 60 + (m || 0);
}
function isMarketOpen() {
  const d = taipeiNow();
  const day = d.getDay();
  if (day === 0 || day === 6) return false;
  const mins = d.getHours() * 60 + d.getMinutes();
  return mins >= parseHHMM(MONITOR_START) && mins < parseHHMM(MONITOR_END);
}
function updateMarketBar() {
  const bar = $('marketBar');
  if (isMarketOpen()) {
    bar.className = 'market-bar open';
    bar.textContent = `ç›£æ§ä¸­ ${MONITOR_START} â€“ ${MONITOR_END}`;
  } else {
    bar.className = 'market-bar closed';
    bar.textContent = `éç›£æ§æ™‚æ®µ â€” ç­‰å¾… ${MONITOR_START}`;
  }
}

/* â”€â”€ Price fetching â€” multi-source with fallback chain â”€â”€ */

// CORS proxy helpers â€” used when direct fetch fails due to CORS
const PROXIES = [
  url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
  url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
];

async function fetchWithTimeout(url, ms = 4000) {
  const resp = await fetch(url, { signal: AbortSignal.timeout(ms) });
  if (!resp.ok) throw new Error('http ' + resp.status);
  return resp;
}

async function tryDirectOrProxy(url, ms = 4000) {
  // Try direct first
  try { return await fetchWithTimeout(url, ms); } catch (_) { /* fall through */ }
  // Try each proxy
  for (const mkProxy of PROXIES) {
    try { return await fetchWithTimeout(mkProxy(url), ms); } catch (_) { /* next */ }
  }
  throw new Error('all fetch attempts failed');
}

// Source A: TWSE JSON (tse + otc)
async function fetchTWSE(stock) {
  const ts = Date.now();
  for (const ex of ['tse', 'otc']) {
    try {
      const url = `https://mis.twse.com.tw/stock/api/getStockInfo.jsp?ex_ch=${ex}_${stock}.tw&_=${ts}`;
      const resp = await tryDirectOrProxy(url);
      const json = await resp.json();
      if (json.msgArray && json.msgArray.length > 0) {
        const info = json.msgArray[0];
        let price = parseFloat(info.z);
        if (isNaN(price) || price <= 0) price = parseFloat(info.y);
        if (isNaN(price) || price <= 0) continue;
        return price;
      }
    } catch (_) { /* try next exchange */ }
  }
  throw new Error('TWSE failed');
}

// Source B: Yahoo Finance quote
async function fetchYahoo(stock) {
  const symbol = `${stock}.TW`;
  const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=1d&interval=1m`;
  const resp = await tryDirectOrProxy(url);
  const json = await resp.json();
  const meta = json?.chart?.result?.[0]?.meta;
  const price = meta?.regularMarketPrice;
  if (typeof price !== 'number' || price <= 0) throw new Error('Yahoo no price');
  return price;
}

// Source C: Stooq (text/csv endpoint)
async function fetchStooq(stock) {
  const url = `https://stooq.com/q/l/?s=${stock}.tw&f=sd2t2ohlcv&h&e=csv`;
  const resp = await tryDirectOrProxy(url);
  const text = await resp.text();
  // CSV: Symbol,Date,Time,Open,High,Low,Close,Volume
  const lines = text.trim().split('\n');
  if (lines.length < 2) throw new Error('Stooq empty');
  const cols = lines[1].split(',');
  const close = parseFloat(cols[6]); // Close column
  if (isNaN(close) || close <= 0) throw new Error('Stooq no price');
  return close;
}

// Source D: Simulation (fallback)
function simulatedPrice(stock) {
  if (simPrice <= 0) {
    const seeds = { '2330': 900, '2317': 170, '0050': 160, '2454': 1200 };
    simPrice = seeds[stock] || 500;
  }
  const change = simPrice * (Math.random() - 0.5) * 0.01;
  simPrice = Math.round((simPrice + change) * 100) / 100;
  if (simPrice < 1) simPrice = 1;
  return simPrice;
}

// Main dispatcher â€” tries sources in priority order
const SOURCES = [
  { name: 'TWSE', fn: fetchTWSE },
  { name: 'Yahoo', fn: fetchYahoo },
  { name: 'Stooq', fn: fetchStooq },
];

async function fetchPrice(stock) {
  for (const src of SOURCES) {
    try {
      const price = await src.fn(stock);
      setSource(src.name);
      enableSimMode(false);
      return price;
    } catch (_) { /* try next */ }
  }
  // All real sources failed â€” fallback to simulation
  setSource('æ¨¡æ“¬');
  enableSimMode(true);
  return simulatedPrice(stock);
}

function setSource(name) {
  lastSource = name;
  const now = taipeiNow();
  lastUpdateTime = now.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  $('sourceBar').textContent = `ä¾†æºï¼š${lastSource} ï½œ æ›´æ–°ï¼š${lastUpdateTime}`;
}

function enableSimMode(on) {
  if (simMode === on) return;
  simMode = on;
  $('simBadge').className = 'sim-badge' + (on ? ' on' : '');
}

/* â”€â”€ Core loop â”€â”€ */
async function tick() {
  updateMarketBar();

  // Fetch price regardless (to show current price), but only run strategy during market hours
  let price;
  try {
    price = await fetchPrice(state.stock);
  } catch { return; }

  state.currentPrice = price;
  renderPrice();

  if (!isMarketOpen()) return;  // no strategy outside monitoring window

  // No auto-buy; user must use "æ‰‹å‹•è²·å…¥" or "é–‹å§‹ç›£æ§" (which does auto-buy)

  if (state.phase === 'holding') {
    if (price <= state.buyPrice * STOP_LOSS) {
      executeSell(price, 'åœæ');
    } else if (price >= state.buyPrice * ENTER_TP) {
      state.phase = 'trailing';
      state.highestPrice = price;
      addLog(`é€²å…¥åœåˆ©æ¨¡å¼ (ç¾åƒ¹ $${price}, è²·å…¥ $${state.buyPrice})`, 'neutral');
      saveState();
    }
  }

  if (state.phase === 'trailing') {
    if (price >= state.highestPrice * NEAR_HIGH) {
      state.highestPrice = Math.max(state.highestPrice, price);
    }
    if (price <= state.highestPrice * TP_EXIT) {
      executeSell(price, 'ç§»å‹•åœåˆ©');
    }
  }

  renderAll();
}

function executeSell(price, reason) {
  const sh = state.shares || 1000;
  const pnl = (price - state.buyPrice) * sh;
  const returnPct = ((price - state.buyPrice) / state.buyPrice) * 100;
  const trade = { buyPrice: state.buyPrice, sellPrice: price, pnl, returnPct, reason, shares: sh, buySource: state.buySource || 'auto' };
  state.trades.push(trade);
  state.phase = 'sold';
  state.buySource = '';
  const sign = pnl >= 0 ? '+' : '';
  addLog(
    `è³£å‡º ${sh} è‚¡ @ $${price}ï¼ˆ${reason}ï¼‰å ±é…¬ ${sign}${returnPct.toFixed(2)}%  æç›Š ${sign}$${pnl.toFixed(0)}`,
    pnl >= 0 ? 'up' : 'down'
  );
  saveState();
}

/* â”€â”€ Start / Stop / Reset â”€â”€ */
function startMonitor() {
  const inputStock = stockInput.value.trim() || '2330';
  const resuming = (state.phase === 'holding' || state.phase === 'trailing') && state.stock === inputStock;
  if (!resuming) {
    state.stock = inputStock;
    state.phase = 'idle';
    state.buyPrice = 0;
    state.highestPrice = 0;
    state.buySource = '';
  }
  simPrice = 0;
  // Read configurable poll interval
  const pollSec = Math.max(POLL_MIN / 1000, parseInt($('pollInput').value) || 5);
  POLL_MS = pollSec * 1000;
  $('pollInput').value = pollSec;
  // Read monitoring time window
  readMonitorTime();
  btnStart.disabled = true;
  btnStop.disabled = false;
  stockInput.disabled = true;
  stockSelect.disabled = true;
  $('pollInput').disabled = true;
  $('monitorStart').disabled = true;
  $('monitorEnd').disabled = true;
  $('loadNotice').style.display = 'none';
  const modeLabel = resuming ? 'çºŒç›£' : 'é–‹å§‹ç›£æ§';
  addLog(`${modeLabel} ${state.stock}ï¼ˆè¼ªè©¢ ${pollSec}sï¼Œæ™‚çª— ${MONITOR_START}~${MONITOR_END}ï¼‰`, 'neutral');
  saveState();
  tick();
  timer = setInterval(tick, POLL_MS);
}

/* Read monitoring time from UI inputs */
function readMonitorTime() {
  const s = $('monitorStart').value.trim();
  const e = $('monitorEnd').value.trim();
  if (/^\d{1,2}:\d{2}$/.test(s)) MONITOR_START = s.padStart(5, '0');
  if (/^\d{1,2}:\d{2}$/.test(e)) MONITOR_END = e.padStart(5, '0');
  $('monitorStart').value = MONITOR_START;
  $('monitorEnd').value = MONITOR_END;
}

/* â”€â”€ Manual Buy â”€â”€ */
async function doManualBuy() {
  if (state.phase === 'holding' || state.phase === 'trailing') {
    alert('å·²æœ‰æŒå€‰ï¼Œè«‹å…ˆè³£å‡ºæˆ–åœæ­¢ç›£æ§å¾Œæ‰èƒ½å†è²·å…¥');
    return;
  }
  const inputStock = stockInput.value.trim() || '2330';
  const sharesVal = parseInt($('manualBuyShares').value) || 1000;
  const priceVal = parseFloat($('manualBuyPrice').value);

  let buyP;
  if (!isNaN(priceVal) && priceVal > 0) {
    buyP = priceVal;
  } else {
    // fetch current price
    try {
      buyP = await fetchPrice(inputStock);
    } catch (_) {
      alert('ç„¡æ³•å–å¾—ç¾åƒ¹ï¼Œè«‹æ‰‹å‹•è¼¸å…¥è²·å…¥åƒ¹');
      return;
    }
  }

  state.stock = inputStock;
  state.buyPrice = buyP;
  state.highestPrice = buyP;
  state.currentPrice = buyP;
  state.shares = sharesVal;
  state.buySource = 'manual';
  state.phase = 'holding';
  SHARES = sharesVal;
  addLog(`æ‰‹å‹•è²·å…¥ ${sharesVal} è‚¡ ${inputStock} @ $${buyP}`, 'neutral');
  saveState();
  renderAll();

  // Auto-start monitoring if not already running
  if (!timer) {
    startMonitor();
  }
}

function stopMonitor() {
  clearInterval(timer);
  timer = null;
  btnStart.disabled = false;
  btnStop.disabled = true;
  stockInput.disabled = false;
  stockSelect.disabled = false;
  $('pollInput').disabled = false;
  $('monitorStart').disabled = false;
  $('monitorEnd').disabled = false;
  const hasPos = state.phase === 'holding' || state.phase === 'trailing';
  if (hasPos) {
    addLog('å·²åœæ­¢ç›£æ§ï¼ˆæŒå€‰ä¿ç•™ï¼‰', 'neutral');
  } else {
    addLog('ç›£æ§å·²åœæ­¢', 'neutral');
  }
  updateManualSellBtn();
  saveState();
}

/* â”€â”€ Manual Sell â”€â”€ */
async function doManualSell() {
  if (state.phase !== 'holding' && state.phase !== 'trailing') {
    alert('ç›®å‰ç„¡æŒå€‰ï¼Œç„¡æ³•è³£å‡º');
    return;
  }
  // Try to get fresh price
  let price = state.currentPrice;
  try {
    price = await fetchPrice(state.stock);
    state.currentPrice = price;
  } catch (_) { /* use last known price */ }
  executeSell(price, 'æ‰‹å‹•è³£å‡º');
  updateManualSellBtn();
  renderAll();
}

function updateManualSellBtn() {
  const hasPos = state.phase === 'holding' || state.phase === 'trailing';
  btnManualSell.disabled = !hasPos;
}

function doReset() {
  stopMonitor();
  state = resetState();
  simPrice = 0;
  enableSimMode(false);
  $('logBox').innerHTML = '<div class="entry" style="color:#64748b">å°šç„¡äº¤æ˜“è¨˜éŒ„</div>';
  renderAll();
  addLog('å·²é‡ç½®', 'neutral');
  saveState();
}

function doClearSave() {
  stopMonitor();
  state = resetState();
  simPrice = 0;
  enableSimMode(false);
  clearSave();
  $('logBox').innerHTML = '<div class="entry" style="color:#64748b">å°šç„¡äº¤æ˜“è¨˜éŒ„</div>';
  $('loadNotice').style.display = 'none';
  lastSource = 'â€”';
  lastUpdateTime = 'â€”';
  $('sourceBar').textContent = 'ä¾†æºï¼šâ€” ï½œ æ›´æ–°ï¼šâ€”';
  POLL_MS = 5000;
  $('pollInput').value = 5;
  MONITOR_START = '09:10';
  MONITOR_END = '12:00';
  $('monitorStart').value = '09:10';
  $('monitorEnd').value = '12:00';
  SHARES = 1000;
  $('manualBuyShares').value = 1000;
  $('manualBuyPrice').value = '';
  stockInput.value = '2330';
  stockSelect.value = '2330';
  renderAll();
  addLog('å­˜æª”å·²æ¸…é™¤ï¼Œå›åˆ°åˆå§‹ç‹€æ…‹', 'neutral');
}

/* â”€â”€ Render â”€â”€ */
function renderPrice() {
  $('dStock').textContent = state.stock;
  $('dPrice').textContent = state.currentPrice ? `$${state.currentPrice.toFixed(2)}` : 'â€”';
}

function renderAll() {
  renderPrice();
  updateManualSellBtn();
  $('dBuy').textContent = state.buyPrice ? `$${state.buyPrice.toFixed(2)}` : 'â€”';
  $('dHigh').textContent = state.highestPrice ? `$${state.highestPrice.toFixed(2)}` : 'â€”';
  $('dShares').textContent = (state.phase === 'holding' || state.phase === 'trailing') ? state.shares : 'â€”';
  const srcLabels = { manual: 'æ‰‹å‹•è²·å…¥', auto: 'è‡ªå‹•è²·å…¥' };
  $('dBuySource').textContent = state.buySource ? (srcLabels[state.buySource] || state.buySource) : 'â€”';
  $('dTimeWindow').textContent = `${MONITOR_START} ~ ${MONITOR_END}`;

  // state label
  const labels = { idle: 'ç­‰å¾…ä¸­', holding: 'æŒæœ‰', trailing: 'åœåˆ©æ¨¡å¼', sold: 'å·²è³£å‡º' };
  const el = $('dState');
  const hasPos = state.phase === 'holding' || state.phase === 'trailing';
  const stoppedSuffix = (hasPos && !timer) ? 'ï¼ˆæœªç›£æ§ï¼‰' : '';
  el.textContent = (labels[state.phase] || 'â€”') + stoppedSuffix;
  el.className = 'val ' + (state.phase === 'trailing' ? 'up' : state.phase === 'sold' ? 'neutral' : 'neutral');

  // current return
  const retEl = $('dReturn');
  if (state.phase === 'holding' || state.phase === 'trailing') {
    const pct = ((state.currentPrice - state.buyPrice) / state.buyPrice) * 100;
    retEl.textContent = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
    retEl.className = 'val ' + (pct >= 0 ? 'up' : 'down');
  } else if (state.phase === 'sold' && state.trades.length > 0) {
    const last = state.trades[state.trades.length - 1];
    retEl.textContent = (last.returnPct >= 0 ? '+' : '') + last.returnPct.toFixed(2) + '%';
    retEl.className = 'val ' + (last.returnPct >= 0 ? 'up' : 'down');
  } else {
    retEl.textContent = 'â€”';
    retEl.className = 'val neutral';
  }

  // cumulative stats
  const t = state.trades;
  $('sTrades').textContent = t.length;
  if (t.length > 0) {
    const wins = t.filter(x => x.pnl > 0).length;
    $('sWinRate').textContent = (wins / t.length * 100).toFixed(1) + '%';
    const avgRet = t.reduce((s, x) => s + x.returnPct, 0) / t.length;
    const avgEl = $('sAvgReturn');
    avgEl.textContent = (avgRet >= 0 ? '+' : '') + avgRet.toFixed(2) + '%';
    avgEl.className = 'val ' + (avgRet >= 0 ? 'up' : 'down');
    const totalPnl = t.reduce((s, x) => s + x.pnl, 0);
    const pnlEl = $('sTotalPnl');
    pnlEl.textContent = (totalPnl >= 0 ? '+' : '') + '$' + totalPnl.toFixed(0);
    pnlEl.className = 'val ' + (totalPnl >= 0 ? 'up' : 'down');
  } else {
    $('sWinRate').textContent = 'â€”';
    $('sAvgReturn').textContent = 'â€”';
    $('sAvgReturn').className = 'val neutral';
    $('sTotalPnl').textContent = '$0';
    $('sTotalPnl').className = 'val neutral';
  }
}

function addLog(msg, type) {
  const box = $('logBox');
  // remove placeholder
  if (box.querySelector('.entry[style]')) box.innerHTML = '';
  const now = taipeiNow();
  const ts = now.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  const cls = type === 'up' ? 'log-entry-up' : type === 'down' ? 'log-entry-down' : '';
  const div = document.createElement('div');
  div.className = 'entry ' + cls;
  div.textContent = `[${ts}] ${msg}`;
  box.prepend(div);
}

/* â”€â”€ Inventory Query â”€â”€ */
async function showInventory() {
  // Trigger a fresh price fetch if we have a stock to check
  if (state.stock) {
    try { state.currentPrice = await fetchPrice(state.stock); } catch (_) { /* use stale price */ }
  }

  const hasPos = state.phase === 'holding' || state.phase === 'trailing';
  const container = $('invContent');
  let html = '';

  if (hasPos) {
    const sh = state.shares || 1000;
    const pnl = (state.currentPrice - state.buyPrice) * sh;
    const retPct = ((state.currentPrice - state.buyPrice) / state.buyPrice) * 100;
    const sign = pnl >= 0 ? '+' : '';
    const cls = pnl >= 0 ? 'up' : 'down';
    const monitorLabel = timer ? '' : 'ï¼ˆç›£æ§å·²åœæ­¢ï¼‰';
    const phaseLabel = (state.phase === 'trailing' ? 'åœåˆ©æ¨¡å¼' : 'æŒæœ‰ä¸­') + monitorLabel;
    const srcLabel = state.buySource === 'manual' ? 'æ‰‹å‹•è²·å…¥' : 'è‡ªå‹•è²·å…¥';

    html += '<div class="inv-grid">';
    html += `<div><div class="lbl">è‚¡ç¥¨ä»£è™Ÿ</div><div class="val">${state.stock}</div></div>`;
    html += `<div><div class="lbl">æŒæœ‰ç‹€æ…‹</div><div class="val">${phaseLabel}</div></div>`;
    html += `<div><div class="lbl">æŒæœ‰è‚¡æ•¸</div><div class="val">${sh}</div></div>`;
    html += `<div><div class="lbl">è²·å…¥ä¾†æº</div><div class="val">${srcLabel}</div></div>`;
    html += `<div><div class="lbl">è²·å…¥åƒ¹</div><div class="val">$${state.buyPrice.toFixed(2)}</div></div>`;
    html += `<div><div class="lbl">ç¾åƒ¹</div><div class="val ${cls}">$${state.currentPrice.toFixed(2)}</div></div>`;
    html += `<div><div class="lbl">æœªå¯¦ç¾æç›Š</div><div class="val ${cls}">${sign}$${pnl.toFixed(0)}</div></div>`;
    html += `<div><div class="lbl">æœªå¯¦ç¾å ±é…¬ç‡</div><div class="val ${cls}">${sign}${retPct.toFixed(2)}%</div></div>`;
    if (state.phase === 'trailing') {
      html += `<div><div class="lbl">æœ€é«˜åƒ¹</div><div class="val up">$${state.highestPrice.toFixed(2)}</div></div>`;
    }
    html += `<div><div class="lbl">æœ€å¾Œæ›´æ–°</div><div class="val" style="font-size:.8rem">${lastUpdateTime}</div></div>`;
    html += `<div><div class="lbl">ä¾†æº</div><div class="val" style="font-size:.8rem">${lastSource}</div></div>`;
    html += '</div>';
  } else {
    html += '<div class="no-pos">ç›®å‰ç„¡æŒå€‰</div>';

    // Show last realized trade if any
    if (state.trades.length > 0) {
      const last = state.trades[state.trades.length - 1];
      const sign = last.pnl >= 0 ? '+' : '';
      const cls = last.pnl >= 0 ? 'up' : 'down';
      html += '<div class="section-title">æœ€è¿‘ä¸€æ¬¡å·²å¯¦ç¾äº¤æ˜“</div>';
      html += '<div class="last-trade">';
      html += `<div>è²·å…¥åƒ¹ï¼š$${last.buyPrice.toFixed(2)}</div>`;
      html += `<div>è³£å‡ºåƒ¹ï¼š$${last.sellPrice.toFixed(2)}</div>`;
      html += `<div>æç›Šï¼š<span class="val ${cls}" style="font-size:.82rem">${sign}$${last.pnl.toFixed(0)}</span></div>`;
      html += `<div>å ±é…¬ç‡ï¼š<span class="val ${cls}" style="font-size:.82rem">${sign}${last.returnPct.toFixed(2)}%</span></div>`;
      html += `<div>åŸå› ï¼š${last.reason}</div>`;
      html += '</div>';
    }

    html += '<div style="margin-top:10px;font-size:.75rem;color:#64748b;text-align:center">';
    html += `æœ€å¾Œæ›´æ–°ï¼š${lastUpdateTime} ï½œ ä¾†æºï¼š${lastSource}`;
    html += '</div>';
  }

  container.innerHTML = html;
  $('invOverlay').classList.add('show');
}

/* â”€â”€ Init â”€â”€ */
updateMarketBar();
setInterval(updateMarketBar, 30000);

// Load saved state from localStorage
(function initLoad() {
  const saved = loadState();
  if (!saved) { renderAll(); return; }

  state.stock = saved.stock;
  state.phase = saved.phase;
  state.buyPrice = saved.buyPrice;
  state.highestPrice = saved.highestPrice;
  state.currentPrice = saved.currentPrice;
  state.shares = saved.shares;
  state.buySource = saved.buySource;
  state.trades = saved.trades;

  lastSource = saved.source;
  lastUpdateTime = saved.sourceTime;
  $('sourceBar').textContent = `ä¾†æºï¼š${lastSource} ï½œ æ›´æ–°ï¼š${lastUpdateTime}`;

  POLL_MS = saved.pollSec * 1000;
  $('pollInput').value = saved.pollSec;

  MONITOR_START = saved.monitorStart;
  MONITOR_END = saved.monitorEnd;
  $('monitorStart').value = MONITOR_START;
  $('monitorEnd').value = MONITOR_END;

  SHARES = saved.shares;

  stockInput.value = saved.stock;
  if ([...stockSelect.options].some(o => o.value === saved.stock)) stockSelect.value = saved.stock;

  // Restore trade log entries into logBox
  if (saved.trades.length > 0) {
    $('logBox').innerHTML = '';
    // Show last 20 trades in log (most recent first â€” they're stored oldest-first)
    const recent = saved.trades.slice(-20);
    for (let i = recent.length - 1; i >= 0; i--) {
      const t = recent[i];
      const sign = t.pnl >= 0 ? '+' : '';
      const cls = t.pnl >= 0 ? 'log-entry-up' : 'log-entry-down';
      const div = document.createElement('div');
      div.className = 'entry ' + cls;
      div.textContent = `è³£å‡º @ $${t.sellPrice}ï¼ˆ${t.reason}ï¼‰å ±é…¬ ${sign}${t.returnPct.toFixed(2)}%  æç›Š ${sign}$${t.pnl.toFixed(0)}`;
      $('logBox').appendChild(div);
    }
  }

  renderAll();

  // Show notice if there's a meaningful saved position
  const hasPosition = saved.phase === 'holding' || saved.phase === 'trailing';
  const hasTrades = saved.trades.length > 0;
  if (hasPosition || hasTrades) {
    const notice = $('loadNotice');
    if (hasPosition) {
      const srcTag = saved.buySource === 'manual' ? 'æ‰‹å‹•è²·å…¥' : 'è‡ªå‹•è²·å…¥';
      notice.textContent = `å·²è¼‰å…¥ä¸Šæ¬¡åº«å­˜ï¼ˆ${saved.stock}ï¼Œ${saved.phase === 'holding' ? 'æŒæœ‰' : 'åœåˆ©æ¨¡å¼'}ï¼Œ${srcTag} ${saved.shares}è‚¡ @ $${saved.buyPrice}ï¼‰ï¼Œå¯æŒ‰ã€Œé–‹å§‹ç›£æ§ã€ç¹¼çºŒæˆ–ã€Œæ‰‹å‹•è³£å‡ºã€å¹³å€‰`;
    } else {
      notice.textContent = `å·²è¼‰å…¥ä¸Šæ¬¡å­˜æª”ï¼ˆ${saved.trades.length} ç­†äº¤æ˜“è¨˜éŒ„ï¼‰ï¼Œå¯ç¹¼çºŒç›£æ§`;
    }
    notice.style.display = 'block';
  }
})();

</script>
</body>
</html>
