<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Plumber Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
#wrap {
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  width: 100%; height: 100%;
}
canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  background: #5c94fc;
}
#ui {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
  display: flex; align-items: center; justify-content: center;
}
#overlay {
  display: none;
  flex-direction: column; align-items: center; gap: 16px;
  pointer-events: auto;
  background: rgba(0,0,0,0.7);
  padding: 32px 48px; border-radius: 12px;
  color: #fff; font-family: monospace; text-align: center;
}
#overlay h1 { font-size: 28px; }
#overlay p { font-size: 18px; }
#overlay button {
  font-family: monospace; font-size: 20px;
  padding: 12px 32px; border: none; border-radius: 8px;
  background: #e74c3c; color: #fff; cursor: pointer;
}
#overlay button:hover { background: #c0392b; }
#hud {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
}
#hud-top {
  display: flex; justify-content: space-between; align-items: flex-start;
  padding: 10px 16px;
  font-family: monospace; font-size: 18px;
  color: #fff; text-shadow: 2px 2px 0 #000;
}
#hud-left { text-align: left; }
#hud-right { text-align: right; }
#hud-time { font-size: 22px; font-weight: bold; }
#hud-level { font-size: 16px; margin-top: 2px; }
#score-display { font-size: 22px; }
#hud-level-bar {
  margin-top: 4px; width: 100px; height: 6px;
  background: rgba(255,255,255,0.25); border-radius: 3px;
  overflow: hidden;
}
#hud-level-fill {
  height: 100%; width: 0%; border-radius: 3px;
  transition: width 0.5s ease, background 0.5s ease;
}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
</div>
<div id="hud">
  <div id="hud-top">
    <div id="hud-left">
      <div id="hud-time">00:00</div>
      <div id="hud-level">Lv.1 EASY</div>
      <div id="hud-level-bar"><div id="hud-level-fill"></div></div>
    </div>
    <div id="hud-right">
      <div id="score-display">SCORE: 0</div>
    </div>
  </div>
</div>
<div id="ui">
  <div id="overlay">
    <h1 id="ol-title">Plumber Runner</h1>
    <p id="ol-msg">Press SPACE / Tap to Start</p>
    <p id="ol-score"></p>
    <button id="ol-btn">START</button>
  </div>
</div>

<script>
// ── Constants ──────────────────────────────────────────
const DESIGN_W = 800;
const DESIGN_H = 400;
const GROUND_H = 60;
const GRAVITY = 0.55;
const JUMP_INITIAL = -7.0;         // short-tap: small jump
const JUMP_HOLD_ACCEL = -0.55;     // long-press: stronger boost per frame
const JUMP_HOLD_MAX_T = 16;        // long-press: more frames of boost
const TALL_PIPE_THRESHOLD = 140;   // pipes >= this height trigger staircase logic
const SCROLL_SPEED_BASE = 3.5;
const SCROLL_ACCEL = 0.0003;
const PIPE_MIN_GAP = 240;
const PIPE_MAX_GAP = 360;
const PIPE_HEIGHTS_BOTTOM = [60, 90, 120, 150, 75, 105];
const PIPE_HEIGHTS_TOP = [60, 80, 100, 120, 140];
const PIPE_W = 48;
const LIP_W = 56;
const LIP_H = 16;
const CRUSH_THRESHOLD = 4; // pixels of squeeze to count as crushed

// ── Lip Corner Forgiveness ──────────────────────────
// When the player is beside a pipe and jumps upward, the lip overhang
// (LIP_W > PIPE_W) can clip the player's head even though the overlap is tiny.
// LIP_CORNER_FORGIVE defines the width of the "forgiveness zone" on each side
// of the lip: if the player's horizontal overlap with the lip is within this
// margin while moving upward, the collision nudges the player sideways instead
// of blocking the jump. This prevents the frustrating "bonk" on lip corners
// while still blocking passage through the pipe body.
const LIP_CORNER_FORGIVE = 14; // pixels of lip-edge forgiveness per side (increased from 8)

// ── Wall-Kick Nudge ────────────────────────────────────
// When the player is flush against a pipe wall and initiates a jump,
// give a one-time outward nudge so the lip overhang doesn't immediately
// block the ascent. Only fires once per jump, only on pipe body side contact.
const WALL_NUDGE_PX = 3; // pixels of outward push on jump-start near wall

// ── Head-Center Rule ───────────────────────────────────
// For pipe-lip top-bonk: only count as a ceiling hit if the player's
// head center region overlaps the lip. Corner brushes become side-deflections.
const HEAD_CENTER_RATIO = 0.45; // fraction of player width that counts as "center"

// ── Breakable Brick Constants ─────────────────────────
const BRICK_W = 32;
const BRICK_H = 24;
const BRICK_SCORE = 5;            // points per brick broken
const BRICK_FRAGMENT_COUNT = 6;   // number of debris fragments
const BRICK_SPAWN_CHANCE = 0.30;  // chance to spawn brick with pipe group
const STANDALONE_BRICK_MIN_COUNT = 1;
const STANDALONE_BRICK_MAX_COUNT = 3;

// ── Difficulty System ─────────────────────────────────
// 5 levels with smooth interpolation between them
// Each level defines target values; actual values lerp continuously
const DIFFICULTY_LEVELS = [
  { name: 'EASY',   time: 0,   speedMul: 1.0, gapMin: 280, gapMax: 380, pipeMaxH: 150, topMaxH: 140, pairChance: 0.35, brickReplace: 0.15 },
  { name: 'NORMAL', time: 30,  speedMul: 1.25, gapMin: 250, gapMax: 340, pipeMaxH: 170, topMaxH: 155, pairChance: 0.40, brickReplace: 0.18 },
  { name: 'HARD',   time: 75,  speedMul: 1.55, gapMin: 220, gapMax: 300, pipeMaxH: 195, topMaxH: 170, pairChance: 0.47, brickReplace: 0.22 },
  { name: 'EXPERT', time: 140, speedMul: 1.85, gapMin: 195, gapMax: 270, pipeMaxH: 220, topMaxH: 190, pairChance: 0.52, brickReplace: 0.25 },
  { name: 'INSANE', time: 240, speedMul: 2.15, gapMin: 175, gapMax: 245, pipeMaxH: 240, topMaxH: 200, pairChance: 0.55, brickReplace: 0.28 },
];

// ── Swept AABB Settings ──────────────────────────────
const SWEEP_MAX_ITERATIONS = 4;   // max resolve iterations per frame
const SWEEP_EPSILON = 0.001;      // floating-point tolerance for contact

// ── Debug Mode ───────────────────────────────────────
const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === '1';

// ── Sprite Mode ─────────────────────────────────────
// Render mode: 'sprite' uses sprite.png + sprite.json, 'procedural' uses code-drawn character.
// Default: attempt sprite mode; fallback to procedural if loading fails.
let spriteMode = 'sprite'; // 'sprite' | 'procedural'
let spriteImg = null;       // Image object when loaded
let spriteData = null;      // Parsed sprite.json data
let spriteReady = false;    // true when both image + json loaded successfully

function loadSprite() {
  const basePath = 'assets/';

  // Load JSON first, then use it to determine image path
  fetch(basePath + 'sprite.json')
    .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
    .then(data => {
      spriteData = data;
      // Now load the image using the path from JSON
      const img = new Image();
      img.onload = () => {
        spriteImg = img;
        onSpriteReady();
      };
      img.onerror = () => {
        console.warn('[Sprite] Failed to load ' + data.meta.image + ', falling back to procedural.');
        spriteMode = 'procedural';
      };
      img.src = basePath + data.meta.image;
    })
    .catch(err => {
      console.warn('[Sprite] Failed to load sprite.json, falling back to procedural:', err.message);
      spriteMode = 'procedural';
    });
}

function onSpriteReady() {
  spriteReady = true;
  spriteMode = 'sprite';
  if (DEBUG_MODE) {
    console.log('%c[Sprite] Sprite mode active — ' + spriteData.meta.columns + ' frames loaded', 'color: #42d4f4');
  }
}

// Resolve the sprite frame index for the current animation state and player frame
function getSpriteFrame() {
  if (!spriteData || !spriteData.animations) return 0;
  const anim = spriteData.animations[player.animState];
  if (!anim) return 0;
  if (anim.frames.length === 1) return anim.frames[0];
  // For multi-frame animations (run), use player.frame to index
  return anim.frames[player.frame % anim.frames.length];
}

// Draw player using the sprite sheet
function drawPlayerSprite(px, py) {
  if (!spriteReady || !spriteImg || !spriteData) return;
  const frameIdx = getSpriteFrame();
  const fw = spriteData.meta.frameWidth;
  const fh = spriteData.meta.frameHeight;
  const cols = spriteData.meta.columns;
  const sx = (frameIdx % cols) * fw;
  const sy = Math.floor(frameIdx / cols) * fh;
  ctx.drawImage(spriteImg, sx, sy, fw, fh, Math.round(px), Math.round(py), fw, fh);
}

// ── Canvas Setup ───────────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = DESIGN_W;
canvas.height = DESIGN_H;

function resizeCanvas() {
  const ww = window.innerWidth;
  const wh = window.innerHeight;
  const scale = Math.min(ww / DESIGN_W, wh / DESIGN_H);
  canvas.style.width = (DESIGN_W * scale) + 'px';
  canvas.style.height = (DESIGN_H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ── UI refs ────────────────────────────────────────────
const overlay = document.getElementById('overlay');
const olTitle = document.getElementById('ol-title');
const olMsg = document.getElementById('ol-msg');
const olScore = document.getElementById('ol-score');
const olBtn = document.getElementById('ol-btn');
const scoreDisplay = document.getElementById('score-display');
const hudTime = document.getElementById('hud-time');
const hudLevel = document.getElementById('hud-level');
const hudLevelFill = document.getElementById('hud-level-fill');

// ── Game State ─────────────────────────────────────────
let state = 'title'; // title | playing | dead
let score = 0;
let highScore = 0;
let frameCount = 0;
let scrollSpeed = SCROLL_SPEED_BASE;
let jumpPressed = false;
let jumpConsumed = false;  // true after jump initiated; must release to jump again
let jumpHoldFrames = 0;
let wallNudgeUsed = false; // true after wall-kick nudge fires; reset on landing

// ── Edge-Protection Debug Overlay ──────────────────────
// Stores short-lived messages like "EDGE-FORGIVE" / "WALL-NUDGE" for display
let edgeDebugMsgs = []; // { text, ttl (frames remaining) }
let survivalTime = 0;       // seconds survived
let diffLevel = 0;          // current difficulty level index (0-4)
let diffProgress = 0;       // 0..1 progress within current level toward next

// ── Player ─────────────────────────────────────────────
const player = {
  x: 120, y: 0, w: 28, h: 36,
  vy: 0, onGround: true, frame: 0,
  animState: 'idle',  // idle | run | jump_up | fall | land
  landTimer: 0,       // frames remaining in land animation
  wasOnGround: true,  // track previous frame for landing detection
};

// ── Pipes ──────────────────────────────────────────────
// Each pipe: { x, h, fromTop (bool), scored }
let pipes = [];

// ── Clouds (decorative) ────────────────────────────────
let clouds = [];
function initClouds() {
  clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * DESIGN_W,
      y: 20 + Math.random() * 100,
      w: 50 + Math.random() * 60,
      speed: 0.3 + Math.random() * 0.5,
    });
  }
}

// ── Hills (decorative bg) ──────────────────────────────
let hills = [];
function initHills() {
  hills = [];
  for (let i = 0; i < 4; i++) {
    hills.push({
      x: i * 250,
      w: 180 + Math.random() * 100,
      h: 40 + Math.random() * 40,
    });
  }
}

// ── Breakable Bricks ──────────────────────────────────
// Each brick: { x, y, w, h, broken }
let bricks = [];

// ── Brick Fragments (debris particles) ────────────────
// Each fragment: { x, y, vx, vy, size, color, life }
let fragments = [];

// ── Score popups (floating +5 text) ───────────────────
// Each popup: { x, y, text, life }
let scorePopups = [];

// ── Drawing helpers ────────────────────────────────────

function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), w, h);
}

// ── Animation State Machine ───────────────────────────
// States: idle, run, jump_up, fall, land
const LAND_DURATION = 6; // frames for land squash animation

function updateAnimState() {
  const prev = player.animState;

  // Landing detection: was airborne, now on ground
  if (!player.wasOnGround && player.onGround && prev !== 'land') {
    player.animState = 'land';
    player.landTimer = LAND_DURATION;
    player.wasOnGround = player.onGround;
    return;
  }

  player.wasOnGround = player.onGround;

  // Land animation countdown
  if (player.animState === 'land') {
    player.landTimer--;
    if (player.landTimer <= 0) {
      player.animState = 'run';
    }
    return;
  }

  // Airborne states
  if (!player.onGround) {
    if (player.vy < -0.5) {
      player.animState = 'jump_up';
    } else {
      player.animState = 'fall';
    }
    return;
  }

  // On ground and not landing
  player.animState = 'run';
}

// Draw the player character — original pixel "Bolt" explorer
// 28x36 px, fully original design: spiky-haired explorer with visor & jetpack
// NOT derived from any Nintendo or copyrighted IP
function drawPlayer(px, py, frame) {
  // Sprite mode: use sprite sheet if available
  if (spriteMode === 'sprite' && spriteReady) {
    drawPlayerSprite(px, py);
    return;
  }
  // Procedural mode: code-drawn character below
  const x = Math.round(px);
  const y = Math.round(py);
  const st = player.animState;

  // ── Original color palette — "Bolt" the Explorer ──
  const HAIR    = '#2d1b69';  // deep indigo hair
  const HAIR_HI = '#5b3fbf';  // hair highlight
  const SKIN    = '#f0c090';  // peach skin
  const SKIN_SH = '#c89060';  // skin shadow
  const VISOR   = '#00e5ff';  // electric cyan visor
  const VISOR_D = '#0097a7';  // visor rim
  const JACKET  = '#d84315';  // burnt orange jacket
  const JACK_HI = '#ff7043';  // jacket highlight
  const JACK_SH = '#bf360c';  // jacket shadow
  const PACK    = '#546e7a';  // grey-blue jetpack
  const PACK_LT = '#78909c';  // pack highlight
  const VENT    = '#ff6d00';  // jetpack vent glow
  const CARGO   = '#37474f';  // dark cargo pants
  const CARGO_L = '#607d8b';  // cargo lighter
  const BOOTS_C = '#4e342e';  // dark leather boots
  const BOOTS_H = '#6d4c41';  // boots highlight
  const BUCKLE  = '#ffd600';  // yellow utility buckle
  const MOUTH   = '#e64a19';  // mouth/expression

  // ── IDLE: relaxed stance, subtle breathing bob ──
  if (st === 'idle') {
    const bob = Math.sin(frameCount * 0.06) * 1.5;
    const by = y + Math.round(bob);
    // Hair — tall spiky
    drawPixelRect(x + 7, by - 4, 4, 6, HAIR);
    drawPixelRect(x + 11, by - 6, 4, 8, HAIR);
    drawPixelRect(x + 15, by - 3, 4, 5, HAIR);
    drawPixelRect(x + 5, by + 0, 18, 4, HAIR);
    drawPixelRect(x + 8, by - 3, 3, 3, HAIR_HI);
    drawPixelRect(x + 13, by - 5, 2, 4, HAIR_HI);
    // Head
    drawPixelRect(x + 6, by + 4, 16, 10, SKIN);
    drawPixelRect(x + 6, by + 10, 4, 4, SKIN_SH);
    // Visor
    drawPixelRect(x + 6, by + 5, 16, 5, VISOR_D);
    drawPixelRect(x + 7, by + 6, 6, 3, VISOR);
    drawPixelRect(x + 15, by + 6, 6, 3, VISOR);
    drawPixelRect(x + 8, by + 6, 2, 1, '#b2ffff'); // visor glint
    // Mouth — relaxed
    drawPixelRect(x + 13, by + 11, 4, 2, MOUTH);
    // Body — jacket
    drawPixelRect(x + 6, by + 14, 16, 8, JACKET);
    drawPixelRect(x + 6, by + 14, 4, 6, JACK_HI);
    drawPixelRect(x + 18, by + 16, 4, 4, JACK_SH);
    // Jetpack (back)
    drawPixelRect(x + 22, by + 14, 4, 8, PACK);
    drawPixelRect(x + 22, by + 14, 4, 2, PACK_LT);
    drawPixelRect(x + 23, by + 22, 2, 2, VENT);
    // Belt + buckle
    drawPixelRect(x + 6, by + 22, 16, 2, CARGO);
    drawPixelRect(x + 11, by + 22, 6, 2, BUCKLE);
    // Arms at sides
    drawPixelRect(x + 2, by + 15, 4, 6, JACKET);
    drawPixelRect(x + 2, by + 21, 4, 2, SKIN);
    // Legs — standing straight
    drawPixelRect(x + 7, by + 24, 6, 8, CARGO);
    drawPixelRect(x + 15, by + 24, 6, 8, CARGO);
    drawPixelRect(x + 7, by + 26, 2, 2, CARGO_L);
    drawPixelRect(x + 17, by + 26, 2, 2, CARGO_L);
    // Boots
    drawPixelRect(x + 5, by + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 15, by + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 6, by + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 16, by + 32, 3, 1, BOOTS_H);
    return;
  }

  // ── LAND: squash impact pose ──
  if (st === 'land') {
    // Hair — compressed flat
    drawPixelRect(x + 4, y + 6, 20, 3, HAIR);
    drawPixelRect(x + 6, y + 4, 4, 3, HAIR);
    drawPixelRect(x + 16, y + 5, 4, 2, HAIR);
    // Head — squished
    drawPixelRect(x + 5, y + 9, 18, 7, SKIN);
    drawPixelRect(x + 5, y + 13, 4, 3, SKIN_SH);
    // Visor
    drawPixelRect(x + 5, y + 10, 18, 4, VISOR_D);
    drawPixelRect(x + 6, y + 11, 6, 2, VISOR);
    drawPixelRect(x + 14, y + 11, 6, 2, VISOR);
    // Mouth — strained
    drawPixelRect(x + 12, y + 14, 5, 2, MOUTH);
    // Body — wide squash
    drawPixelRect(x + 2, y + 16, 24, 5, JACKET);
    drawPixelRect(x + 2, y + 16, 6, 3, JACK_HI);
    drawPixelRect(x + 22, y + 17, 4, 3, JACK_SH);
    // Jetpack
    drawPixelRect(x + 24, y + 16, 4, 5, PACK);
    drawPixelRect(x + 25, y + 21, 2, 2, VENT);
    // Belt
    drawPixelRect(x + 6, y + 21, 16, 2, CARGO);
    drawPixelRect(x + 10, y + 21, 8, 2, BUCKLE);
    // Arms — bracing wide
    drawPixelRect(x + 0, y + 17, 4, 5, JACKET);
    drawPixelRect(x + 0, y + 22, 3, 2, SKIN);
    // Legs — wide squat
    drawPixelRect(x + 2, y + 23, 8, 5, CARGO);
    drawPixelRect(x + 18, y + 23, 8, 5, CARGO);
    drawPixelRect(x + 4, y + 25, 2, 2, CARGO_L);
    drawPixelRect(x + 20, y + 25, 2, 2, CARGO_L);
    // Boots — wide stance
    drawPixelRect(x + 0, y + 28, 10, 4, BOOTS_C);
    drawPixelRect(x + 18, y + 28, 10, 4, BOOTS_C);
    drawPixelRect(x + 1, y + 28, 3, 1, BOOTS_H);
    drawPixelRect(x + 19, y + 28, 3, 1, BOOTS_H);
    // Dust puffs
    if (player.landTimer > 3) {
      ctx.fillStyle = 'rgba(180,160,130,0.6)';
      ctx.fillRect(x - 4, y + 30, 5, 3);
      ctx.fillRect(x + 27, y + 30, 5, 3);
      ctx.fillStyle = 'rgba(180,160,130,0.3)';
      ctx.fillRect(x - 6, y + 29, 3, 2);
      ctx.fillRect(x + 31, y + 29, 3, 2);
    }
    return;
  }

  // ── JUMP_UP: arms raised, legs tucked, visor glowing ──
  if (st === 'jump_up') {
    // Hair — streaming upward, wind-blown
    drawPixelRect(x + 6, y - 4, 4, 6, HAIR);
    drawPixelRect(x + 10, y - 6, 5, 8, HAIR);
    drawPixelRect(x + 16, y - 3, 4, 5, HAIR);
    drawPixelRect(x + 5, y + 1, 18, 3, HAIR);
    drawPixelRect(x + 8, y - 4, 2, 3, HAIR_HI);
    drawPixelRect(x + 12, y - 5, 3, 4, HAIR_HI);
    // Head
    drawPixelRect(x + 6, y + 4, 16, 10, SKIN);
    drawPixelRect(x + 6, y + 10, 4, 4, SKIN_SH);
    // Visor — bright glow
    drawPixelRect(x + 6, y + 5, 16, 5, VISOR_D);
    drawPixelRect(x + 7, y + 6, 6, 3, VISOR);
    drawPixelRect(x + 15, y + 6, 6, 3, VISOR);
    drawPixelRect(x + 8, y + 6, 3, 2, '#b2ffff');
    drawPixelRect(x + 17, y + 6, 2, 1, '#b2ffff');
    // Mouth — open excited
    drawPixelRect(x + 13, y + 12, 4, 2, MOUTH);
    // Body
    drawPixelRect(x + 6, y + 14, 16, 8, JACKET);
    drawPixelRect(x + 6, y + 14, 4, 6, JACK_HI);
    drawPixelRect(x + 18, y + 16, 4, 4, JACK_SH);
    // Jetpack — thrust glow!
    drawPixelRect(x + 22, y + 14, 4, 8, PACK);
    drawPixelRect(x + 22, y + 14, 4, 2, PACK_LT);
    drawPixelRect(x + 22, y + 22, 4, 3, VENT);
    drawPixelRect(x + 23, y + 25, 2, 2 + Math.round(Math.random()), '#ff9100');
    // Arms — raised up
    drawPixelRect(x + 1, y + 8, 5, 4, JACKET);
    drawPixelRect(x + 0, y + 4, 4, 5, JACKET);
    drawPixelRect(x + 0, y + 2, 4, 3, SKIN);
    drawPixelRect(x + 22, y + 8, 5, 4, JACKET);
    drawPixelRect(x + 24, y + 4, 4, 5, JACKET);
    drawPixelRect(x + 24, y + 2, 4, 3, SKIN);
    // Belt
    drawPixelRect(x + 6, y + 22, 16, 2, CARGO);
    drawPixelRect(x + 11, y + 22, 6, 2, BUCKLE);
    // Legs — tucked
    drawPixelRect(x + 7, y + 24, 6, 4, CARGO);
    drawPixelRect(x + 15, y + 24, 6, 4, CARGO);
    // Boots — tucked under
    drawPixelRect(x + 6, y + 28, 7, 4, BOOTS_C);
    drawPixelRect(x + 15, y + 28, 7, 4, BOOTS_C);
    drawPixelRect(x + 7, y + 28, 3, 1, BOOTS_H);
    drawPixelRect(x + 16, y + 28, 3, 1, BOOTS_H);
    return;
  }

  // ── FALL: arms spread, legs dangling, worried face ──
  if (st === 'fall') {
    // Hair — blown back, flattened
    drawPixelRect(x + 5, y + 2, 18, 3, HAIR);
    drawPixelRect(x + 20, y + 1, 6, 4, HAIR);
    drawPixelRect(x + 22, y + 3, 4, 2, HAIR_HI);
    // Head
    drawPixelRect(x + 6, y + 5, 16, 10, SKIN);
    drawPixelRect(x + 6, y + 11, 4, 4, SKIN_SH);
    // Visor — dim
    drawPixelRect(x + 6, y + 6, 16, 5, VISOR_D);
    drawPixelRect(x + 7, y + 7, 6, 3, VISOR);
    drawPixelRect(x + 15, y + 7, 6, 3, VISOR);
    // Mouth — worried O shape
    drawPixelRect(x + 13, y + 12, 3, 3, MOUTH);
    drawPixelRect(x + 14, y + 13, 1, 1, SKIN);
    // Body
    drawPixelRect(x + 6, y + 15, 16, 8, JACKET);
    drawPixelRect(x + 6, y + 15, 4, 6, JACK_HI);
    drawPixelRect(x + 18, y + 17, 4, 4, JACK_SH);
    // Jetpack — idle
    drawPixelRect(x + 22, y + 15, 4, 8, PACK);
    drawPixelRect(x + 22, y + 15, 4, 2, PACK_LT);
    drawPixelRect(x + 23, y + 23, 2, 1, VENT);
    // Arms — spread wide for balance
    drawPixelRect(x + 0, y + 14, 6, 4, JACKET);
    drawPixelRect(x + 0, y + 12, 4, 3, JACKET);
    drawPixelRect(x + 0, y + 12, 3, 2, SKIN);
    drawPixelRect(x + 22, y + 16, 6, 4, JACKET);
    drawPixelRect(x + 26, y + 14, 2, 3, JACKET);
    drawPixelRect(x + 26, y + 14, 2, 2, SKIN);
    // Belt
    drawPixelRect(x + 6, y + 23, 16, 2, CARGO);
    drawPixelRect(x + 11, y + 23, 6, 2, BUCKLE);
    // Legs — dangling apart
    drawPixelRect(x + 6, y + 25, 6, 7, CARGO);
    drawPixelRect(x + 16, y + 25, 6, 7, CARGO);
    drawPixelRect(x + 8, y + 27, 2, 2, CARGO_L);
    drawPixelRect(x + 18, y + 27, 2, 2, CARGO_L);
    // Boots — dangling
    drawPixelRect(x + 5, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 15, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 6, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 16, y + 32, 3, 1, BOOTS_H);
    return;
  }

  // ── RUN: 4-frame cycle with dynamic limbs ──
  // Hair — bouncing tuft
  const hbob = (frame % 2 === 0) ? 0 : -1;
  drawPixelRect(x + 7, y - 2 + hbob, 4, 4, HAIR);
  drawPixelRect(x + 11, y - 4 + hbob, 5, 6, HAIR);
  drawPixelRect(x + 16, y - 1 + hbob, 4, 3, HAIR);
  drawPixelRect(x + 5, y + 1, 18, 3, HAIR);
  drawPixelRect(x + 9, y - 2 + hbob, 2, 3, HAIR_HI);
  drawPixelRect(x + 13, y - 3 + hbob, 2, 3, HAIR_HI);
  // Head
  drawPixelRect(x + 6, y + 4, 16, 10, SKIN);
  drawPixelRect(x + 6, y + 10, 4, 4, SKIN_SH);
  // Visor
  drawPixelRect(x + 6, y + 5, 16, 5, VISOR_D);
  drawPixelRect(x + 7, y + 6, 6, 3, VISOR);
  drawPixelRect(x + 15, y + 6, 6, 3, VISOR);
  drawPixelRect(x + 8, y + 6, 2, 1, '#b2ffff');
  // Mouth — determined grin
  drawPixelRect(x + 13, y + 11, 5, 2, MOUTH);
  // Body
  drawPixelRect(x + 6, y + 14, 16, 8, JACKET);
  drawPixelRect(x + 6, y + 14, 4, 6, JACK_HI);
  drawPixelRect(x + 18, y + 16, 4, 4, JACK_SH);
  // Jetpack
  drawPixelRect(x + 22, y + 14, 4, 8, PACK);
  drawPixelRect(x + 22, y + 14, 4, 2, PACK_LT);
  drawPixelRect(x + 23, y + 22, 2, 2, VENT);
  // Belt
  drawPixelRect(x + 6, y + 22, 16, 2, CARGO);
  drawPixelRect(x + 11, y + 22, 6, 2, BUCKLE);

  // ── Arms & Legs — 4-frame run cycle ──
  const phase = frame % 4;
  if (phase === 0) {
    // Left arm forward, right arm back
    drawPixelRect(x + 0, y + 16, 6, 5, JACKET);
    drawPixelRect(x + 0, y + 21, 4, 2, SKIN);
    drawPixelRect(x + 22, y + 13, 4, 5, JACKET);
    drawPixelRect(x + 22, y + 13, 3, 2, SKIN);
    // Left leg forward, right leg back
    drawPixelRect(x + 4, y + 24, 7, 8, CARGO);
    drawPixelRect(x + 6, y + 26, 2, 2, CARGO_L);
    drawPixelRect(x + 16, y + 26, 6, 6, CARGO);
    drawPixelRect(x + 2, y + 32, 9, 4, BOOTS_C);
    drawPixelRect(x + 3, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 16, y + 32, 8, 4, BOOTS_C);
  } else if (phase === 1) {
    // Contact — both legs under body
    drawPixelRect(x + 1, y + 15, 5, 4, JACKET);
    drawPixelRect(x + 1, y + 19, 4, 2, SKIN);
    drawPixelRect(x + 22, y + 15, 4, 4, JACKET);
    drawPixelRect(x + 22, y + 19, 3, 2, SKIN);
    drawPixelRect(x + 7, y + 24, 6, 8, CARGO);
    drawPixelRect(x + 9, y + 26, 2, 2, CARGO_L);
    drawPixelRect(x + 15, y + 24, 6, 8, CARGO);
    drawPixelRect(x + 17, y + 26, 2, 2, CARGO_L);
    drawPixelRect(x + 5, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 6, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 15, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 16, y + 32, 3, 1, BOOTS_H);
  } else if (phase === 2) {
    // Right arm forward, left arm back (mirror of 0)
    drawPixelRect(x + 22, y + 16, 6, 5, JACKET);
    drawPixelRect(x + 24, y + 21, 4, 2, SKIN);
    drawPixelRect(x + 2, y + 13, 4, 5, JACKET);
    drawPixelRect(x + 2, y + 13, 3, 2, SKIN);
    // Right leg forward, left leg back
    drawPixelRect(x + 15, y + 24, 7, 8, CARGO);
    drawPixelRect(x + 17, y + 26, 2, 2, CARGO_L);
    drawPixelRect(x + 6, y + 26, 6, 6, CARGO);
    drawPixelRect(x + 15, y + 32, 9, 4, BOOTS_C);
    drawPixelRect(x + 16, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 4, y + 32, 8, 4, BOOTS_C);
  } else {
    // phase 3: passing — legs close, arms neutral
    drawPixelRect(x + 1, y + 16, 5, 3, JACKET);
    drawPixelRect(x + 1, y + 19, 3, 2, SKIN);
    drawPixelRect(x + 22, y + 16, 5, 3, JACKET);
    drawPixelRect(x + 23, y + 19, 3, 2, SKIN);
    drawPixelRect(x + 8, y + 24, 6, 8, CARGO);
    drawPixelRect(x + 10, y + 26, 2, 2, CARGO_L);
    drawPixelRect(x + 14, y + 24, 6, 8, CARGO);
    drawPixelRect(x + 16, y + 26, 2, 2, CARGO_L);
    drawPixelRect(x + 6, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 7, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 14, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 15, y + 32, 3, 1, BOOTS_H);
  }
}

// Get pipe collision rectangles
// Returns { lipRect, bodyRect, topY (top of entire pipe visual) }
function getPipeRects(pipe) {
  // Marker pipes (h=0, used for brick-replaced spawns) have no collision
  if (pipe.h <= 0) {
    return {
      lipRect: { x: pipe.x, y: -100, w: 0, h: 0 },
      bodyRect: { x: pipe.x, y: -100, w: 0, h: 0 },
      standY: null,
    };
  }
  const groundY = DESIGN_H - GROUND_H;
  const lipOffset = (LIP_W - PIPE_W) / 2;
  if (!pipe.fromTop) {
    // Bottom pipe
    const topY = groundY - pipe.h;
    return {
      lipRect: { x: pipe.x, y: topY, w: LIP_W, h: LIP_H },
      bodyRect: { x: pipe.x + lipOffset, y: topY + LIP_H, w: PIPE_W, h: pipe.h - LIP_H },
      standY: topY, // top surface Y for standing
    };
  } else {
    // Top (ceiling) pipe — hangs from y=0
    const bottomY = pipe.h;
    return {
      lipRect: { x: pipe.x, y: bottomY - LIP_H, w: LIP_W, h: LIP_H },
      bodyRect: { x: pipe.x + lipOffset, y: 0, w: PIPE_W, h: pipe.h - LIP_H },
      standY: null, // cannot stand on top pipes
    };
  }
}

// Draw a bottom pipe (green, with lip at top)
function drawBottomPipe(px, ph) {
  const x = Math.round(px);
  const groundY = DESIGN_H - GROUND_H;
  const lipOffset = (LIP_W - PIPE_W) / 2;
  const bodyY = groundY - ph + LIP_H;
  const bodyH = ph - LIP_H;
  const topY = groundY - ph;
  // Pipe body
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x + lipOffset, bodyY, PIPE_W, bodyH);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + lipOffset + 4, bodyY, 8, bodyH);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + lipOffset + PIPE_W - 8, bodyY, 8, bodyH);
  // Lip
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x, topY, LIP_W, LIP_H);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + 4, topY + 2, 8, LIP_H - 4);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + LIP_W - 8, topY + 2, 6, LIP_H - 4);
  ctx.fillStyle = '#196f3d';
  ctx.fillRect(x, topY, LIP_W, 2);
}

// Draw a top (ceiling) pipe (hanging from top, lip at bottom)
function drawTopPipe(px, ph) {
  const x = Math.round(px);
  const lipOffset = (LIP_W - PIPE_W) / 2;
  const bodyH = ph - LIP_H;
  const lipY = bodyH;
  // Pipe body
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x + lipOffset, 0, PIPE_W, bodyH);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + lipOffset + 4, 0, 8, bodyH);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + lipOffset + PIPE_W - 8, 0, 8, bodyH);
  // Lip (at bottom of top pipe)
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x, lipY, LIP_W, LIP_H);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + 4, lipY + 2, 8, LIP_H - 4);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + LIP_W - 8, lipY + 2, 6, LIP_H - 4);
  // Bottom line of lip
  ctx.fillStyle = '#196f3d';
  ctx.fillRect(x, lipY + LIP_H - 2, LIP_W, 2);
}

// Draw ground with brick pattern
function drawGround(offset) {
  const groundY = DESIGN_H - GROUND_H;
  ctx.fillStyle = '#c0784a';
  ctx.fillRect(0, groundY, DESIGN_W, GROUND_H);
  const brickW = 32;
  const brickH = 16;
  const startX = -(offset % brickW);
  ctx.fillStyle = '#a0603a';
  for (let row = 0; row < Math.ceil(GROUND_H / brickH); row++) {
    const rowOffset = (row % 2) * (brickW / 2);
    for (let col = -1; col < Math.ceil(DESIGN_W / brickW) + 2; col++) {
      const bx = startX + col * brickW + rowOffset;
      const by = groundY + row * brickH;
      ctx.fillRect(bx, by, brickW, 1);
      ctx.fillRect(bx, by, 1, brickH);
    }
  }
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, groundY, DESIGN_W, 3);
}

function drawCloud(cx, cy, cw) {
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  const h = cw * 0.4;
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.3, cy + h * 0.5, cw * 0.3, h * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.6, cy + h * 0.35, cw * 0.25, h * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.5, cy + h * 0.6, cw * 0.35, h * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawHill(hx, hw, hh) {
  const groundY = DESIGN_H - GROUND_H;
  ctx.fillStyle = '#3a9d5c';
  ctx.beginPath();
  ctx.moveTo(hx, groundY);
  ctx.quadraticCurveTo(hx + hw / 2, groundY - hh, hx + hw, groundY);
  ctx.fill();
}

// ── Draw breakable brick (original pixel-art style) ───
// A 32x24 terracotta/sandy brick with cracks and mortar lines
function drawBrick(bx, by) {
  const x = Math.round(bx);
  const y = Math.round(by);
  // Main brick body — warm sandy brown
  ctx.fillStyle = '#c8874a';
  ctx.fillRect(x, y, BRICK_W, BRICK_H);
  // Lighter highlight strip (top)
  ctx.fillStyle = '#daa06d';
  ctx.fillRect(x + 1, y + 1, BRICK_W - 2, 3);
  // Darker shadow strip (bottom)
  ctx.fillStyle = '#8b5e3c';
  ctx.fillRect(x + 1, y + BRICK_H - 3, BRICK_W - 2, 2);
  // Mortar lines (horizontal center)
  ctx.fillStyle = '#a07040';
  ctx.fillRect(x, y + 11, BRICK_W, 2);
  // Mortar lines (vertical, staggered)
  ctx.fillRect(x + 15, y, 2, 11);
  ctx.fillRect(x + 8, y + 13, 2, 11);
  ctx.fillRect(x + 24, y + 13, 2, 11);
  // Crack detail — small diagonal scratches
  ctx.fillStyle = '#6b4226';
  ctx.fillRect(x + 5, y + 4, 1, 3);
  ctx.fillRect(x + 6, y + 6, 2, 1);
  ctx.fillRect(x + 20, y + 15, 1, 3);
  ctx.fillRect(x + 21, y + 17, 2, 1);
  // Question mark / sparkle decoration (original, not Mario's ?)
  ctx.fillStyle = '#f4d03f';
  // Small diamond sparkle in center
  ctx.fillRect(x + 15, y + 3, 2, 2);
  ctx.fillRect(x + 14, y + 4, 1, 1);
  ctx.fillRect(x + 17, y + 4, 1, 1);
  ctx.fillRect(x + 15, y + 6, 2, 1);
  // Outline
  ctx.strokeStyle = '#5a3a1a';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, BRICK_W - 1, BRICK_H - 1);
}

// Draw a single debris fragment
function drawFragment(frag) {
  ctx.fillStyle = frag.color;
  ctx.fillRect(Math.round(frag.x), Math.round(frag.y), frag.size, frag.size);
}

// Spawn a floating score popup
function spawnScorePopup(x, y, points) {
  scorePopups.push({
    x: x,
    y: y,
    text: `+${points}`,
    life: 45,
  });
}

// Update score popups
function updateScorePopups() {
  for (let i = scorePopups.length - 1; i >= 0; i--) {
    const p = scorePopups[i];
    p.y -= 1.2; // float upward
    p.life--;
    if (p.life <= 0) {
      scorePopups.splice(i, 1);
    }
  }
}

// Draw score popups
function drawScorePopups() {
  for (const p of scorePopups) {
    const alpha = Math.min(1, p.life / 15);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 14px monospace';
    ctx.fillStyle = '#f4d03f';
    ctx.strokeStyle = '#5a3a1a';
    ctx.lineWidth = 2;
    ctx.strokeText(p.text, Math.round(p.x), Math.round(p.y));
    ctx.fillText(p.text, Math.round(p.x), Math.round(p.y));
    ctx.restore();
  }
}

// Spawn debris fragments when a brick breaks
function spawnBrickFragments(bx, by) {
  const colors = ['#c8874a', '#daa06d', '#8b5e3c', '#a07040', '#6b4226', '#f4d03f'];
  for (let i = 0; i < BRICK_FRAGMENT_COUNT; i++) {
    const angle = (Math.PI * 2 * i) / BRICK_FRAGMENT_COUNT + (Math.random() - 0.5) * 0.5;
    const speed = 2.5 + Math.random() * 3;
    fragments.push({
      x: bx + BRICK_W / 2 + (Math.random() - 0.5) * BRICK_W * 0.6,
      y: by + BRICK_H / 2 + (Math.random() - 0.5) * BRICK_H * 0.4,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 3 - Math.random() * 2, // bias upward initially
      size: 3 + Math.floor(Math.random() * 5),
      color: colors[Math.floor(Math.random() * colors.length)],
      life: 40 + Math.floor(Math.random() * 20), // frames before despawn
    });
  }
}

// Update all fragments (gravity + movement + lifetime)
function updateFragments() {
  for (let i = fragments.length - 1; i >= 0; i--) {
    const f = fragments[i];
    f.vy += 0.35; // gravity on fragments
    f.x += f.vx;
    f.y += f.vy;
    f.life--;
    if (f.life <= 0 || f.y > DESIGN_H + 20) {
      fragments.splice(i, 1);
    }
  }
}

// ── Collision — Swept AABB Continuous Collision Detection ──

function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// Get player hitbox (slightly shrunken for fairness)
function getPlayerHitbox() {
  return {
    x: player.x + 4,
    y: player.y + 2,
    w: player.w - 8,
    h: player.h - 4,
  };
}

// Gather all solid collision AABBs in the world.
// Each rect: { x, y, w, h, type }
// type: 'ground' | 'pipe_lip' | 'pipe_body' | 'brick' | 'ceiling_pipe_lip' | 'ceiling_pipe_body'
function gatherCollisionRects() {
  const rects = [];
  const groundY = DESIGN_H - GROUND_H;

  // Ground (extends infinitely left/right, thick enough to never tunnel)
  rects.push({ x: -1000, y: groundY, w: DESIGN_W + 2000, h: 500, type: 'ground' });

  // Pipes
  for (const pipe of pipes) {
    if (pipe.h <= 0) continue;
    const pr = getPipeRects(pipe);
    if (!pipe.fromTop) {
      rects.push({ x: pr.lipRect.x, y: pr.lipRect.y, w: pr.lipRect.w, h: pr.lipRect.h, type: 'pipe_lip', standY: pr.standY });
      rects.push({ x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h, type: 'pipe_body' });
    } else {
      rects.push({ x: pr.lipRect.x, y: pr.lipRect.y, w: pr.lipRect.w, h: pr.lipRect.h, type: 'ceiling_pipe_lip' });
      rects.push({ x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h, type: 'ceiling_pipe_body' });
    }
  }

  // Bricks
  for (const brick of bricks) {
    if (brick.broken) continue;
    rects.push({ x: brick.x, y: brick.y, w: brick.w, h: brick.h, type: 'brick', brickRef: brick });
  }

  return rects;
}

// ── Swept AABB ──────────────────────────────────────────
// Given a moving AABB (pos + size) and velocity (dx, dy),
// and a static AABB (obstacle), compute the time of first contact [0, 1].
// Returns { t, normalX, normalY } where t is in [0,1] (fraction of movement),
// or { t: 1, normalX: 0, normalY: 0 } if no collision in this movement.
//
// The player AABB moves by (dx, dy) relative to the obstacle.
// Obstacles are treated as static for each sweep call; scroll motion is
// folded into the relative velocity before calling.
function sweptAABB(px, py, pw, ph, dx, dy, ox, oy, ow, oh) {
  // Compute entry and exit distances on each axis
  let xEntryDist, xExitDist, yEntryDist, yExitDist;

  if (dx > 0) {
    xEntryDist = ox - (px + pw);
    xExitDist = (ox + ow) - px;
  } else if (dx < 0) {
    xEntryDist = (ox + ow) - px;
    xExitDist = ox - (px + pw);
  } else {
    xEntryDist = ox - (px + pw);
    xExitDist = (ox + ow) - px;
  }

  if (dy > 0) {
    yEntryDist = oy - (py + ph);
    yExitDist = (oy + oh) - py;
  } else if (dy < 0) {
    yEntryDist = (oy + oh) - py;
    yExitDist = oy - (py + ph);
  } else {
    yEntryDist = oy - (py + ph);
    yExitDist = (oy + oh) - py;
  }

  // Compute entry and exit times
  let xEntry, xExit, yEntry, yExit;

  if (dx === 0) {
    // Not moving on X — check static overlap
    if (xEntryDist < 0 && xExitDist > 0) {
      // Overlapping on X already
      xEntry = -Infinity;
      xExit = Infinity;
    } else {
      // No overlap on X, can never collide
      return { t: 1, normalX: 0, normalY: 0 };
    }
  } else {
    xEntry = xEntryDist / dx;
    xExit = xExitDist / dx;
  }

  if (dy === 0) {
    if (yEntryDist < 0 && yExitDist > 0) {
      yEntry = -Infinity;
      yExit = Infinity;
    } else {
      return { t: 1, normalX: 0, normalY: 0 };
    }
  } else {
    yEntry = yEntryDist / dy;
    yExit = yExitDist / dy;
  }

  // The overall entry time is the latest entry, exit is the earliest exit
  const entryTime = Math.max(xEntry, yEntry);
  const exitTime = Math.min(xExit, yExit);

  // No collision conditions:
  // - Entry after exit (swept past without overlap)
  // - Entry after end of movement (t > 1)
  // - Both entries negative (moving away)
  if (entryTime > exitTime || entryTime > 1 || (xEntry < 0 && yEntry < 0)) {
    return { t: 1, normalX: 0, normalY: 0 };
  }

  // Entry time must be >= 0 for a valid future collision
  // (if < 0, we started overlapping — handle as depenetration)
  if (entryTime < -SWEEP_EPSILON) {
    return { t: 1, normalX: 0, normalY: 0 };
  }

  const t = Math.max(0, entryTime);

  // Determine collision normal (which axis was entered last)
  let normalX = 0, normalY = 0;
  if (xEntry > yEntry) {
    normalX = dx > 0 ? -1 : 1;
  } else {
    normalY = dy > 0 ? -1 : 1;
  }

  return { t, normalX, normalY };
}

// Depenetrate player from any overlapping obstacles.
// Called once before the sweep loop to fix any pre-existing overlaps.
function depenetratePlayer(collisionRects) {
  const HB_OX = 4, HB_OY = 2, HB_W = player.w - 8, HB_H = player.h - 4;

  for (let iter = 0; iter < 4; iter++) {
    let pushed = false;
    const hx = player.x + HB_OX;
    const hy = player.y + HB_OY;

    for (const r of collisionRects) {
      if (!rectsOverlap(hx, hy, HB_W, HB_H, r.x, r.y, r.w, r.h)) continue;

      // Compute minimum penetration vector
      const overlapLeft = (hx + HB_W) - r.x;
      const overlapRight = (r.x + r.w) - hx;
      const overlapTop = (hy + HB_H) - r.y;
      const overlapBottom = (r.y + r.h) - hy;

      const minX = overlapLeft < overlapRight ? -overlapLeft : overlapRight;
      const minY = overlapTop < overlapBottom ? -overlapTop : overlapBottom;

      // Lip corner forgiveness: if overlapping a lip rect and the horizontal
      // overlap is within the forgiveness margin, always push sideways so the
      // player can clear the lip corner instead of being pushed down.
      // Also apply head-center rule: if head center doesn't overlap lip, force sideways.
      const isLip = r.type === 'pipe_lip' || r.type === 'ceiling_pipe_lip';
      const horizOverlap = Math.min(overlapLeft, overlapRight);
      let forceSideways = isLip && player.vy < 0 && horizOverlap <= LIP_CORNER_FORGIVE;
      // Head-center rule for depenetration
      if (isLip && player.vy < 0 && !forceSideways) {
        const headCW = (player.w - 8) * HEAD_CENTER_RATIO;
        const headCL = hx + ((player.w - 8) - headCW) / 2;
        const headCR = headCL + headCW;
        if (!(headCR > r.x && headCL < r.x + r.w)) {
          forceSideways = true;
        }
      }
      if (forceSideways) {
        edgeDebugMsgs.push({ text: 'EDGE-FORGIVE', ttl: 90 });
      }

      if (forceSideways || Math.abs(minX) < Math.abs(minY)) {
        player.x += minX;
      } else {
        player.y += minY;
        if (minY < 0 && player.vy > 0) {
          // Pushed up = landed on surface
          player.vy = 0;
          player.onGround = true;
        }
        if (minY > 0 && player.vy < 0) {
          // Pushed down = hit ceiling
          player.vy = 0;
        }
      }
      pushed = true;
    }
    if (!pushed) break;
  }
}

// ── Main Swept Movement Resolver ────────────────────────
// Resolves player movement for one frame using iterative swept AABB.
//
// Parameters:
//   playerVY: vertical velocity (pixels/frame, after gravity)
//   scrollDX: horizontal scroll displacement this frame (positive = world moves left)
//
// The player's relative motion vs obstacles is:
//   dx = -scrollDX (obstacles move left → equivalent to player moving right relative to them,
//        but player is pushed left by scroll, so relative dx = -scrollDX)
//   dy = playerVY
//
// After resolving, updates player.x, player.y, player.vy, player.onGround.
// Returns { hitBricks: [...] } for bricks hit from below.
function resolveSweptMovement(playerVY, scrollDX) {
  const HB_OX = 4, HB_OY = 2, HB_W = player.w - 8, HB_H = player.h - 4;

  // The relative velocity of the player hitbox vs static obstacles:
  // - Vertically: player moves by playerVY
  // - Horizontally: obstacles move left by scrollDX, so in obstacle-frame,
  //   player effectively moves right by scrollDX.
  //   But we also want to keep player at x=120 (recovery), so net player
  //   movement in world coords is 0 horizontally (scroll moves obstacles).
  //   In the sweep frame, we move the player by (0, playerVY) in world coords,
  //   then move obstacles by (-scrollDX, 0).
  //
  // To handle both in one unified sweep, we compute in "obstacle rest frame":
  //   relative dx = +scrollDX (player moves right relative to obstacles)
  //   relative dy = playerVY
  // After resolving, we convert back: player world displacement = sweep displacement - scrollDX on X.

  let relDX = scrollDX; // player moves right relative to obstacles
  let relDY = playerVY;

  // Gather obstacles
  const collisionRects = gatherCollisionRects();

  // Depenetrate first
  depenetratePlayer(collisionRects);

  let hitBricks = [];
  let remainingT = 1.0;
  let landedThisFrame = false;
  let hitCeilingThisFrame = false;

  for (let iter = 0; iter < SWEEP_MAX_ITERATIONS && remainingT > SWEEP_EPSILON; iter++) {
    const moveDX = relDX * remainingT;
    const moveDY = relDY * remainingT;

    if (Math.abs(moveDX) < SWEEP_EPSILON && Math.abs(moveDY) < SWEEP_EPSILON) break;

    // Current hitbox position
    const hx = player.x + HB_OX;
    const hy = player.y + HB_OY;

    // Find earliest collision among all obstacles
    let bestT = 1.0;
    let bestNX = 0, bestNY = 0;
    let bestRect = null;

    for (const r of collisionRects) {
      const result = sweptAABB(hx, hy, HB_W, HB_H, moveDX, moveDY, r.x, r.y, r.w, r.h);
      if (result.t < bestT - SWEEP_EPSILON) {
        bestT = result.t;
        bestNX = result.normalX;
        bestNY = result.normalY;
        bestRect = r;
      } else if (Math.abs(result.t - bestT) < SWEEP_EPSILON && result.t < 1.0) {
        // Same time — prefer the collision that blocks the most relevant axis
        // (vertical collisions take priority for landing/ceiling)
        if (result.normalY !== 0 && bestNY === 0) {
          bestNX = result.normalX;
          bestNY = result.normalY;
          bestRect = r;
        }
      }
    }

    // Move player to the contact point (with tiny epsilon pullback to avoid overlap)
    const safeT = Math.max(0, bestT - SWEEP_EPSILON);
    player.x += moveDX * safeT;
    player.y += moveDY * safeT;

    if (bestT >= 1.0 - SWEEP_EPSILON) {
      // No collision in remaining movement — done
      break;
    }

    // ── Collision response ──────────────────────────────
    // Resolve normal velocity and redirect remaining time on tangent

    if (bestNY === -1) {
      // Hit top of obstacle (landed on surface)
      // Check if this is a brick hit from below... no, normalY=-1 means
      // player was moving down and hit the top = landing
      landedThisFrame = true;
      relDY = 0;
      player.vy = 0;
      player.onGround = true;
    } else if (bestNY === 1) {
      // Hit bottom of obstacle (ceiling/brick from below)

      // ── Lip Corner Forgiveness (enhanced) ──────────────
      // When player jumps upward beside a pipe and clips the lip overhang
      // corner, nudge them sideways instead of blocking the jump.
      // Now with wider margin (LIP_CORNER_FORGIVE=14) and only while ascending.
      const isLipRect = bestRect && (bestRect.type === 'pipe_lip' || bestRect.type === 'ceiling_pipe_lip');
      if (isLipRect && playerVY < 0) {
        const hx = player.x + HB_OX;
        const lipLeft = bestRect.x;
        const lipRight = bestRect.x + bestRect.w;
        const playerLeft = hx;
        const playerRight = hx + HB_W;

        // How much the player overlaps into the lip on each side
        const overlapFromLeft = playerRight - lipLeft;   // player's right edge past lip's left
        const overlapFromRight = lipRight - playerLeft;  // lip's right edge past player's left

        // Determine which side has the smaller overlap (= which corner was clipped)
        const minOverlap = Math.min(overlapFromLeft, overlapFromRight);

        // ── Head-Center Rule ──────────────────────────────
        // Only count as a true ceiling bonk if the player's head center
        // region overlaps the lip top edge. Edge brushes → side deflection.
        const headCenterW = HB_W * HEAD_CENTER_RATIO;
        const headCenterLeft = hx + (HB_W - headCenterW) / 2;
        const headCenterRight = headCenterLeft + headCenterW;
        const headCenterOverlaps = headCenterRight > lipLeft && headCenterLeft < lipRight;

        if (minOverlap > 0 && (minOverlap <= LIP_CORNER_FORGIVE || !headCenterOverlaps)) {
          // Corner clip or head-center miss — nudge player sideways to clear the lip
          if (overlapFromLeft < overlapFromRight) {
            // Player is to the left of the lip — nudge left
            player.x -= overlapFromLeft + 0.5;
          } else {
            // Player is to the right of the lip — nudge right
            player.x += overlapFromRight + 0.5;
          }
          // Do NOT stop the jump — let upward motion continue
          edgeDebugMsgs.push({ text: 'EDGE-FORGIVE', ttl: 90 });
          remainingT *= (1.0 - bestT);
          continue;
        }
      }

      hitCeilingThisFrame = true;

      // Check if we hit a brick from below (player moving up)
      if (bestRect && bestRect.type === 'brick' && bestRect.brickRef && playerVY < 0) {
        const brick = bestRect.brickRef;
        if (!brick.broken) {
          brick.broken = true;
          hitBricks.push(brick);
          spawnBrickFragments(brick.x, brick.y);
          spawnScorePopup(brick.x + BRICK_W / 2 - 8, brick.y - 5, BRICK_SCORE);
          score += BRICK_SCORE;
          // Bounce down
          player.vy = Math.abs(player.vy) * 0.4;
          relDY = player.vy;
          // Remove this rect from future iterations (brick is gone)
          const idx = collisionRects.indexOf(bestRect);
          if (idx >= 0) collisionRects.splice(idx, 1);
        }
      } else {
        // Hit solid ceiling — stop upward movement
        relDY = 0;
        player.vy = 0;
      }
    }

    if (bestNX === -1) {
      // Hit left face of obstacle (player moving right relative to it)
      // This means the scroll is pushing player into obstacle.
      // Stop the horizontal relative motion component.
      relDX = 0;
    } else if (bestNX === 1) {
      // Hit right face of obstacle — unusual (player moving left relative)
      relDX = 0;
    }

    // Consume the used time fraction
    remainingT *= (1.0 - bestT);
  }

  // Convert back from obstacle-relative frame to world frame.
  // In the sweep, player.x moved by (actual sweep displacement).
  // But obstacles actually move left by scrollDX in world coords.
  // The sweep already moved player.x by the relative displacement,
  // so we subtract the scroll portion to get world coords:
  // world_x = original_x + (relDisp - scrollDX)
  // But since sweep already applied the displacement to player.x,
  // we just need to subtract scrollDX from player.x to account for
  // the fact that obstacles were treated as static.
  // Actually: let's think carefully.
  //   Before sweep: player at world px, obstacles at world ox.
  //   Sweep uses relative frame: player moves by (scrollDX, vy) relative to obstacles.
  //   After sweep: player.x += actualRelDX. But in world frame, obstacles moved by -scrollDX.
  //   So player.x in world = original_px + actualRelDX, obstacles at original_ox - scrollDX.
  //   For world correctness, we need: player.x stays in world frame, obstacles get scrollDX subtracted.
  //   Since sweep already added relDX contribution to player.x, and relDX included scrollDX,
  //   we need to subtract scrollDX from player.x (it was the obstacle's motion, not player's).
  player.x -= scrollDX;

  return { hitBricks, landedThisFrame, hitCeilingThisFrame };
}

// Check if player is standing on any pipe top or brick top. Returns standY or null.
// Used for edge-fall-off detection after movement resolves.
function checkStandingSupport() {
  const pb = getPlayerHitbox();
  const feetY = pb.y + pb.h;
  const groundY = DESIGN_H - GROUND_H;

  // On ground?
  if (Math.abs(feetY - groundY) < 2) return groundY;

  for (const pipe of pipes) {
    if (pipe.fromTop) continue;
    const rects = getPipeRects(pipe);
    const standY = rects.standY;
    if (standY === null) continue;
    // Feet at or very close to the surface, and horizontally overlapping lip
    if (Math.abs(feetY - standY) < 3 &&
        pb.x + pb.w > pipe.x + 4 && pb.x < pipe.x + LIP_W - 4) {
      return standY;
    }
  }

  for (const brick of bricks) {
    if (brick.broken) continue;
    if (Math.abs(feetY - brick.y) < 3 &&
        pb.x + pb.w > brick.x + 2 && pb.x < brick.x + brick.w - 2) {
      return brick.y;
    }
  }

  return null;
}

// Check if player is being crushed (squeezed between obstacles)
function checkCrush() {
  const pb = getPlayerHitbox();

  // 1) Crushed against left screen edge by pipe/brick pushing from right
  if (player.x <= 0) {
    for (const pipe of pipes) {
      const rects = getPipeRects(pipe);
      if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
          rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
          rectsOverlap(pb.x, pb.y, pb.w, pb.h,
          rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
        return true;
      }
    }
    for (const brick of bricks) {
      if (brick.broken) continue;
      if (rectsOverlap(pb.x, pb.y, pb.w, pb.h, brick.x, brick.y, brick.w, brick.h)) {
        return true;
      }
    }
  }

  // 2) Vertically crushed between bottom pipe/ground and top pipe/ceiling
  let floorY = DESIGN_H - GROUND_H;
  let ceilY = 0;

  for (const pipe of pipes) {
    const rects = getPipeRects(pipe);
    const horizOverlap = pb.x + pb.w > rects.lipRect.x + 4 &&
                         pb.x < rects.lipRect.x + rects.lipRect.w - 4;
    if (!horizOverlap) continue;

    if (!pipe.fromTop) {
      const pipeTop = rects.standY;
      if (pipeTop !== null && pipeTop < floorY) floorY = pipeTop;
    } else {
      const pipeBottom = pipe.h;
      if (pipeBottom > ceilY) ceilY = pipeBottom;
    }
  }

  const availableSpace = floorY - ceilY;
  if (availableSpace < pb.h - CRUSH_THRESHOLD) {
    if (pb.y + pb.h >= floorY - 2 && pb.y <= ceilY + 2) {
      return true;
    }
  }

  // 3) Head hitting ceiling pipe while standing on bottom pipe
  for (const topPipe of pipes) {
    if (!topPipe.fromTop) continue;
    const topRects = getPipeRects(topPipe);
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        topRects.lipRect.x, topRects.lipRect.y, topRects.lipRect.w, topRects.lipRect.h) ||
        rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        topRects.bodyRect.x, topRects.bodyRect.y, topRects.bodyRect.w, topRects.bodyRect.h)) {
      if (player.onGround) return true;
    }
  }

  return false;
}

// ── Swept AABB Self-Test (debug=1 only) ─────────────────
// Simulates extreme velocity scenarios and asserts no penetration.
// Call via console: runCollisionSelfTest()
function runCollisionSelfTest() {
  const results = [];
  const HB_W = player.w - 8;
  const HB_H = player.h - 4;

  // Test 1: High-speed downward fall through a thin obstacle (brick 24px)
  {
    const obstacle = { x: 100, y: 200, w: 32, h: 24 };
    // Player hitbox bottom at py+HB_H=160+32=192, obstacle top at 200 → gap 8px
    // Falling at 50 px/frame (extreme) — must detect contact, not tunnel through
    const px = 105, py = 160, dx = 0, dy = 50;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const contactY = py + dy * r.t;
    const passed = r.t < 1 && r.normalY === -1 && (contactY + HB_H) <= obstacle.y + 1;
    results.push({ name: 'Downward 50px/f through 24px brick', t: r.t, normalY: r.normalY, contactY, passed });
  }

  // Test 2: High-speed upward through brick bottom
  {
    const obstacle = { x: 100, y: 200, w: 32, h: 24 };
    const px = 105, py = 280, dx = 0, dy = -60;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const contactY = py + dy * r.t;
    const passed = r.t < 1 && r.normalY === 1 && contactY >= obstacle.y + obstacle.h - 1;
    results.push({ name: 'Upward 60px/f through 24px brick', t: r.t, normalY: r.normalY, contactY, passed });
  }

  // Test 3: High-speed horizontal through pipe body (48px wide)
  {
    const obstacle = { x: 300, y: 100, w: 48, h: 200 };
    const px = 100, py = 150, dx = 250, dy = 0;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const contactX = px + dx * r.t;
    const passed = r.t < 1 && r.normalX === -1 && (contactX + HB_W) <= obstacle.x + 1;
    results.push({ name: 'Horizontal 250px/f through 48px pipe', t: r.t, normalX: r.normalX, contactX, passed });
  }

  // Test 4: Diagonal high-speed through thin lip (16px)
  {
    const obstacle = { x: 200, y: 250, w: 56, h: 16 };
    const px = 150, py = 200, dx = 80, dy = 40;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const passed = r.t < 1; // must detect collision
    results.push({ name: 'Diagonal 80,40 px/f through 16px lip', t: r.t, passed });
  }

  // Test 5: Verify no false positive (moving away from obstacle)
  {
    const obstacle = { x: 300, y: 100, w: 48, h: 200 };
    const px = 100, py = 150, dx = -50, dy = 0;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const passed = r.t >= 1; // should NOT collide
    results.push({ name: 'Moving away — no false positive', t: r.t, passed });
  }

  // Test 6: Scroll-induced collision (obstacle moves into player at high speed)
  {
    const obstacle = { x: 130, y: 200, w: 56, h: 100 };
    // Player at x=100, obstacle approaches from right. In relative frame,
    // player moves right by scrollDX=20 toward obstacle.
    const px = 100, py = 220, dx = 20, dy = 0;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const passed = r.t < 1 && r.normalX === -1;
    results.push({ name: 'Scroll-induced horizontal collision', t: r.t, normalX: r.normalX, passed });
  }

  // Test 7: Full movement resolver — extreme fall with obstacles below
  {
    // Save state
    const savedX = player.x, savedY = player.y, savedVY = player.vy;
    const savedOnGround = player.onGround;
    const savedPipes = [...pipes];
    const savedBricks = [...bricks];

    // Set up scenario: player close above pipe, extreme downward velocity
    // Pipe top (standY) = DESIGN_H - GROUND_H - 120 = 220
    // Player hitbox bottom = player.y + 2 + (player.h - 4) = player.y + 34
    // Set player.y = 190 → hitbox bottom = 224, just 4px below pipe top at 220
    // Actually we want player ABOVE pipe: hitbox bottom < 220
    // player.y = 180 → hitbox bottom = 214, gap = 6px, vy = 80 → easily reaches
    player.x = 100;
    player.y = 180;
    player.vy = 80; // extreme fall speed
    player.onGround = false;
    pipes = [{ x: 96, h: 120, fromTop: false, scored: false }];
    bricks = [];

    const groundY = DESIGN_H - GROUND_H;
    const pipeTopY = groundY - 120;
    resolveSweptMovement(80, 0);

    const pb = getPlayerHitbox();
    const feetY = pb.y + pb.h;
    const penetrated = feetY > pipeTopY + 3;
    results.push({ name: 'Resolver: 80px/f fall onto pipe', feetY: feetY.toFixed(1), pipeTop: pipeTopY, penetrated: penetrated, passed: !penetrated });

    // Restore state
    player.x = savedX; player.y = savedY; player.vy = savedVY;
    player.onGround = savedOnGround;
    pipes = savedPipes;
    bricks = savedBricks;
  }

  // Print results
  let allPassed = true;
  console.log('%c=== Swept AABB Collision Self-Test ===', 'color: #42d4f4; font-weight: bold');
  for (const r of results) {
    const icon = r.passed ? '\u2705' : '\u274c';
    console.log(`${icon} ${r.name}`, r);
    if (!r.passed) allPassed = false;
  }
  console.log(allPassed
    ? '%c\u2705 ALL TESTS PASSED — no penetration detected'
    : '%c\u274c SOME TESTS FAILED — check results above',
    `color: ${allPassed ? '#2ecc71' : '#e74c3c'}; font-weight: bold`);

  return { allPassed, results };
}

// ── Game Logic ─────────────────────────────────────────
let groundOffset = 0;

function resetGame() {
  player.y = DESIGN_H - GROUND_H - player.h;
  player.x = 120;
  player.vy = 0;
  player.onGround = true;
  player.frame = 0;
  player.animState = 'idle';
  player.landTimer = 0;
  player.wasOnGround = true;
  pipes = [];
  bricks = [];
  fragments = [];
  scorePopups = [];
  score = 0;
  frameCount = 0;
  survivalTime = 0;
  diffLevel = 0;
  diffProgress = 0;
  scrollSpeed = SCROLL_SPEED_BASE;
  groundOffset = 0;
  jumpHoldFrames = 0;
  jumpConsumed = false;
  wallNudgeUsed = false;
  edgeDebugMsgs = [];
  initClouds();
  initHills();
  // Seed first pipe pair far away
  spawnInitialPipes();
}

function spawnInitialPipes() {
  const x = DESIGN_W + 100;
  // Bottom pipe
  pipes.push({
    x: x,
    h: PIPE_HEIGHTS_BOTTOM[Math.floor(Math.random() * PIPE_HEIGHTS_BOTTOM.length)],
    fromTop: false,
    scored: false,
  });
}

// Get smoothly interpolated difficulty parameter at current survival time
function getDiffParam(key) {
  const levels = DIFFICULTY_LEVELS;
  const t = survivalTime;
  // Find which two levels we're between
  for (let i = levels.length - 1; i >= 0; i--) {
    if (t >= levels[i].time) {
      if (i === levels.length - 1) return levels[i][key]; // at max level
      const curr = levels[i];
      const next = levels[i + 1];
      const frac = (t - curr.time) / (next.time - curr.time);
      // Smooth step for less jarring transitions
      const s = frac * frac * (3 - 2 * frac);
      return curr[key] + (next[key] - curr[key]) * s;
    }
  }
  return levels[0][key];
}

function updateDifficultyInfo() {
  const levels = DIFFICULTY_LEVELS;
  const t = survivalTime;
  for (let i = levels.length - 1; i >= 0; i--) {
    if (t >= levels[i].time) {
      diffLevel = i;
      if (i < levels.length - 1) {
        diffProgress = (t - levels[i].time) / (levels[i + 1].time - levels[i].time);
      } else {
        diffProgress = 1;
      }
      break;
    }
  }
}

// Check if the last few bottom pipes already provide a staircase for a tall target
function needsStaircase(targetH) {
  if (targetH < TALL_PIPE_THRESHOLD) return false;
  // Look at recent bottom pipes (last 2) — if any is a mid-height step, no staircase needed
  const recentBottom = pipes.filter(p => !p.fromTop).slice(-2);
  for (const p of recentBottom) {
    if (p.h >= 60 && p.h < targetH - 20) return false; // already has a step
  }
  return true;
}

// Spawn staircase pipes before a tall bottom pipe
function spawnStaircaseFor(targetH, targetX, gapMin, gapMax) {
  // Create 1-2 stepping-stone pipes leading up to the tall one
  const steps = targetH >= 200 ? 2 : 1;
  let curX = targetX;
  const stepHeights = [];
  for (let i = steps; i >= 1; i--) {
    // Each step is roughly (i / (steps+1)) of the target height, with some variance
    const ratio = i / (steps + 1);
    const baseH = Math.round(targetH * ratio);
    const h = Math.max(50, Math.min(baseH + Math.floor(Math.random() * 20 - 10), targetH - 30));
    stepHeights.unshift(h);
  }
  // Place steps before the target, working backwards
  for (let i = stepHeights.length - 1; i >= 0; i--) {
    const stepGap = gapMin * 0.7 + Math.random() * (gapMax - gapMin) * 0.4;
    curX -= stepGap;
    pipes.push({
      x: curX,
      h: stepHeights[i],
      fromTop: false,
      scored: false,
    });
  }
  return curX; // returns leftmost step X so we know where steps start
}

// Spawn stepping-stone bricks before a bottom pipe
// Bricks are placed 40~140px to the LEFT of the pipe, at heights that help
// the player reach the pipe top via small or large jumps.
// Tall pipes (>= TALL_PIPE_THRESHOLD) always get bricks; shorter pipes have a random chance.
function maybeSpawnSteppingStoneBricks(pipeX, pipeH, hasCeiling) {
  if (hasCeiling) return; // don't spawn bricks under ceiling pipes
  const groundY = DESIGN_H - GROUND_H;
  const pipeTopY = groundY - pipeH;

  // Tall pipes always get stepping stones; shorter pipes use BRICK_SPAWN_CHANCE
  const isTall = pipeH >= TALL_PIPE_THRESHOLD;
  if (!isTall && Math.random() > BRICK_SPAWN_CHANCE) return;

  // Decide 1 or 2 bricks: tall pipes get 2, shorter pipes get 1
  const brickCount = (isTall && pipeH >= 180) ? 2 : 1;

  // Player physics reference:
  // Small jump apex from ground ≈ 45px above ground (JUMP_INITIAL^2 / (2*GRAVITY))
  // Full jump apex from ground ≈ 130px above ground (with hold boost)
  // Ground surface Y = groundY (DESIGN_H - GROUND_H)
  // Player stands at groundY - player.h (36)

  for (let i = 0; i < brickCount; i++) {
    // Horizontal distance: 40~140px before the pipe
    // For 2 bricks, spread them: first one farther, second one closer
    let horizDist;
    if (brickCount === 2) {
      horizDist = (i === 0)
        ? 100 + Math.random() * 40   // farther brick: 100~140px
        : 40 + Math.random() * 40;   // closer brick: 40~80px
    } else {
      horizDist = 40 + Math.random() * 100; // single brick: 40~140px
    }
    const brickX = pipeX - horizDist;

    // Vertical placement: brick top is a stepping height
    // For single or first brick: reachable from ground via small jump
    //   Place brick surface at roughly 30~60px above ground
    // For second (closer) brick: higher, bridging to pipe top
    //   Place brick surface at roughly 50~80% of pipe height
    let brickTopY;
    if (brickCount === 2 && i === 1) {
      // Higher stepping stone — between 40% and 65% of pipe height off ground
      const ratio = 0.40 + Math.random() * 0.25;
      brickTopY = groundY - Math.round(pipeH * ratio);
    } else {
      // Lower stepping stone — reachable from ground with small jump
      // Player can small-jump about 45px, so brick top at groundY - 40~70
      const stepH = 40 + Math.random() * 30;
      brickTopY = groundY - stepH;
    }

    // Clamp: don't place too high (above screen) or too low (at ground)
    brickTopY = Math.max(30, Math.min(brickTopY, groundY - BRICK_H - 10));

    // Prevent overlapping with existing pipes
    const brickRight = brickX + BRICK_W;
    const brickBottom = brickTopY + BRICK_H;
    let overlaps = false;
    for (const pipe of pipes) {
      const rects = getPipeRects(pipe);
      // Check against lip and body rects
      if (rectsOverlap(brickX, brickTopY, BRICK_W, BRICK_H,
          rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
          rectsOverlap(brickX, brickTopY, BRICK_W, BRICK_H,
          rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
        overlaps = true;
        break;
      }
      // Also ensure minimum 8px gap from pipe edges (no "touching")
      const lipR = rects.lipRect;
      if (Math.abs(brickX - (lipR.x + lipR.w)) < 8 || Math.abs(brickRight - lipR.x) < 8) {
        if (brickTopY < lipR.y + lipR.h && brickBottom > lipR.y) {
          overlaps = true;
          break;
        }
      }
    }

    // Also prevent overlapping with existing bricks
    if (!overlaps) {
      for (const existingBrick of bricks) {
        if (existingBrick.broken) continue;
        if (rectsOverlap(brickX, brickTopY, BRICK_W, BRICK_H,
            existingBrick.x - 8, existingBrick.y - 8,
            existingBrick.w + 16, existingBrick.h + 16)) {
          overlaps = true;
          break;
        }
      }
    }

    if (overlaps) continue; // skip this brick if overlapping

    bricks.push({
      x: brickX,
      y: brickTopY,
      w: BRICK_W,
      h: BRICK_H,
      broken: false,
    });
  }
}

// Spawn a standalone brick obstacle group (1~3 bricks) that replaces a pipe.
// Bricks are arranged as a small platforming challenge: low, mid, and optionally high.
// All heights are reachable via small/full jumps from ground or from other bricks.
function spawnStandaloneBricks(anchorX) {
  const groundY = DESIGN_H - GROUND_H;
  const count = STANDALONE_BRICK_MIN_COUNT +
    Math.floor(Math.random() * (STANDALONE_BRICK_MAX_COUNT - STANDALONE_BRICK_MIN_COUNT + 1));

  // Predefined height tiers (top-of-brick Y measured from groundY upward)
  // Low: 30–55 px above ground — reachable with small jump
  // Mid: 70–100 px above ground — reachable with medium hold
  // High: 110–140 px above ground — needs full jump
  const tiers = [
    { minH: 30, maxH: 55 },   // low
    { minH: 70, maxH: 100 },  // mid
    { minH: 110, maxH: 140 }, // high
  ];

  // Horizontal spread: bricks are spaced 35–55 px apart
  const startX = anchorX;

  for (let i = 0; i < count; i++) {
    const tier = tiers[i];
    const heightAboveGround = tier.minH + Math.random() * (tier.maxH - tier.minH);
    const brickTopY = groundY - heightAboveGround;
    const brickX = startX + i * (35 + Math.random() * 20);

    // Clamp within screen bounds
    const clampedY = Math.max(30, Math.min(brickTopY, groundY - BRICK_H - 10));

    // Prevent overlapping with existing bricks
    let overlaps = false;
    for (const existingBrick of bricks) {
      if (existingBrick.broken) continue;
      if (rectsOverlap(brickX, clampedY, BRICK_W, BRICK_H,
          existingBrick.x - 8, existingBrick.y - 8,
          existingBrick.w + 16, existingBrick.h + 16)) {
        overlaps = true;
        break;
      }
    }

    // Prevent overlapping with existing pipes
    if (!overlaps) {
      for (const pipe of pipes) {
        const rects = getPipeRects(pipe);
        if (rectsOverlap(brickX, clampedY, BRICK_W, BRICK_H,
            rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
            rectsOverlap(brickX, clampedY, BRICK_W, BRICK_H,
            rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
          overlaps = true;
          break;
        }
      }
    }

    if (overlaps) continue;

    bricks.push({
      x: brickX,
      y: clampedY,
      w: BRICK_W,
      h: BRICK_H,
      broken: false,
    });
  }
}

function spawnPipe() {
  const lastPipe = pipes[pipes.length - 1];
  const gapMin = getDiffParam('gapMin');
  const gapMax = getDiffParam('gapMax');
  const gap = gapMin + Math.random() * (gapMax - gapMin);
  const newX = lastPipe.x + gap;

  // ── Brick-replaces-pipe check ──────────────────────────
  const brickReplaceChance = getDiffParam('brickReplace');
  if (Math.random() < brickReplaceChance) {
    // Replace this pipe spawn with a standalone brick obstacle group
    spawnStandaloneBricks(newX);
    // Add a tiny invisible ground-level "marker pipe" so the spawn/score
    // system keeps tracking position (h=0 is invisible, scored normally)
    pipes.push({ x: newX, h: 0, fromTop: false, scored: false });
    return;
  }

  const pipeMaxH = getDiffParam('pipeMaxH');
  const topMaxH = getDiffParam('topMaxH');
  const pairChance = getDiffParam('pairChance');

  // Build height pools dynamically based on current difficulty
  const bottomHeights = PIPE_HEIGHTS_BOTTOM.filter(h => h <= pipeMaxH);
  if (pipeMaxH >= 170) bottomHeights.push(170);
  if (pipeMaxH >= 195) bottomHeights.push(195);
  if (pipeMaxH >= 220) bottomHeights.push(220);
  if (pipeMaxH >= 240) bottomHeights.push(240);

  const topHeights = PIPE_HEIGHTS_TOP.filter(h => h <= topMaxH);
  if (topMaxH >= 155) topHeights.push(155);
  if (topMaxH >= 170) topHeights.push(170);
  if (topMaxH >= 190) topHeights.push(190);
  if (topMaxH >= 200) topHeights.push(200);

  // Decide what to spawn
  const roll = Math.random();
  const topOnlyChance = 0.20;
  const bottomOnlyChance = 1 - topOnlyChance - pairChance;

  if (roll < bottomOnlyChance) {
    // Bottom pipe only
    const h = bottomHeights[Math.floor(Math.random() * bottomHeights.length)];
    // Staircase: if this pipe is tall and no recent step exists, insert stepping pipes
    if (needsStaircase(h)) {
      spawnStaircaseFor(h, newX, gapMin, gapMax);
    }
    pipes.push({ x: newX, h, fromTop: false, scored: false });
    // Maybe spawn stepping-stone bricks before this pipe
    maybeSpawnSteppingStoneBricks(newX, h, false);
  } else if (roll < bottomOnlyChance + topOnlyChance) {
    // Top pipe only
    pipes.push({
      x: newX,
      h: topHeights[Math.floor(Math.random() * topHeights.length)],
      fromTop: true,
      scored: false,
    });
  } else {
    // Both top and bottom — create a passable gap
    const groundY = DESIGN_H - GROUND_H;
    const bottomH = bottomHeights[Math.floor(Math.random() * bottomHeights.length)];
    // Staircase for tall bottom in pair
    if (needsStaircase(bottomH)) {
      spawnStaircaseFor(bottomH, newX, gapMin, gapMax);
    }
    const bottomTopY = groundY - bottomH;
    const diffFrac = Math.min(survivalTime / DIFFICULTY_LEVELS[DIFFICULTY_LEVELS.length - 1].time, 1);
    const minGapSize = player.h + 30 + (1 - diffFrac) * 30;
    const maxTopH = bottomTopY - minGapSize;
    if (maxTopH >= 50) {
      const topH = 50 + Math.floor(Math.random() * (Math.min(maxTopH, topMaxH) - 50));
      pipes.push({ x: newX, h: bottomH, fromTop: false, scored: false });
      pipes.push({ x: newX, h: Math.max(50, topH), fromTop: true, scored: false });
    } else {
      pipes.push({ x: newX, h: bottomH, fromTop: false, scored: false });
      // Spawn stepping-stone bricks before this pipe (no ceiling pipe)
      maybeSpawnSteppingStoneBricks(newX, bottomH, false);
    }
  }
}

function update() {
  if (state !== 'playing') return;

  frameCount++;
  survivalTime = frameCount / 60; // assume ~60fps
  updateDifficultyInfo();
  const speedMul = getDiffParam('speedMul');
  scrollSpeed = (SCROLL_SPEED_BASE + frameCount * SCROLL_ACCEL) * speedMul;
  groundOffset += scrollSpeed;

  // ── Phase 1: Compute desired velocity vector ──────────
  // Jump initiation (requires fresh press — must release before next jump)
  if (jumpPressed && !jumpConsumed && player.onGround) {
    player.vy = JUMP_INITIAL;
    player.onGround = false;
    jumpHoldFrames = 0;
    jumpConsumed = true;
    wallNudgeUsed = false; // allow one wall-kick nudge this jump

    // ── Wall-Kick Nudge ──────────────────────────────────
    // If player is flush against a pipe body side at jump start, nudge outward
    // so the lip overhang doesn't immediately block the ascent.
    const hb = getPlayerHitbox();
    for (const pipe of pipes) {
      if (pipe.h <= 0) continue;
      const pr = getPipeRects(pipe);
      const body = pipe.fromTop
        ? { x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h }
        : { x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h };
      // Check vertical overlap with pipe body
      if (hb.y + hb.h <= body.y || hb.y >= body.y + body.h) continue;
      // Check if player's side is touching the pipe body (within 2px)
      const gapRight = body.x - (hb.x + hb.w); // player left of pipe
      const gapLeft = hb.x - (body.x + body.w); // player right of pipe
      if (gapRight >= -1 && gapRight <= 2) {
        // Player is to the LEFT of pipe body — nudge left
        player.x -= WALL_NUDGE_PX;
        wallNudgeUsed = true;
        edgeDebugMsgs.push({ text: 'WALL-NUDGE', ttl: 90 });
        break;
      } else if (gapLeft >= -1 && gapLeft <= 2) {
        // Player is to the RIGHT of pipe body — nudge right
        player.x += WALL_NUDGE_PX;
        wallNudgeUsed = true;
        edgeDebugMsgs.push({ text: 'WALL-NUDGE', ttl: 90 });
        break;
      }
    }
  }

  // Variable jump: hold to go higher
  if (jumpPressed && !player.onGround && jumpHoldFrames < JUMP_HOLD_MAX_T && player.vy < 0) {
    player.vy += JUMP_HOLD_ACCEL;
    jumpHoldFrames++;
  }

  // Apply gravity to get desired vertical velocity
  player.vy += GRAVITY;

  // ── Phase 2: Swept AABB resolve ───────────────────────
  // Combine player's vertical motion + scroll-induced horizontal motion
  // into one unified continuous collision resolve.
  const result = resolveSweptMovement(player.vy, scrollSpeed);

  // ── Phase 3: Post-resolve checks ─────────────────────
  const groundY = DESIGN_H - GROUND_H - player.h;

  // Reset hold counter on landing
  if (result.landedThisFrame) {
    jumpHoldFrames = 0;
    wallNudgeUsed = false;
  }

  // Clamp player X (don't go off-screen too far left)
  if (player.x < -10) player.x = -10;

  // Animation state machine
  updateAnimState();

  // Animation frame (run cycle only advances on ground)
  if (player.animState === 'run') {
    if (frameCount % 6 === 0) player.frame = (player.frame + 1) % 4;
  }

  // Update debris fragments
  updateFragments();

  // Update score popups
  updateScorePopups();

  // ── Phase 4: Move obstacles in world coords ──────────
  // The sweep already accounted for scroll in collision detection.
  // Now actually move obstacle positions for rendering/scoring.
  for (const pipe of pipes) {
    pipe.x -= scrollSpeed;
  }
  for (const brick of bricks) {
    brick.x -= scrollSpeed;
  }

  // Check if player fell off a platform edge (pipe/brick scrolled away)
  if (player.onGround && player.y < groundY - 5) {
    const support = checkStandingSupport();
    if (support === null) {
      player.onGround = false;
    }
  }

  // ── Phase 5: Death checks (after obstacles moved) ────
  // Check crush death
  if (checkCrush()) {
    state = 'dead';
    if (score > highScore) highScore = score;
    const tMins = Math.floor(survivalTime / 60);
    const tSecs = Math.floor(survivalTime % 60);
    const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
    showOverlay('Game Over', `Score: ${score}  |  Time: ${timeStr}  |  ${DIFFICULTY_LEVELS[diffLevel].name}`, score);
    return;
  }

  // If player pushed too far left off screen, also die
  if (player.x + player.w < -5) {
    state = 'dead';
    if (score > highScore) highScore = score;
    const tMins = Math.floor(survivalTime / 60);
    const tSecs = Math.floor(survivalTime % 60);
    const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
    showOverlay('Game Over', `Score: ${score}  |  Time: ${timeStr}  |  ${DIFFICULTY_LEVELS[diffLevel].name}`, score);
    return;
  }

  // Score: passed pipe
  for (const pipe of pipes) {
    if (!pipe.scored && pipe.x + LIP_W < player.x) {
      pipe.scored = true;
      score++;
    }
  }

  // Remove off-screen pipes
  pipes = pipes.filter(p => p.x > -LIP_W - 10);

  // Remove off-screen or broken bricks
  bricks = bricks.filter(b => !b.broken && b.x > -BRICK_W - 10);

  // Spawn pipes
  if (pipes.length > 0) {
    const rightmost = pipes.reduce((a, b) => a.x > b.x ? a : b);
    if (rightmost.x < DESIGN_W) {
      spawnPipe();
    }
  } else {
    spawnInitialPipes();
  }

  // Recover player X towards default position when not being pushed
  const pb = getPlayerHitbox();
  let beingPushed = false;
  for (const pipe of pipes) {
    if (pipe.h <= 0) continue;
    const rects = getPipeRects(pipe);
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
        rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
      beingPushed = true;
      break;
    }
  }
  if (!beingPushed) {
    for (const brick of bricks) {
      if (brick.broken) continue;
      if (rectsOverlap(pb.x, pb.y, pb.w, pb.h, brick.x, brick.y, brick.w, brick.h)) {
        beingPushed = true;
        break;
      }
    }
  }
  if (!beingPushed && player.x < 120) {
    player.x += Math.min(1.5, 120 - player.x);
  }

  // Update clouds
  for (const c of clouds) {
    c.x -= c.speed;
    if (c.x + c.w < 0) {
      c.x = DESIGN_W + Math.random() * 100;
      c.y = 20 + Math.random() * 100;
    }
  }

  // Update hills
  for (const h of hills) {
    h.x -= scrollSpeed * 0.3;
    if (h.x + h.w < 0) {
      const last = hills.reduce((a, b) => a.x > b.x ? a : b);
      h.x = last.x + 200 + Math.random() * 100;
      h.w = 180 + Math.random() * 100;
      h.h = 40 + Math.random() * 40;
    }
  }

  scoreDisplay.textContent = `SCORE: ${score}`;

  // Update HUD
  const mins = Math.floor(survivalTime / 60);
  const secs = Math.floor(survivalTime % 60);
  hudTime.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

  const lvl = DIFFICULTY_LEVELS[diffLevel];
  hudLevel.textContent = `Lv.${diffLevel + 1} ${lvl.name}`;

  const fillPct = diffLevel >= DIFFICULTY_LEVELS.length - 1 ? 100 : Math.round(diffProgress * 100);
  hudLevelFill.style.width = fillPct + '%';
  const levelColors = ['#2ecc71', '#f1c40f', '#e67e22', '#e74c3c', '#9b59b6'];
  hudLevelFill.style.background = levelColors[diffLevel];
}

function draw() {
  // Sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, DESIGN_H - GROUND_H);
  grad.addColorStop(0, '#5c94fc');
  grad.addColorStop(1, '#92c4f8');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, DESIGN_W, DESIGN_H);

  // Clouds
  for (const c of clouds) {
    drawCloud(c.x, c.y, c.w);
  }

  // Hills
  for (const h of hills) {
    drawHill(h.x, h.w, h.h);
  }

  // Ground
  drawGround(groundOffset);

  // Pipes
  for (const pipe of pipes) {
    if (pipe.h <= 0) continue; // skip marker pipes (brick-replaced)
    if (pipe.fromTop) {
      drawTopPipe(pipe.x, pipe.h);
    } else {
      drawBottomPipe(pipe.x, pipe.h);
    }
  }

  // Breakable bricks
  for (const brick of bricks) {
    if (!brick.broken) {
      drawBrick(brick.x, brick.y);
    }
  }

  // Player
  if (state === 'playing' || state === 'dead') {
    drawPlayer(player.x, player.y, player.frame);
  } else {
    // Title screen: show idle animation
    const prevAnim = player.animState;
    player.animState = 'idle';
    drawPlayer(player.x, DESIGN_H - GROUND_H - player.h, 0);
    player.animState = prevAnim;
  }

  // Debris fragments (drawn on top of everything)
  for (const frag of fragments) {
    drawFragment(frag);
  }

  // Score popups
  drawScorePopups();

  // ── Edge-Protection Debug Overlay (always visible) ────
  // Show EDGE-FORGIVE / WALL-NUDGE messages at top-left when triggered
  if (edgeDebugMsgs.length > 0) {
    ctx.save();
    ctx.font = 'bold 11px monospace';
    let dbgY = 14;
    for (let i = edgeDebugMsgs.length - 1; i >= 0; i--) {
      const msg = edgeDebugMsgs[i];
      const alpha = Math.min(1, msg.ttl / 30);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = msg.text === 'WALL-NUDGE' ? '#ff6' : '#6ff';
      ctx.fillText(msg.text, 6, dbgY);
      dbgY += 14;
      msg.ttl--;
      if (msg.ttl <= 0) edgeDebugMsgs.splice(i, 1);
    }
    ctx.restore();
  }

  // ── Debug hitbox overlay ──────────────────────────────
  if (DEBUG_MODE) {
    ctx.save();
    ctx.globalAlpha = 0.45;
    ctx.lineWidth = 1;

    // Player hitbox (green)
    const dbPb = getPlayerHitbox();
    ctx.strokeStyle = '#0f0';
    ctx.strokeRect(dbPb.x, dbPb.y, dbPb.w, dbPb.h);

    // Pipe collision rects (red = lip, orange = body)
    for (const pipe of pipes) {
      if (pipe.h <= 0) continue;
      const rects = getPipeRects(pipe);
      ctx.strokeStyle = '#f00';
      ctx.strokeRect(rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h);
      ctx.strokeStyle = '#f80';
      ctx.strokeRect(rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h);
      // Stand-Y line (cyan)
      if (rects.standY !== null) {
        ctx.strokeStyle = '#0ff';
        ctx.beginPath();
        ctx.moveTo(rects.lipRect.x, rects.standY);
        ctx.lineTo(rects.lipRect.x + rects.lipRect.w, rects.standY);
        ctx.stroke();
      }
    }

    // Brick hitboxes (yellow)
    for (const brick of bricks) {
      if (brick.broken) continue;
      ctx.strokeStyle = '#ff0';
      ctx.strokeRect(brick.x, brick.y, brick.w, brick.h);
    }

    // Scroll speed indicator + swept AABB label
    ctx.globalAlpha = 1;
    ctx.font = '10px monospace';
    ctx.fillStyle = '#0f0';
    ctx.fillText(`spd:${scrollSpeed.toFixed(1)} vy:${player.vy.toFixed(1)} y:${player.y.toFixed(0)} [SweptAABB]`, 4, DESIGN_H - 4);
    ctx.fillText(`onGround:${player.onGround} x:${player.x.toFixed(0)}`, 4, DESIGN_H - 14);

    ctx.restore();
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// ── Overlay ────────────────────────────────────────────
function showOverlay(title, msg, sc) {
  olTitle.textContent = title;
  olMsg.textContent = msg;
  if (sc !== undefined) {
    olScore.textContent = `High Score: ${highScore}`;
    olScore.style.display = 'block';
  } else {
    olScore.style.display = 'none';
  }
  olBtn.textContent = state === 'title' ? 'START' : 'RESTART';
  overlay.style.display = 'flex';
}

function hideOverlay() {
  overlay.style.display = 'none';
}

olBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  startGame();
});

function startGame() {
  hideOverlay();
  resetGame();
  player.animState = 'run';
  state = 'playing';
}

// ── Input ──────────────────────────────────────────────
function onInputDown(e) {
  if (state === 'dead') {
    startGame();
    return;
  }
  if (state === 'title') {
    startGame();
    jumpPressed = true;
    return;
  }
  jumpPressed = true;
}
function onInputUp() {
  jumpPressed = false;
  jumpConsumed = false;
}

// Keyboard
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    onInputDown(e);
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    onInputUp();
  }
});

// Touch
document.addEventListener('touchstart', (e) => {
  if (e.target === olBtn) return;
  e.preventDefault();
  onInputDown(e);
}, { passive: false });
document.addEventListener('touchend', (e) => {
  onInputUp();
}, { passive: false });

// Mouse (for desktop testing)
canvas.addEventListener('mousedown', (e) => {
  onInputDown(e);
});
document.addEventListener('mouseup', () => {
  onInputUp();
});

// ── Init ───────────────────────────────────────────────
loadSprite(); // attempt sprite mode; falls back to procedural on failure
initClouds();
initHills();
showOverlay('Plumber Runner', 'Press SPACE / Tap to Start');
gameLoop();

// Expose self-test globally for console access
window.runCollisionSelfTest = runCollisionSelfTest;

// Auto-run self-test in debug mode
if (DEBUG_MODE) {
  setTimeout(() => {
    console.log('%cDebug mode active — running collision self-test...', 'color: #42d4f4');
    runCollisionSelfTest();
  }, 500);
}
</script>
</body>
</html>
