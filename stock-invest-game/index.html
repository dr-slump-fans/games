<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>è‚¡å¸‚æŠ•è³‡ç­–ç•¥å·¥å…·ï¼ˆå°è‚¡ç›¤ä¸­è¦å‰‡ç‰ˆï¼‰</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans TC",sans-serif;background:#0f172a;color:#e2e8f0;padding:12px}
.wrap{max-width:520px;margin:0 auto}
h1{font-size:1.2rem;margin-bottom:4px}
.ver{font-size:.7rem;color:#64748b}

/* inputs */
.row{display:flex;gap:8px;margin:10px 0;flex-wrap:wrap}
.row input,.row select{background:#1e293b;border:1px solid #334155;color:#e2e8f0;border-radius:8px;padding:8px 10px;font-size:.95rem}
.row input{flex:1;min-width:80px}
.row select{min-width:100px}
button{background:#2563eb;color:#fff;border:none;border-radius:8px;padding:8px 16px;font-size:.9rem;cursor:pointer;font-weight:600}
button:disabled{opacity:.4;cursor:default}
button.stop{background:#dc2626}
button.reset{background:#475569}
button.clear-save{background:#7c2d12}

/* status panel */
.panel{background:#1e293b;border:1px solid #334155;border-radius:12px;padding:12px;margin:10px 0}
.panel h2{font-size:.95rem;margin-bottom:8px;color:#94a3b8}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:6px 16px}
.grid .lbl{font-size:.75rem;color:#64748b}
.grid .val{font-size:1rem;font-weight:700}
.val.up{color:#22c55e}
.val.down{color:#ef4444}
.val.neutral{color:#94a3b8}

/* stats */
.stats{display:grid;grid-template-columns:repeat(2,1fr);gap:6px 16px}

/* log */
.log-box{background:#111827;border:1px solid #334155;border-radius:10px;padding:10px;max-height:200px;overflow-y:auto;font-size:.78rem;line-height:1.5}
.log-box .entry{border-bottom:1px solid #1e293b;padding:3px 0}
.log-box .entry:last-child{border:none}
.log-entry-up{color:#22c55e}
.log-entry-down{color:#ef4444}

/* market status bar */
.market-bar{text-align:center;padding:6px;border-radius:8px;font-size:.8rem;font-weight:600;margin:8px 0}
.market-bar.open{background:#14532d;color:#4ade80}
.market-bar.closed{background:#422006;color:#fbbf24}

.back{display:inline-block;margin-bottom:8px;color:#38bdf8;text-decoration:none;font-size:.85rem}

/* inventory query button */
button.query{background:#0d9488}
button.manual-sell{background:#f97316}
button.manual-sell:disabled{opacity:.4;cursor:default}
button.manual-buy{background:#7c3aed}
button.manual-buy:disabled{opacity:.4;cursor:default}
.manual-buy-row{display:flex;gap:8px;margin:6px 0;flex-wrap:wrap;align-items:center}
.manual-buy-row input{background:#1e293b;border:1px solid #334155;color:#e2e8f0;border-radius:8px;padding:8px 10px;font-size:.95rem;width:110px}
.manual-buy-row label{font-size:.8rem;color:#94a3b8;white-space:nowrap}
.time-row{display:flex;gap:8px;margin:6px 0;flex-wrap:wrap;align-items:center}
.time-row input{background:#1e293b;border:1px solid #334155;color:#e2e8f0;border-radius:8px;padding:6px 8px;font-size:.9rem;width:80px}
.time-row label{font-size:.8rem;color:#94a3b8;white-space:nowrap}

/* inventory modal overlay */
.inv-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);z-index:100;justify-content:center;align-items:center}
.inv-overlay.show{display:flex}
.inv-modal{background:#1e293b;border:1px solid #475569;border-radius:14px;padding:16px;max-width:460px;width:92%;max-height:85vh;overflow-y:auto;position:relative}
.inv-modal h2{font-size:1rem;margin-bottom:10px;color:#e2e8f0}
.inv-modal .close-btn{position:absolute;top:10px;right:14px;background:none;border:none;color:#94a3b8;font-size:1.3rem;cursor:pointer;padding:0}
.inv-modal .inv-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px 16px}
.inv-modal .lbl{font-size:.75rem;color:#64748b}
.inv-modal .val{font-size:.95rem;font-weight:700}
.inv-modal .section-title{font-size:.82rem;color:#94a3b8;margin:12px 0 6px;border-top:1px solid #334155;padding-top:8px}
.inv-modal .no-pos{text-align:center;color:#94a3b8;padding:16px 0;font-size:.9rem}
.inv-modal .last-trade{background:#111827;border-radius:8px;padding:10px;margin-top:8px;font-size:.82rem;line-height:1.6}

/* lots table */
.lots-panel{margin:10px 0}
.lots-panel h2{font-size:.95rem;margin-bottom:6px;color:#94a3b8}
.lots-table{width:100%;border-collapse:collapse;font-size:.78rem}
.lots-table th{text-align:left;color:#64748b;padding:4px 6px;border-bottom:1px solid #334155;font-weight:500}
.lots-table td{padding:4px 6px;border-bottom:1px solid #1e293b;vertical-align:middle}
.lots-table .lot-up{color:#22c55e}
.lots-table .lot-down{color:#ef4444}
.lots-table .lot-neutral{color:#94a3b8}
button.sell-lot{background:#f97316;color:#fff;border:none;border-radius:6px;padding:3px 8px;font-size:.72rem;cursor:pointer;font-weight:600}
button.sell-lot:hover{background:#ea580c}
button.sell-all{background:#dc2626;color:#fff;border:none;border-radius:8px;padding:6px 14px;font-size:.82rem;cursor:pointer;font-weight:600;margin-top:6px}
button.sell-all:hover{background:#b91c1c}
.lots-empty{color:#64748b;font-size:.82rem;text-align:center;padding:10px 0}

/* v0.1.9 strategy dashboard */
.lot-detail{background:#111827;border-radius:8px;padding:8px 10px;margin:4px 0;font-size:.76rem;line-height:1.6}
.lot-detail .lot-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.lot-detail .lot-header strong{font-size:.82rem}
.lot-detail .lot-meta{color:#94a3b8}
.lot-detail .lot-price-row{display:flex;gap:12px;flex-wrap:wrap;margin:2px 0}
.lot-detail .strat-row{display:flex;gap:8px;flex-wrap:wrap;margin:2px 0}
.strat-tag{display:inline-block;padding:1px 6px;border-radius:4px;font-size:.72rem;font-weight:600}
.strat-safe{background:#14532d;color:#4ade80}
.strat-warn{background:#713f12;color:#fbbf24}
.strat-danger{background:#7f1d1d;color:#fca5a5}
.strat-info{background:#1e3a5f;color:#93c5fd}
.phase-badge{display:inline-block;padding:1px 6px;border-radius:4px;font-size:.72rem;font-weight:600}
.phase-holding{background:#1e3a5f;color:#93c5fd}
.phase-trailing{background:#14532d;color:#4ade80}
</style>
</head>
<body>
<div class="wrap">
  <a class="back" href="../index.html">â† å›é¦–é </a>
  <h1>ğŸ“ˆ è‚¡å¸‚æŠ•è³‡ç­–ç•¥å·¥å…· <span class="ver">v0.1.9</span></h1>

  <div id="marketBar" class="market-bar closed">éç›¤ä¸­æ™‚æ®µ â€” ç­‰å¾…é–‹ç›¤</div>
  <div id="sourceBar" style="text-align:center;padding:4px;font-size:.75rem;color:#94a3b8;margin:4px 0">ä¾†æºï¼šâ€” ï½œ æ›´æ–°ï¼šâ€”</div>

  <!-- poll interval -->
  <div class="row" style="align-items:center">
    <label style="font-size:.8rem;color:#94a3b8;white-space:nowrap">è¼ªè©¢é–“éš”</label>
    <input id="pollInput" type="number" min="3" max="60" value="5" style="width:60px;flex:none"/> <span style="font-size:.8rem;color:#94a3b8">ç§’</span>
  </div>

  <!-- monitoring time window -->
  <div class="time-row">
    <label>ç›£æ§æ™‚çª—</label>
    <input id="monitorStart" type="text" value="09:10" placeholder="09:10"/>
    <span style="font-size:.8rem;color:#94a3b8">~</span>
    <input id="monitorEnd" type="text" value="12:00" placeholder="12:00"/>
    <span style="font-size:.75rem;color:#64748b">(Asia/Taipei)</span>
  </div>

  <!-- stock input -->
  <div class="row">
    <input id="stockInput" type="text" placeholder="è‚¡ç¥¨ä»£è™Ÿ" value="2330"/>
    <select id="stockSelect">
      <option value="2330">2330 å°ç©é›»</option>
      <option value="2317">2317 é´»æµ·</option>
      <option value="0050">0050 å…ƒå¤§å°ç£50</option>
      <option value="2454">2454 è¯ç™¼ç§‘</option>
    </select>
  </div>
  <div class="row">
    <button id="btnStart">é–‹å§‹ç›£æ§</button>
    <button id="btnStop" class="stop" disabled>åœæ­¢ç›£æ§</button>
    <button id="btnManualSell" class="manual-sell" disabled>è³£å‡ºå…¨éƒ¨</button>
    <button id="btnReset" class="reset">é‡ç½®</button>
    <button id="btnClearSave" class="reset" style="background:#7c2d12">æ¸…é™¤å­˜æª”</button>
    <button id="btnQuery" class="query">æŸ¥è©¢åº«å­˜</button>
  </div>
  <!-- manual buy -->
  <div class="manual-buy-row">
    <label>æ‰‹å‹•è²·å…¥åƒ¹</label>
    <input id="manualBuyPrice" type="number" step="0.01" min="0" placeholder="ç•™ç©º=ç¾åƒ¹"/>
    <label>è‚¡æ•¸</label>
    <input id="manualBuyShares" type="number" min="1" value="1000" style="width:80px"/>
    <button id="btnManualBuy" class="manual-buy">æ‰‹å‹•è²·å…¥</button>
  </div>
  <!-- active lots panel -->
  <div class="panel lots-panel" id="lotsPanel" style="display:none">
    <h2>æŒå€‰æ¸…å–®</h2>
    <div id="lotsBody"></div>
  </div>

  <div id="loadNotice" style="display:none;background:#1e3a5f;color:#93c5fd;border-radius:8px;padding:8px 12px;margin:6px 0;font-size:.82rem;text-align:center"></div>

  <!-- status -->
  <div class="panel">
    <h2>å³æ™‚ç‹€æ…‹</h2>
    <div class="grid">
      <div><div class="lbl">è‚¡ç¥¨</div><div class="val" id="dStock">â€”</div></div>
      <div><div class="lbl">ç¾åƒ¹</div><div class="val" id="dPrice">â€”</div></div>
      <div><div class="lbl">è²·å…¥åƒ¹</div><div class="val" id="dBuy">â€”</div></div>
      <div><div class="lbl">æœ€é«˜åƒ¹</div><div class="val" id="dHigh">â€”</div></div>
      <div><div class="lbl">è‚¡æ•¸</div><div class="val" id="dShares">â€”</div></div>
      <div><div class="lbl">è²·å…¥ä¾†æº</div><div class="val" id="dBuySource">â€”</div></div>
      <div><div class="lbl">ç‹€æ…‹</div><div class="val neutral" id="dState">ç­‰å¾…ä¸­</div></div>
      <div><div class="lbl">å ±é…¬ç‡</div><div class="val neutral" id="dReturn">â€”</div></div>
      <div><div class="lbl">ç›£æ§æ™‚çª—</div><div class="val" id="dTimeWindow" style="font-size:.85rem">â€”</div></div>
    </div>
  </div>

  <!-- cumulative stats -->
  <div class="panel">
    <h2>ç´¯ç©çµ±è¨ˆ</h2>
    <div class="stats">
      <div><div class="lbl">äº¤æ˜“æ¬¡æ•¸</div><div class="val" id="sTrades">0</div></div>
      <div><div class="lbl">å‹ç‡</div><div class="val" id="sWinRate">â€”</div></div>
      <div><div class="lbl">å¹³å‡å ±é…¬ç‡</div><div class="val" id="sAvgReturn">â€”</div></div>
      <div><div class="lbl">ç´¯ç©æç›Š</div><div class="val neutral" id="sTotalPnl">$0</div></div>
    </div>
  </div>

  <!-- trade log -->
  <div class="panel">
    <h2>äº¤æ˜“æ—¥èªŒ</h2>
    <div class="log-box" id="logBox"><div class="entry" style="color:#64748b">å°šç„¡äº¤æ˜“è¨˜éŒ„</div></div>
  </div>
</div>

<!-- inventory query modal -->
<div id="invOverlay" class="inv-overlay">
  <div class="inv-modal">
    <button class="close-btn" id="invClose">&times;</button>
    <h2>åº«å­˜æŸ¥è©¢</h2>
    <div id="invContent"></div>
  </div>
</div>

<script>
/* â”€â”€ Config â”€â”€ */
let SHARES = 1000;           // default shares (can be overridden by manual buy)
const STOP_LOSS = 0.9;       // sell if price <= buyPrice * 0.9
const ENTER_TP = 1.1;        // enter trailing-stop mode at +10%
const NEAR_HIGH = 0.998;     // treat as new high if >= highest * 0.998
const TP_EXIT = 0.92;        // sell if price <= highestPrice * 0.92
let POLL_MS = 5000;          // poll interval (configurable)
const POLL_MIN = 3000;
/* Configurable monitoring time window (HH:MM format, Asia/Taipei) */
let MONITOR_START = '09:10';
let MONITOR_END = '12:00';

/* â”€â”€ Price source tracking â”€â”€ */
let lastSource = 'â€”';
let lastUpdateTime = 'â€”';

/* â”€â”€ State â”€â”€ */
let nextLotId = 1;
let state = resetState();
let timer = null;
let lastValidPrice = 0;  // last successfully fetched price

function makeLot(opts) {
  return {
    lotId: nextLotId++,
    stock: opts.stock || '2330',
    shares: opts.shares || 1000,
    buyPrice: opts.buyPrice || 0,
    highestPrice: opts.highestPrice || opts.buyPrice || 0,
    phase: opts.phase || 'holding',   // holding | trailing | sold
    buyTime: opts.buyTime || Date.now(),
    buySource: opts.buySource || 'manual',
    sellPrice: null,
    sellTime: null,
    sellReason: null,
  };
}

function resetState() {
  nextLotId = 1;
  return {
    stock: '2330',
    currentPrice: 0,
    lots: [],            // active + sold lots
    trades: [],          // {buyPrice, sellPrice, pnl, returnPct, reason, shares, buySource, lotId}
  };
}

/* â”€â”€ localStorage persistence â”€â”€ */
const SAVE_KEY = 'stockInvestGame_v1';

function saveState() {
  try {
    const data = {
      version: 2,        // v0.1.6+ multi-lot format (v0.1.8: per-symbol pricing)
      stock: state.stock,
      currentPrice: state.currentPrice,
      lots: state.lots,
      nextLotId: nextLotId,
      trades: (state.trades || []).slice(-100),
      source: lastSource,
      sourceTime: lastUpdateTime,
      pollSec: POLL_MS / 1000,
      monitorStart: MONITOR_START,
      monitorEnd: MONITOR_END,
      savedAt: Date.now(),
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
  } catch (_) { /* localStorage unavailable â€” silently ignore */ }
}

function loadState() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return null;
    const d = JSON.parse(raw);
    if (!d || typeof d !== 'object') return null;

    const base = {
      source:       typeof d.source === 'string' ? d.source : 'â€”',
      sourceTime:   typeof d.sourceTime === 'string' ? d.sourceTime : 'â€”',
      pollSec:      typeof d.pollSec === 'number' && d.pollSec >= POLL_MIN/1000 ? d.pollSec : 5,
      monitorStart: typeof d.monitorStart === 'string' && /^\d{2}:\d{2}$/.test(d.monitorStart) ? d.monitorStart : '09:10',
      monitorEnd:   typeof d.monitorEnd === 'string' && /^\d{2}:\d{2}$/.test(d.monitorEnd) ? d.monitorEnd : '12:00',
      trades:       Array.isArray(d.trades) ? d.trades.slice(-100) : [],
      currentPrice: typeof d.currentPrice === 'number' && d.currentPrice >= 0 ? d.currentPrice : 0,
      stock:        typeof d.stock === 'string' && d.stock ? d.stock : '2330',
    };

    // v2 format (multi-lot)
    if (d.version === 2 && Array.isArray(d.lots)) {
      // Backfill stock field for old lots that may lack it
      base.lots = d.lots.map(l => {
        if (!l.stock) l.stock = base.stock;
        return l;
      });
      base.nextLotId = typeof d.nextLotId === 'number' ? d.nextLotId : 1;
      return base;
    }

    // v1 migration: single position â†’ lots array
    base.lots = [];
    base.nextLotId = 1;
    const phase = ['holding','trailing'].includes(d.phase) ? d.phase : null;
    if (phase && typeof d.buyPrice === 'number' && d.buyPrice > 0) {
      base.lots.push({
        lotId: base.nextLotId++,
        stock: base.stock,
        shares: typeof d.shares === 'number' && d.shares > 0 ? d.shares : 1000,
        buyPrice: d.buyPrice,
        highestPrice: typeof d.highestPrice === 'number' && d.highestPrice > 0 ? d.highestPrice : d.buyPrice,
        phase: phase,
        buyTime: d.savedAt || Date.now(),
        buySource: typeof d.buySource === 'string' && d.buySource ? d.buySource : 'manual',
        sellPrice: null, sellTime: null, sellReason: null,
      });
    }
    return base;
  } catch (_) { return null; }
}

function clearSave() {
  try { localStorage.removeItem(SAVE_KEY); } catch (_) { /* ignore */ }
}

/* â”€â”€ DOM refs â”€â”€ */
const $ = id => document.getElementById(id);
const btnStart = $('btnStart'), btnStop = $('btnStop'), btnReset = $('btnReset');
const btnClearSave = $('btnClearSave');
const stockInput = $('stockInput'), stockSelect = $('stockSelect');

stockSelect.addEventListener('change', () => { stockInput.value = stockSelect.value; });
stockInput.addEventListener('input', () => {
  const v = stockInput.value.trim();
  if ([...stockSelect.options].some(o => o.value === v)) stockSelect.value = v;
});

const btnQuery = $('btnQuery');
const btnManualSell = $('btnManualSell');
const btnManualBuy = $('btnManualBuy');

btnStart.addEventListener('click', startMonitor);
btnStop.addEventListener('click', stopMonitor);
btnReset.addEventListener('click', doReset);
btnClearSave.addEventListener('click', doClearSave);
btnQuery.addEventListener('click', showInventory);
btnManualBuy.addEventListener('click', doManualBuy);
btnManualSell.addEventListener('click', doManualSell);
$('invClose').addEventListener('click', () => { $('invOverlay').classList.remove('show'); });
$('invOverlay').addEventListener('click', e => { if (e.target === $('invOverlay')) $('invOverlay').classList.remove('show'); });

/* â”€â”€ Market hours check (Asia/Taipei) â”€â”€ */
function taipeiNow() {
  return new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Taipei' }));
}
function parseHHMM(s) {
  const [h, m] = s.split(':').map(Number);
  return h * 60 + (m || 0);
}
function isMarketOpen() {
  const d = taipeiNow();
  const day = d.getDay();
  if (day === 0 || day === 6) return false;
  const mins = d.getHours() * 60 + d.getMinutes();
  return mins >= parseHHMM(MONITOR_START) && mins < parseHHMM(MONITOR_END);
}
function updateMarketBar() {
  const bar = $('marketBar');
  if (isMarketOpen()) {
    bar.className = 'market-bar open';
    bar.textContent = `ç›£æ§ä¸­ ${MONITOR_START} â€“ ${MONITOR_END}`;
  } else {
    bar.className = 'market-bar closed';
    bar.textContent = `éç›£æ§æ™‚æ®µ â€” ç­‰å¾… ${MONITOR_START}`;
  }
}

/* â”€â”€ Price fetching â€” multi-source with fallback chain â”€â”€ */

// CORS proxy helpers â€” used when direct fetch fails due to CORS
const PROXIES = [
  url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
  url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
];

async function fetchWithTimeout(url, ms = 4000) {
  const resp = await fetch(url, { signal: AbortSignal.timeout(ms) });
  if (!resp.ok) throw new Error('http ' + resp.status);
  return resp;
}

async function tryDirectOrProxy(url, ms = 4000) {
  // Try direct first
  try { return await fetchWithTimeout(url, ms); } catch (_) { /* fall through */ }
  // Try each proxy
  for (const mkProxy of PROXIES) {
    try { return await fetchWithTimeout(mkProxy(url), ms); } catch (_) { /* next */ }
  }
  throw new Error('all fetch attempts failed');
}

// Source A: TWSE JSON (tse + otc)
async function fetchTWSE(stock) {
  const ts = Date.now();
  for (const ex of ['tse', 'otc']) {
    try {
      const url = `https://mis.twse.com.tw/stock/api/getStockInfo.jsp?ex_ch=${ex}_${stock}.tw&_=${ts}`;
      const resp = await tryDirectOrProxy(url);
      const json = await resp.json();
      if (json.msgArray && json.msgArray.length > 0) {
        const info = json.msgArray[0];
        let price = parseFloat(info.z);
        if (isNaN(price) || price <= 0) price = parseFloat(info.y);
        if (isNaN(price) || price <= 0) continue;
        return price;
      }
    } catch (_) { /* try next exchange */ }
  }
  throw new Error('TWSE failed');
}

// Source B: Yahoo Finance quote
async function fetchYahoo(stock) {
  const symbol = `${stock}.TW`;
  const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=1d&interval=1m`;
  const resp = await tryDirectOrProxy(url);
  const json = await resp.json();
  const meta = json?.chart?.result?.[0]?.meta;
  const price = meta?.regularMarketPrice;
  if (typeof price !== 'number' || price <= 0) throw new Error('Yahoo no price');
  return price;
}

// Source C: Stooq (text/csv endpoint)
async function fetchStooq(stock) {
  const url = `https://stooq.com/q/l/?s=${stock}.tw&f=sd2t2ohlcv&h&e=csv`;
  const resp = await tryDirectOrProxy(url);
  const text = await resp.text();
  // CSV: Symbol,Date,Time,Open,High,Low,Close,Volume
  const lines = text.trim().split('\n');
  if (lines.length < 2) throw new Error('Stooq empty');
  const cols = lines[1].split(',');
  const close = parseFloat(cols[6]); // Close column
  if (isNaN(close) || close <= 0) throw new Error('Stooq no price');
  return close;
}

// Main dispatcher â€” tries sources in priority order, returns null on failure
const SOURCES = [
  { name: 'TWSE', fn: fetchTWSE },
  { name: 'Yahoo', fn: fetchYahoo },
  { name: 'Stooq', fn: fetchStooq },
];

async function fetchPrice(stock) {
  for (const src of SOURCES) {
    try {
      const price = await src.fn(stock);
      setSource(src.name);
      lastValidPrice = price;
      return price;
    } catch (_) { /* try next */ }
  }
  // All sources failed â€” return null (no simulation)
  return null;
}

function setSource(name) {
  lastSource = name;
  const now = taipeiNow();
  lastUpdateTime = now.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  $('sourceBar').textContent = `ä¾†æºï¼š${lastSource} ï½œ æ›´æ–°ï¼š${lastUpdateTime}`;
}

/* â”€â”€ Helper: get active lots â”€â”€ */
function activeLots() { return state.lots.filter(l => l.phase === 'holding' || l.phase === 'trailing'); }

/* â”€â”€ Per-symbol price map â”€â”€ */
let priceMap = {};  // { symbol: { price, source, time } }

async function fetchPriceMap(symbols) {
  const map = {};
  await Promise.all(symbols.map(async (sym) => {
    const price = await fetchPrice(sym);
    if (price !== null) {
      map[sym] = { price, source: lastSource, time: lastUpdateTime };
    }
  }));
  return map;
}

/* â”€â”€ Core loop â”€â”€ */
async function tick() {
  updateMarketBar();

  // Collect unique symbols from active lots
  const active = activeLots();
  const symbols = [...new Set(active.map(l => l.stock))];
  // Also include state.stock for UI display
  if (state.stock && !symbols.includes(state.stock)) symbols.push(state.stock);

  if (symbols.length === 0) {
    // No active lots, just fetch state.stock for display
    const price = await fetchPrice(state.stock);
    if (price !== null) {
      state.currentPrice = price;
      priceMap[state.stock] = { price, source: lastSource, time: lastUpdateTime };
    }
    renderPrice();
    return;
  }

  // Fetch prices for all unique symbols in parallel
  const newMap = await fetchPriceMap(symbols);
  Object.assign(priceMap, newMap);

  // Update sourceBar with summary
  const fetched = Object.keys(newMap);
  const failed = symbols.filter(s => !newMap[s]);
  if (fetched.length > 0) {
    const lastEntry = newMap[fetched[fetched.length - 1]];
    $('sourceBar').textContent = `ä¾†æºï¼š${lastEntry.source} ï½œ æ›´æ–°ï¼š${lastEntry.time}` +
      (failed.length > 0 ? ` ï½œ æŸ¥ç„¡ï¼š${failed.join(',')}` : '');
  } else {
    $('sourceBar').textContent = `ä¾†æºï¼šæŸ¥ç„¡ç¾åƒ¹ ï½œ ä¸Šæ¬¡ï¼š${lastUpdateTime}`;
  }

  // Update state.currentPrice for backward compat (use state.stock's price)
  if (priceMap[state.stock]) {
    state.currentPrice = priceMap[state.stock].price;
  }
  renderPrice();

  if (!isMarketOpen()) return;  // no strategy outside monitoring window

  // Log skipped symbols
  for (const sym of failed) {
    addLog(`è‚¡è™Ÿ ${sym} æŸ¥ç„¡ç¾åƒ¹ï¼Œè·³éç›¸é—œ lots`, 'neutral');
  }

  // Apply strategy to each active lot using its own symbol's price
  for (const lot of active) {
    const entry = priceMap[lot.stock];
    if (!entry) continue;  // no price for this symbol â€” skip
    const price = entry.price;

    if (lot.phase === 'holding') {
      if (price <= lot.buyPrice * STOP_LOSS) {
        executeSellLot(lot, price, 'åœæ');
      } else if (price >= lot.buyPrice * ENTER_TP) {
        lot.phase = 'trailing';
        lot.highestPrice = price;
        addLog(`Lot#${lot.lotId}(${lot.stock}) é€²å…¥åœåˆ©æ¨¡å¼ (ç¾åƒ¹ $${price}, è²·å…¥ $${lot.buyPrice})`, 'neutral');
        saveState();
      }
    }
    if (lot.phase === 'trailing') {
      if (price >= lot.highestPrice * NEAR_HIGH) {
        lot.highestPrice = Math.max(lot.highestPrice, price);
      }
      if (price <= lot.highestPrice * TP_EXIT) {
        executeSellLot(lot, price, 'ç§»å‹•åœåˆ©');
      }
    }
  }

  renderAll();
}

function executeSellLot(lot, price, reason) {
  const sh = lot.shares || 1000;
  const pnl = (price - lot.buyPrice) * sh;
  const returnPct = ((price - lot.buyPrice) / lot.buyPrice) * 100;
  const trade = { buyPrice: lot.buyPrice, sellPrice: price, pnl, returnPct, reason, shares: sh, buySource: lot.buySource || 'manual', lotId: lot.lotId };
  state.trades.push(trade);
  lot.phase = 'sold';
  lot.sellPrice = price;
  lot.sellTime = Date.now();
  lot.sellReason = reason;
  const sign = pnl >= 0 ? '+' : '';
  addLog(
    `Lot#${lot.lotId}(${lot.stock}) è³£å‡º ${sh} è‚¡ @ $${price}ï¼ˆ${reason}ï¼‰å ±é…¬ ${sign}${returnPct.toFixed(2)}%  æç›Š ${sign}$${pnl.toFixed(0)}`,
    pnl >= 0 ? 'up' : 'down'
  );
  saveState();
}

/* â”€â”€ Start / Stop / Reset â”€â”€ */
function startMonitor() {
  const inputStock = stockInput.value.trim() || '2330';
  state.stock = inputStock;
  lastValidPrice = 0;
  // Read configurable poll interval
  const pollSec = Math.max(POLL_MIN / 1000, parseInt($('pollInput').value) || 5);
  POLL_MS = pollSec * 1000;
  $('pollInput').value = pollSec;
  // Read monitoring time window
  readMonitorTime();
  btnStart.disabled = true;
  btnStop.disabled = false;
  stockInput.disabled = true;
  stockSelect.disabled = true;
  $('pollInput').disabled = true;
  $('monitorStart').disabled = true;
  $('monitorEnd').disabled = true;
  $('loadNotice').style.display = 'none';
  const lotsCount = activeLots().length;
  const modeLabel = lotsCount > 0 ? `çºŒç›£ï¼ˆ${lotsCount} ç­†æŒå€‰ï¼‰` : 'é–‹å§‹ç›£æ§';
  addLog(`${modeLabel} ${state.stock}ï¼ˆè¼ªè©¢ ${pollSec}sï¼Œæ™‚çª— ${MONITOR_START}~${MONITOR_END}ï¼‰`, 'neutral');
  saveState();
  tick();
  timer = setInterval(tick, POLL_MS);
}

/* Read monitoring time from UI inputs */
function readMonitorTime() {
  const s = $('monitorStart').value.trim();
  const e = $('monitorEnd').value.trim();
  if (/^\d{1,2}:\d{2}$/.test(s)) MONITOR_START = s.padStart(5, '0');
  if (/^\d{1,2}:\d{2}$/.test(e)) MONITOR_END = e.padStart(5, '0');
  $('monitorStart').value = MONITOR_START;
  $('monitorEnd').value = MONITOR_END;
}

/* â”€â”€ Manual Buy â”€â”€ */
async function doManualBuy() {
  const inputStock = stockInput.value.trim() || '2330';
  const sharesVal = parseInt($('manualBuyShares').value) || 1000;
  const priceVal = parseFloat($('manualBuyPrice').value);

  let buyP;
  if (!isNaN(priceVal) && priceVal > 0) {
    buyP = priceVal;
  } else {
    buyP = await fetchPrice(inputStock);
    if (buyP === null) {
      alert('æŸ¥ç„¡ç¾åƒ¹ï¼Œç„¡æ³•è²·å…¥ã€‚è«‹æ‰‹å‹•è¼¸å…¥è²·å…¥åƒ¹æˆ–ç¨å¾Œå†è©¦ã€‚');
      return;
    }
  }

  state.stock = inputStock;
  state.currentPrice = buyP;
  const lot = makeLot({ stock: inputStock, shares: sharesVal, buyPrice: buyP, buySource: 'manual' });
  state.lots.push(lot);
  addLog(`Lot#${lot.lotId} æ‰‹å‹•è²·å…¥ ${sharesVal} è‚¡ ${inputStock} @ $${buyP}`, 'neutral');
  saveState();
  renderAll();

  // Auto-start monitoring if not already running
  if (!timer) {
    startMonitor();
  }
}

function stopMonitor() {
  clearInterval(timer);
  timer = null;
  btnStart.disabled = false;
  btnStop.disabled = true;
  stockInput.disabled = false;
  stockSelect.disabled = false;
  $('pollInput').disabled = false;
  $('monitorStart').disabled = false;
  $('monitorEnd').disabled = false;
  const active = activeLots();
  if (active.length > 0) {
    addLog(`å·²åœæ­¢ç›£æ§ï¼ˆ${active.length} ç­†æŒå€‰ä¿ç•™ï¼‰`, 'neutral');
  } else {
    addLog('ç›£æ§å·²åœæ­¢', 'neutral');
  }
  updateManualSellBtn();
  saveState();
}

/* â”€â”€ Manual Sell â”€â”€ */
async function doManualSell() {
  const active = activeLots();
  if (active.length === 0) {
    alert('ç›®å‰ç„¡æŒå€‰ï¼Œç„¡æ³•è³£å‡º');
    return;
  }
  // Fetch prices per unique symbol
  const symbols = [...new Set(active.map(l => l.stock))];
  const newMap = await fetchPriceMap(symbols);
  Object.assign(priceMap, newMap);

  const failedSyms = symbols.filter(s => !newMap[s]);
  let soldCount = 0;
  for (const lot of active) {
    const entry = priceMap[lot.stock];
    if (!entry) continue;  // skip lots without price
    executeSellLot(lot, entry.price, 'æ‰‹å‹•è³£å‡º');
    soldCount++;
  }
  if (failedSyms.length > 0) {
    alert(`ä»¥ä¸‹è‚¡è™ŸæŸ¥ç„¡ç¾åƒ¹ï¼Œç›¸é—œ lots å·²è·³éï¼š${failedSyms.join(', ')}`);
  }
  if (soldCount === 0 && failedSyms.length > 0) {
    alert('æ‰€æœ‰è‚¡è™Ÿçš†æŸ¥ç„¡ç¾åƒ¹ï¼Œç„¡æ³•è³£å‡ºã€‚è«‹ç¨å¾Œå†è©¦ã€‚');
  }
  // Update state.currentPrice for display
  if (priceMap[state.stock]) state.currentPrice = priceMap[state.stock].price;
  updateManualSellBtn();
  renderAll();
}

async function doManualSellLot(lotId) {
  const lot = state.lots.find(l => l.lotId === lotId);
  if (!lot || (lot.phase !== 'holding' && lot.phase !== 'trailing')) return;
  const price = await fetchPrice(lot.stock);
  if (price === null) {
    alert(`è‚¡è™Ÿ ${lot.stock} æŸ¥ç„¡ç¾åƒ¹ï¼Œå·²è·³éè³£å‡ºã€‚è«‹ç¨å¾Œå†è©¦ã€‚`);
    return;
  }
  priceMap[lot.stock] = { price, source: lastSource, time: lastUpdateTime };
  executeSellLot(lot, price, 'æ‰‹å‹•è³£å‡º');
  updateManualSellBtn();
  renderAll();
}

function updateManualSellBtn() {
  btnManualSell.disabled = activeLots().length === 0;
}

function doReset() {
  stopMonitor();
  state = resetState();
  lastValidPrice = 0;
  $('logBox').innerHTML = '<div class="entry" style="color:#64748b">å°šç„¡äº¤æ˜“è¨˜éŒ„</div>';
  renderAll();
  addLog('å·²é‡ç½®', 'neutral');
  saveState();
}

function doClearSave() {
  stopMonitor();
  state = resetState();
  lastValidPrice = 0;
  clearSave();
  $('logBox').innerHTML = '<div class="entry" style="color:#64748b">å°šç„¡äº¤æ˜“è¨˜éŒ„</div>';
  $('loadNotice').style.display = 'none';
  lastSource = 'â€”';
  lastUpdateTime = 'â€”';
  $('sourceBar').textContent = 'ä¾†æºï¼šâ€” ï½œ æ›´æ–°ï¼šâ€”';
  POLL_MS = 5000;
  $('pollInput').value = 5;
  MONITOR_START = '09:10';
  MONITOR_END = '12:00';
  $('monitorStart').value = '09:10';
  $('monitorEnd').value = '12:00';
  SHARES = 1000;
  $('manualBuyShares').value = 1000;
  $('manualBuyPrice').value = '';
  stockInput.value = '2330';
  stockSelect.value = '2330';
  renderAll();
  addLog('å­˜æª”å·²æ¸…é™¤ï¼Œå›åˆ°åˆå§‹ç‹€æ…‹', 'neutral');
}

/* â”€â”€ Render â”€â”€ */
function renderPrice() {
  $('dStock').textContent = state.stock;
  $('dPrice').textContent = state.currentPrice ? `$${state.currentPrice.toFixed(2)}` : 'â€”';
}

function renderAll() {
  renderPrice();
  updateManualSellBtn();

  const active = activeLots();
  const hasPos = active.length > 0;
  $('dTimeWindow').textContent = `${MONITOR_START} ~ ${MONITOR_END}`;

  // Summary of active lots in the status panel
  if (hasPos) {
    const totalShares = active.reduce((s, l) => s + l.shares, 0);
    const avgBuy = active.reduce((s, l) => s + l.buyPrice * l.shares, 0) / totalShares;
    const hasTrailing = active.some(l => l.phase === 'trailing');
    const maxHigh = Math.max(...active.map(l => l.highestPrice));

    $('dBuy').textContent = active.length === 1 ? `$${active[0].buyPrice.toFixed(2)}` : `avg $${avgBuy.toFixed(2)}`;
    $('dHigh').textContent = hasTrailing ? `$${maxHigh.toFixed(2)}` : 'â€”';
    $('dShares').textContent = `${totalShares}ï¼ˆ${active.length}ç­†ï¼‰`;
    $('dBuySource').textContent = active.length === 1 ? (active[0].buySource === 'manual' ? 'æ‰‹å‹•è²·å…¥' : 'è‡ªå‹•è²·å…¥') : `${active.length} ç­†`;

    const stoppedSuffix = !timer ? 'ï¼ˆæœªç›£æ§ï¼‰' : '';
    const phaseLabel = hasTrailing ? 'åœåˆ©æ¨¡å¼' : 'æŒæœ‰';
    $('dState').textContent = phaseLabel + stoppedSuffix;
    $('dState').className = 'val ' + (hasTrailing ? 'up' : 'neutral');

    const totalPnl = active.reduce((s, l) => {
      const e = priceMap[l.stock];
      return s + ((e ? e.price : state.currentPrice) - l.buyPrice) * l.shares;
    }, 0);
    const totalCost = active.reduce((s, l) => s + l.buyPrice * l.shares, 0);
    const pctReturn = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
    const retEl = $('dReturn');
    retEl.textContent = (pctReturn >= 0 ? '+' : '') + pctReturn.toFixed(2) + '%';
    retEl.className = 'val ' + (pctReturn >= 0 ? 'up' : 'down');
  } else {
    $('dBuy').textContent = 'â€”';
    $('dHigh').textContent = 'â€”';
    $('dShares').textContent = 'â€”';
    $('dBuySource').textContent = 'â€”';
    $('dState').textContent = state.trades.length > 0 ? 'å·²è³£å‡º' : 'ç­‰å¾…ä¸­';
    $('dState').className = 'val neutral';
    const retEl = $('dReturn');
    if (state.trades.length > 0) {
      const last = state.trades[state.trades.length - 1];
      retEl.textContent = (last.returnPct >= 0 ? '+' : '') + last.returnPct.toFixed(2) + '%';
      retEl.className = 'val ' + (last.returnPct >= 0 ? 'up' : 'down');
    } else {
      retEl.textContent = 'â€”';
      retEl.className = 'val neutral';
    }
  }

  // cumulative stats
  const t = state.trades;
  $('sTrades').textContent = t.length;
  if (t.length > 0) {
    const wins = t.filter(x => x.pnl > 0).length;
    $('sWinRate').textContent = (wins / t.length * 100).toFixed(1) + '%';
    const avgRet = t.reduce((s, x) => s + x.returnPct, 0) / t.length;
    const avgEl = $('sAvgReturn');
    avgEl.textContent = (avgRet >= 0 ? '+' : '') + avgRet.toFixed(2) + '%';
    avgEl.className = 'val ' + (avgRet >= 0 ? 'up' : 'down');
    const totalPnl = t.reduce((s, x) => s + x.pnl, 0);
    const pnlEl = $('sTotalPnl');
    pnlEl.textContent = (totalPnl >= 0 ? '+' : '') + '$' + totalPnl.toFixed(0);
    pnlEl.className = 'val ' + (totalPnl >= 0 ? 'up' : 'down');
  } else {
    $('sWinRate').textContent = 'â€”';
    $('sAvgReturn').textContent = 'â€”';
    $('sAvgReturn').className = 'val neutral';
    $('sTotalPnl').textContent = '$0';
    $('sTotalPnl').className = 'val neutral';
  }

  // Render active lots panel
  renderLotsPanel();
}

/* â”€â”€ Strategy helper: compute thresholds & distance for a lot â”€â”€ */
function lotStrategyInfo(lot, lotPrice) {
  const bp = lot.buyPrice;
  const stopLossPrice = bp * STOP_LOSS;         // 0.9
  const enterTpPrice = bp * ENTER_TP;           // 1.1
  const info = {
    stopLossPrice,
    enterTpPrice,
    trailSellPrice: null,
    distStopLoss: null,    // % distance from current price to stop-loss (positive = safe)
    distEnterTp: null,     // % distance to enter trailing
    distTrailSell: null,   // % distance to trailing sell
    phase: lot.phase,
  };
  if (lotPrice !== null && bp > 0) {
    info.distStopLoss = ((lotPrice - stopLossPrice) / stopLossPrice) * 100;
    info.distEnterTp = ((enterTpPrice - lotPrice) / lotPrice) * 100;
  }
  if (lot.phase === 'trailing') {
    info.trailSellPrice = lot.highestPrice * TP_EXIT;  // 0.92
    if (lotPrice !== null) {
      info.distTrailSell = ((lotPrice - info.trailSellPrice) / info.trailSellPrice) * 100;
    }
  }
  return info;
}

/* Color tag class based on distance % */
function distClass(pct, isLoss) {
  if (pct === null) return 'strat-info';
  const abs = Math.abs(pct);
  if (isLoss) {
    // distance to stop-loss: smaller = more dangerous
    if (abs <= 2) return 'strat-danger';
    if (abs <= 5) return 'strat-warn';
    return 'strat-safe';
  }
  // distance to take-profit or trail-sell: smaller = closer to trigger
  if (abs <= 2) return 'strat-warn';
  if (abs <= 5) return 'strat-info';
  return 'strat-safe';
}

function renderLotsPanel() {
  const active = activeLots();
  const panel = $('lotsPanel');
  const body = $('lotsBody');
  if (active.length === 0) {
    panel.style.display = 'none';
    return;
  }
  panel.style.display = 'block';
  let html = '';
  for (const lot of active) {
    const entry = priceMap[lot.stock];
    const lotPrice = entry ? entry.price : null;
    const si = lotStrategyInfo(lot, lotPrice);
    const pct = (lotPrice && lot.buyPrice > 0) ? ((lotPrice - lot.buyPrice) / lot.buyPrice * 100) : null;
    const pctCls = pct !== null ? (pct >= 0 ? 'lot-up' : 'lot-down') : 'lot-neutral';
    const sign = pct !== null && pct >= 0 ? '+' : '';
    const phaseBadge = lot.phase === 'trailing'
      ? '<span class="phase-badge phase-trailing">åœåˆ©è¿½è¹¤</span>'
      : '<span class="phase-badge phase-holding">æŒæœ‰ä¸­</span>';

    html += '<div class="lot-detail">';
    // Header: lotId, stock, shares, phase, sell button
    html += '<div class="lot-header">';
    html += `<strong>Lot#${lot.lotId} ${lot.stock}</strong> ${phaseBadge}`;
    html += `<button class="sell-lot" onclick="doManualSellLot(${lot.lotId})">è³£å‡º</button>`;
    html += '</div>';

    // Price row: buy price, current price, source, update time
    const priceStr = lotPrice !== null ? `$${lotPrice.toFixed(2)}` : '<span style="color:#f59e0b">ç„¡å³æ™‚åƒ¹</span>';
    const srcStr = entry ? entry.source : 'â€”';
    const timeStr = entry ? entry.time : 'â€”';
    const pctStr = pct !== null ? `<span class="${pctCls}">${sign}${pct.toFixed(2)}%</span>` : 'â€”';
    html += '<div class="lot-price-row">';
    html += `<span>è²· $${lot.buyPrice.toFixed(2)} Ã— ${lot.shares}è‚¡</span>`;
    html += `<span>ç¾åƒ¹ ${priceStr} ${pctStr}</span>`;
    html += `<span class="lot-meta">${srcStr} ${timeStr}</span>`;
    html += '</div>';

    // Strategy thresholds row
    html += '<div class="strat-row">';
    // Stop-loss
    const slDist = si.distStopLoss;
    const slCls = distClass(slDist, true);
    const slDistStr = slDist !== null ? `è· ${slDist.toFixed(1)}%` : '';
    html += `<span class="strat-tag ${slCls}">åœæ $${si.stopLossPrice.toFixed(2)} ${slDistStr}</span>`;

    if (lot.phase === 'holding') {
      // Distance to enter trailing
      const tpDist = si.distEnterTp;
      const tpCls = distClass(tpDist, false);
      const tpDistStr = tpDist !== null ? `å·® ${tpDist.toFixed(1)}%` : '';
      html += `<span class="strat-tag ${tpCls}">é€²åœåˆ© $${si.enterTpPrice.toFixed(2)} ${tpDistStr}</span>`;
    }
    if (lot.phase === 'trailing') {
      // Trailing sell threshold
      const tsDist = si.distTrailSell;
      const tsCls = distClass(tsDist, true);
      const tsDistStr = tsDist !== null ? `è· ${tsDist.toFixed(1)}%` : '';
      html += `<span class="strat-tag ${tsCls}">å›æ’¤è³£ $${si.trailSellPrice.toFixed(2)} ${tsDistStr}</span>`;
      html += `<span class="strat-tag strat-info">æœ€é«˜ $${lot.highestPrice.toFixed(2)}</span>`;
    }
    html += '</div>';
    html += '</div>';
  }
  if (active.length > 1) {
    html += '<button class="sell-all" onclick="doManualSell()">è³£å‡ºå…¨éƒ¨</button>';
  }
  body.innerHTML = html;
}

function addLog(msg, type) {
  const box = $('logBox');
  // remove placeholder
  if (box.querySelector('.entry[style]')) box.innerHTML = '';
  const now = taipeiNow();
  const ts = now.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  const cls = type === 'up' ? 'log-entry-up' : type === 'down' ? 'log-entry-down' : '';
  const div = document.createElement('div');
  div.className = 'entry ' + cls;
  div.textContent = `[${ts}] ${msg}`;
  box.prepend(div);
}

/* â”€â”€ Inventory Query â”€â”€ */
async function showInventory() {
  const active = activeLots();

  // Fetch prices per unique symbol across all active lots
  const symbols = [...new Set(active.map(l => l.stock))];
  if (symbols.length > 0) {
    const newMap = await fetchPriceMap(symbols);
    Object.assign(priceMap, newMap);
  } else if (state.stock) {
    const p = await fetchPrice(state.stock);
    if (p !== null) {
      priceMap[state.stock] = { price: p, source: lastSource, time: lastUpdateTime };
      state.currentPrice = p;
    }
  }

  const container = $('invContent');
  let html = '';

  if (active.length > 0) {
    const totalShares = active.reduce((s, l) => s + l.shares, 0);
    const monitorLabel = timer ? '' : 'ï¼ˆç›£æ§å·²åœæ­¢ï¼‰';

    // Compute total PnL only for lots with price
    let totalPnl = 0, totalCost = 0, allHavePrice = true;
    for (const lot of active) {
      const entry = priceMap[lot.stock];
      if (entry) {
        totalPnl += (entry.price - lot.buyPrice) * lot.shares;
        totalCost += lot.buyPrice * lot.shares;
      } else {
        allHavePrice = false;
        totalCost += lot.buyPrice * lot.shares;
      }
    }
    const totalRetPct = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
    const tSign = totalPnl >= 0 ? '+' : '';
    const tCls = totalPnl >= 0 ? 'up' : 'down';

    // Summary
    html += '<div class="inv-grid">';
    const stockList = [...new Set(active.map(l => l.stock))].join(', ');
    html += `<div><div class="lbl">è‚¡ç¥¨ä»£è™Ÿ</div><div class="val">${stockList}</div></div>`;
    html += `<div><div class="lbl">æŒå€‰ç­†æ•¸</div><div class="val">${active.length} ç­†${monitorLabel}</div></div>`;
    html += `<div><div class="lbl">ç¸½æŒæœ‰è‚¡æ•¸</div><div class="val">${totalShares}</div></div>`;
    html += `<div><div class="lbl">ç¸½æœªå¯¦ç¾æç›Š</div><div class="val ${tCls}">${tSign}$${totalPnl.toFixed(0)}${allHavePrice ? '' : 'ï¼ˆéƒ¨åˆ†ç„¡å³æ™‚åƒ¹ï¼‰'}</div></div>`;
    html += `<div><div class="lbl">ç¸½å ±é…¬ç‡</div><div class="val ${tCls}">${tSign}${totalRetPct.toFixed(2)}%</div></div>`;
    html += '</div>';

    // Per-lot detail with strategy dashboard
    html += '<div class="section-title">å„ç­†æŒå€‰ â€” ç­–ç•¥çœ‹æ¿</div>';
    for (const lot of active) {
      const entry = priceMap[lot.stock];
      const lotPrice = entry ? entry.price : null;
      const si = lotStrategyInfo(lot, lotPrice);
      const phaseBadge = lot.phase === 'trailing'
        ? '<span class="phase-badge phase-trailing">åœåˆ©è¿½è¹¤</span>'
        : '<span class="phase-badge phase-holding">æŒæœ‰ä¸­</span>';
      const srcLabel = lot.buySource === 'manual' ? 'æ‰‹å‹•' : 'è‡ªå‹•';

      // Status summary text
      let statusText = '';
      if (lot.phase === 'holding') {
        if (si.distStopLoss !== null && si.distStopLoss <= 3) statusText = 'æ¥è¿‘åœæç·šï¼Œè«‹ç•™æ„é¢¨éšª';
        else if (si.distEnterTp !== null && si.distEnterTp <= 3) statusText = 'å³å°‡é€²å…¥åœåˆ©æ¨¡å¼';
        else statusText = 'æŒæœ‰è§€æœ›ä¸­ï¼Œç­‰å¾…çªç ´';
      } else if (lot.phase === 'trailing') {
        if (si.distTrailSell !== null && si.distTrailSell <= 3) statusText = 'æ¥è¿‘å›æ’¤è³£å‡ºç·šï¼Œç•™æ„ç²åˆ©äº†çµ';
        else statusText = 'åœåˆ©è¿½è¹¤ä¸­ï¼ŒæŒçºŒè¿½é«˜';
      }

      html += '<div class="last-trade">';
      html += `<div><strong>Lot#${lot.lotId}</strong> ${lot.stock} ${phaseBadge}ï¼ˆ${srcLabel}ï¼‰</div>`;
      html += `<div style="color:#94a3b8;font-size:.75rem;margin:2px 0">${statusText}</div>`;
      html += `<div>è²·å…¥åƒ¹ï¼š$${lot.buyPrice.toFixed(2)} Ã— ${lot.shares} è‚¡</div>`;
      if (lotPrice !== null) {
        const pnl = (lotPrice - lot.buyPrice) * lot.shares;
        const retPct = lot.buyPrice > 0 ? ((lotPrice - lot.buyPrice) / lot.buyPrice * 100) : 0;
        const sign = pnl >= 0 ? '+' : '';
        const cls = pnl >= 0 ? 'up' : 'down';
        html += `<div>ç¾åƒ¹ï¼š$${lotPrice.toFixed(2)}ï¼ˆ${entry.source} ${entry.time}ï¼‰</div>`;
        html += `<div>æç›Šï¼š<span class="val ${cls}" style="font-size:.82rem">${sign}$${pnl.toFixed(0)}</span>ï¼ˆ${sign}${retPct.toFixed(2)}%ï¼‰</div>`;
      } else {
        html += `<div>ç¾åƒ¹ï¼š<span style="color:#f59e0b">ç„¡å³æ™‚åƒ¹</span>ï¼ˆä¾†æºï¼šâ€”ï¼‰</div>`;
        html += `<div>æç›Šï¼šâ€”</div>`;
      }
      // Strategy thresholds
      html += '<div style="margin-top:4px">';
      const slDist = si.distStopLoss;
      const slCls = distClass(slDist, true);
      const slDistStr = slDist !== null ? `è· ${slDist.toFixed(1)}%` : '';
      html += `<span class="strat-tag ${slCls}">åœæ $${si.stopLossPrice.toFixed(2)} ${slDistStr}</span> `;
      if (lot.phase === 'holding') {
        const tpDist = si.distEnterTp;
        const tpCls = distClass(tpDist, false);
        const tpDistStr = tpDist !== null ? `å·® ${tpDist.toFixed(1)}%` : '';
        html += `<span class="strat-tag ${tpCls}">é€²åœåˆ© $${si.enterTpPrice.toFixed(2)} ${tpDistStr}</span> `;
      }
      if (lot.phase === 'trailing') {
        html += `<div>æœ€é«˜åƒ¹ï¼š$${lot.highestPrice.toFixed(2)}</div>`;
        const tsDist = si.distTrailSell;
        const tsCls = distClass(tsDist, true);
        const tsDistStr = tsDist !== null ? `è· ${tsDist.toFixed(1)}%` : '';
        html += `<span class="strat-tag ${tsCls}">å›æ’¤è³£ $${si.trailSellPrice.toFixed(2)} ${tsDistStr}</span> `;
      }
      html += '</div>';
      html += '</div>';
    }

    html += `<div style="margin-top:8px;font-size:.75rem;color:#64748b;text-align:center">æœ€å¾Œæ›´æ–°ï¼š${lastUpdateTime} ï½œ ä¾†æºï¼š${lastSource}</div>`;
  } else {
    html += '<div class="no-pos">ç›®å‰ç„¡æŒå€‰</div>';

    if (state.trades.length > 0) {
      const last = state.trades[state.trades.length - 1];
      const sign = last.pnl >= 0 ? '+' : '';
      const cls = last.pnl >= 0 ? 'up' : 'down';
      html += '<div class="section-title">æœ€è¿‘ä¸€æ¬¡å·²å¯¦ç¾äº¤æ˜“</div>';
      html += '<div class="last-trade">';
      html += `<div>Lot#${last.lotId || 'â€”'} è²·å…¥åƒ¹ï¼š$${last.buyPrice.toFixed(2)}</div>`;
      html += `<div>è³£å‡ºåƒ¹ï¼š$${last.sellPrice.toFixed(2)}</div>`;
      html += `<div>æç›Šï¼š<span class="val ${cls}" style="font-size:.82rem">${sign}$${last.pnl.toFixed(0)}</span></div>`;
      html += `<div>å ±é…¬ç‡ï¼š<span class="val ${cls}" style="font-size:.82rem">${sign}${last.returnPct.toFixed(2)}%</span></div>`;
      html += `<div>åŸå› ï¼š${last.reason}</div>`;
      html += '</div>';
    }

    html += `<div style="margin-top:10px;font-size:.75rem;color:#64748b;text-align:center">æœ€å¾Œæ›´æ–°ï¼š${lastUpdateTime} ï½œ ä¾†æºï¼š${lastSource}</div>`;
  }

  container.innerHTML = html;
  $('invOverlay').classList.add('show');
}

/* â”€â”€ Init â”€â”€ */
updateMarketBar();
setInterval(updateMarketBar, 30000);

// Load saved state from localStorage
(function initLoad() {
  const saved = loadState();
  if (!saved) { renderAll(); return; }

  state.stock = saved.stock;
  state.currentPrice = saved.currentPrice;
  state.lots = saved.lots || [];
  state.trades = saved.trades;
  nextLotId = saved.nextLotId || 1;

  lastSource = saved.source;
  lastUpdateTime = saved.sourceTime;
  $('sourceBar').textContent = `ä¾†æºï¼š${lastSource} ï½œ æ›´æ–°ï¼š${lastUpdateTime}`;

  POLL_MS = saved.pollSec * 1000;
  $('pollInput').value = saved.pollSec;

  MONITOR_START = saved.monitorStart;
  MONITOR_END = saved.monitorEnd;
  $('monitorStart').value = MONITOR_START;
  $('monitorEnd').value = MONITOR_END;

  stockInput.value = saved.stock;
  if ([...stockSelect.options].some(o => o.value === saved.stock)) stockSelect.value = saved.stock;

  // Restore trade log entries into logBox
  if (saved.trades.length > 0) {
    $('logBox').innerHTML = '';
    const recent = saved.trades.slice(-20);
    for (let i = recent.length - 1; i >= 0; i--) {
      const t = recent[i];
      const sign = t.pnl >= 0 ? '+' : '';
      const cls = t.pnl >= 0 ? 'log-entry-up' : 'log-entry-down';
      const div = document.createElement('div');
      div.className = 'entry ' + cls;
      div.textContent = `Lot#${t.lotId || 'â€”'} è³£å‡º @ $${t.sellPrice}ï¼ˆ${t.reason}ï¼‰å ±é…¬ ${sign}${t.returnPct.toFixed(2)}%  æç›Š ${sign}$${t.pnl.toFixed(0)}`;
      $('logBox').appendChild(div);
    }
  }

  renderAll();

  // Show notice if there's a meaningful saved position
  const active = activeLots();
  const hasTrades = saved.trades.length > 0;
  if (active.length > 0 || hasTrades) {
    const notice = $('loadNotice');
    if (active.length > 0) {
      const totalShares = active.reduce((s, l) => s + l.shares, 0);
      notice.textContent = `å·²è¼‰å…¥ä¸Šæ¬¡åº«å­˜ï¼ˆ${saved.stock}ï¼Œ${active.length} ç­†æŒå€‰ï¼Œå…± ${totalShares} è‚¡ï¼‰ï¼Œå¯æŒ‰ã€Œé–‹å§‹ç›£æ§ã€ç¹¼çºŒæˆ–ã€Œè³£å‡ºå…¨éƒ¨ã€å¹³å€‰`;
    } else {
      notice.textContent = `å·²è¼‰å…¥ä¸Šæ¬¡å­˜æª”ï¼ˆ${saved.trades.length} ç­†äº¤æ˜“è¨˜éŒ„ï¼‰ï¼Œå¯ç¹¼çºŒç›£æ§`;
    }
    notice.style.display = 'block';
  }
})();

</script>
</body>
</html>
