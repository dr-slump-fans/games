<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Plumber Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
#wrap {
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  width: 100%; height: 100%;
}
canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  background: #5c94fc;
}
#ui {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
  display: flex; align-items: center; justify-content: center;
}
#overlay {
  display: none;
  flex-direction: column; align-items: center; gap: 16px;
  pointer-events: auto;
  background: rgba(0,0,0,0.7);
  padding: 32px 48px; border-radius: 12px;
  color: #fff; font-family: monospace; text-align: center;
}
#overlay h1 { font-size: 28px; }
#overlay p { font-size: 18px; }
#overlay button {
  font-family: monospace; font-size: 20px;
  padding: 12px 32px; border: none; border-radius: 8px;
  background: #e74c3c; color: #fff; cursor: pointer;
}
#overlay button:hover { background: #c0392b; }
#hud {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
}
#hud-top {
  display: flex; justify-content: space-between; align-items: flex-start;
  padding: 10px 16px;
  font-family: monospace; font-size: 18px;
  color: #fff; text-shadow: 2px 2px 0 #000;
}
#hud-left { text-align: left; }
#hud-right { text-align: right; }
#hud-time { font-size: 22px; font-weight: bold; }
#hud-level { font-size: 16px; margin-top: 2px; }
#score-display { font-size: 22px; }
#hud-coin { font-size: 16px; color: #f4d03f; margin-top: 2px; }
#hud-life { font-size: 16px; color: #7fff7f; margin-top: 2px; }
#hud-level-bar {
  margin-top: 4px; width: 100px; height: 6px;
  background: rgba(255,255,255,0.25); border-radius: 3px;
  overflow: hidden;
}
#hud-level-fill {
  height: 100%; width: 0%; border-radius: 3px;
  transition: width 0.5s ease, background 0.5s ease;
}
/* ── Mobile 4-Button Layout ────────────────────────── */
#mobile-buttons {
  position: absolute; bottom: 0; left: 0; width: 100%; height: 110px;
  display: flex; justify-content: space-between; align-items: flex-end;
  padding: 0 8px 8px 8px;
  pointer-events: none;
  z-index: 10;
}
#mobile-left, #mobile-right {
  display: flex; gap: 6px;
  pointer-events: none;
}
.mobile-btn {
  pointer-events: auto;
  width: 72px; height: 72px;
  border: 3px solid rgba(255,255,255,0.5);
  border-radius: 14px;
  background: rgba(0,0,0,0.25);
  color: rgba(255,255,255,0.8);
  font-family: monospace; font-size: 16px; font-weight: bold;
  display: flex; align-items: center; justify-content: center;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  -webkit-user-select: none;
  touch-action: none;
}
.mobile-btn.active {
  background: rgba(255,255,255,0.25);
  border-color: rgba(255,255,255,0.85);
}
.mobile-btn.wide {
  width: 88px; height: 72px;
  font-size: 15px;
}
#hud-combo {
  position: absolute; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: monospace; font-size: 28px; font-weight: bold;
  color: #ff0; text-shadow: 2px 2px 0 #000, 0 0 12px rgba(255,200,0,0.7);
  pointer-events: none;
  display: none;
  z-index: 12;
  transition: opacity 0.3s ease;
}
#hud-combo-bar {
  position: absolute; top: 80px; right: 16px;
  font-family: monospace; font-size: 14px; font-weight: bold;
  color: #ff6; text-shadow: 1px 1px 0 #000;
  pointer-events: none;
  display: none;
  z-index: 11;
}
#hud-mission {
  position: absolute; top: 56px; left: 16px;
  font-family: monospace; font-size: 13px; font-weight: bold;
  color: #0ff; text-shadow: 1px 1px 0 #000;
  pointer-events: none;
  display: none;
  z-index: 11;
}
#hud-mission-complete {
  position: absolute; top: 40%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: monospace; font-size: 24px; font-weight: bold;
  color: #2ecc71; text-shadow: 2px 2px 0 #000, 0 0 10px rgba(46,204,113,0.6);
  pointer-events: none;
  display: none;
  z-index: 12;
}
/* ── Fun Pack v2.1: Settings Toggles ─────────────── */
#hud-settings {
  position: absolute; top: 6px; left: 50%;
  transform: translateX(-50%);
  display: flex; gap: 6px;
  z-index: 20;
}
#hud-settings .toggle-btn {
  font-family: monospace; font-size: 11px; font-weight: bold;
  padding: 2px 8px; border: 1px solid rgba(255,255,255,0.4);
  border-radius: 4px; background: rgba(0,0,0,0.45);
  color: #fff; cursor: pointer; user-select: none;
  -webkit-tap-highlight-color: transparent;
}
#hud-settings .toggle-btn.off {
  color: #888; border-color: rgba(255,255,255,0.15);
}
/* ── Fun Pack v2: Boss Wave HUD ───────────────────── */
#hud-boss-wave {
  position: absolute; top: 30%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: monospace; font-size: 32px; font-weight: bold;
  color: #e74c3c; text-shadow: 2px 2px 0 #000, 0 0 16px rgba(231,76,60,0.8);
  pointer-events: none;
  display: none;
  z-index: 13;
}
#hud-boss-clear {
  position: absolute; top: 35%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: monospace; font-size: 26px; font-weight: bold;
  color: #f39c12; text-shadow: 2px 2px 0 #000, 0 0 12px rgba(243,156,18,0.7);
  pointer-events: none;
  display: none;
  z-index: 13;
}
/* ── Theme Chunk System HUD ──────────────────────── */
#hud-theme {
  position: absolute; top: 56px; right: 16px;
  font-family: monospace; font-size: 12px; font-weight: bold;
  color: #adf; text-shadow: 1px 1px 0 #000;
  pointer-events: none;
  z-index: 11;
}
#hud-theme-announce {
  position: absolute; top: 22%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: monospace; font-size: 22px; font-weight: bold;
  color: #fff; text-shadow: 2px 2px 0 #000, 0 0 14px rgba(255,255,255,0.6);
  pointer-events: none;
  display: none;
  z-index: 12;
  transition: opacity 0.5s ease;
}
#hud-section-label {
  font-size: 11px; margin-top: 2px; color: #aaa;
  transition: color 0.4s ease, text-shadow 0.4s ease;
}
#hud-section-label.highlight {
  text-shadow: 0 0 8px currentColor, 0 0 16px currentColor;
}
#hud-section-announce {
  position: absolute; top: 28%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: monospace; font-size: 18px; font-weight: bold;
  color: #fff; text-shadow: 2px 2px 0 #000, 0 0 10px rgba(255,255,255,0.5);
  pointer-events: none;
  display: none;
  z-index: 12;
  transition: opacity 0.5s ease;
}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
</div>
<div id="hud">
  <div id="hud-top">
    <div id="hud-left">
      <div id="hud-time">00:00</div>
      <div id="hud-level">Lv.1 EASY</div>
      <div id="hud-level-bar"><div id="hud-level-fill"></div></div>
      <div id="hud-section-label">UNDERWORLD</div>
    </div>
    <div id="hud-right">
      <div id="score-display">SCORE: 0</div>
      <div id="hud-coin">COIN: 0</div>
      <div id="hud-life">LIFE: 3</div>
      <div id="hud-mushroom" style="font-size:14px;margin-top:4px;display:none;"></div>
    </div>
  </div>
</div>
<div id="mobile-buttons">
  <div id="mobile-left">
    <div class="mobile-btn" id="btn-left">&larr;</div>
    <div class="mobile-btn" id="btn-right">&rarr;</div>
  </div>
  <div id="mobile-right">
    <div class="mobile-btn wide" id="btn-jump">JUMP</div>
  </div>
</div>
<div id="hud-boost" style="display:none"></div>
<div id="hud-combo"></div>
<div id="hud-combo-bar"></div>
<div id="hud-mission"></div>
<div id="hud-mission-complete">MISSION COMPLETE!</div>
<div id="hud-boss-wave"></div>
<div id="hud-boss-clear"></div>
<div id="hud-theme"></div>
<div id="hud-theme-announce"></div>
<div id="hud-section-announce"></div>
<div id="hud-settings">
  <div class="toggle-btn" id="btn-sfx">SFX ON</div>
  <div class="toggle-btn" id="btn-vib">VIB ON</div>
</div>
<div id="ui">
  <div id="overlay">
    <h1 id="ol-title">Plumber Runner</h1>
    <p id="ol-msg">MOVE: Arrows/AD  |  JUMP: Space</p>
    <p id="ol-score"></p>
    <button id="ol-btn">START</button>
    <p id="ol-version" style="font-size:12px;color:#888;margin:0"></p>
  </div>
</div>

<script>
// ── Version ───────────────────────────────────────────
const GAME_VERSION = 'v0.5.2';

// ── Constants ──────────────────────────────────────────
const DESIGN_W = 800;
const DESIGN_H = 400;
const GROUND_H = 60;
const GRAVITY = 0.55;
const JUMP_INITIAL = -7.0;         // short-tap: small jump
const JUMP_HOLD_ACCEL = -0.55;     // long-press: stronger boost per frame
const JUMP_HOLD_MAX_T = 16;        // long-press: more frames of boost
const AIR_JUMP_INITIAL = JUMP_INITIAL * 0.6;   // air jump: 60% initial velocity (slightly stronger than half)
const AIR_JUMP_HOLD_MAX_T = Math.floor(JUMP_HOLD_MAX_T * 0.55); // air jump: 55% hold frames
const COYOTE_FRAMES = 6;              // ~100ms at 60fps jump forgiveness after leaving ground
const TALL_PIPE_THRESHOLD = 140;   // pipes >= this height trigger staircase logic
const SCROLL_SPEED_BASE = 0;          // no auto-scroll — camera follows player
const SCROLL_ACCEL = 0;              // disabled: scroll speed no longer increases
const SCREEN_HALF_X = DESIGN_W * 0.5; // camera trigger: player at 50% screen width
const PIPE_MIN_GAP = 240;
const PIPE_MAX_GAP = 360;
const PIPE_HEIGHTS_BOTTOM = [60, 90, 120, 150, 75, 105];
const PIPE_HEIGHTS_TOP = [60, 80, 100, 120, 140];
const PIPE_W = 48;
const LIP_W = 56;
const LIP_H = 16;
const CRUSH_THRESHOLD = 4; // pixels of squeeze to count as crushed
const RECENTER_TARGET_X = DESIGN_W * 0.20; // player start position (160px from left)

// ── Manual Movement (auto-acceleration) ─────────────
const PLAYER_MAX_SPEED = 4.5;        // max speed when holding direction (auto ramps up)
const PLAYER_ACCEL = 0.07;           // acceleration per frame toward max speed (smooth ramp ~1.1s)
const PLAYER_DECEL = 0.22;           // deceleration per frame when no input
const BRAKE_TO_STOP_TIME = 0.5;      // seconds to brake to zero on ground when reversing
const BRAKE_DECEL_MIN = 0.10;        // min decel per frame (prevents infinite brake at low speed)
const BRAKE_DECEL_MAX = 0.60;        // max decel per frame (cap at very high speed)
const AIR_BRAKE_DECEL = 0.30;        // weaker brake when reversing in air (no time constraint)
const CAMERA_LEAD = DESIGN_W * 0.40; // camera keeps player at 40% from left edge
// ── Coin Rush (Mario-style mini buff) ───────────────
const COIN_RUSH_WINDOW = 6.0;      // seconds to chain 3 coin pickups
const COIN_RUSH_TARGET = 3;        // coins needed to trigger rush
const COIN_RUSH_DURATION = 4.0;    // seconds of temporary speed boost
const COIN_RUSH_SPEED_MUL = 1.25;  // +25% move speed during rush

// ── Lip Corner Forgiveness ──────────────────────────
// When the player is beside a pipe and jumps upward, the lip overhang
// (LIP_W > PIPE_W) can clip the player's head even though the overlap is tiny.
// LIP_CORNER_FORGIVE defines the width of the "forgiveness zone" on each side
// of the lip: if the player's horizontal overlap with the lip is within this
// margin while moving upward, the collision nudges the player sideways instead
// of blocking the jump. This prevents the frustrating "bonk" on lip corners
// while still blocking passage through the pipe body.
const LIP_CORNER_FORGIVE = 14; // pixels of lip-edge forgiveness per side (increased from 8)

// ── Wall-Kick Nudge ────────────────────────────────────
// When the player is flush against a pipe wall and initiates a jump,
// give a one-time outward nudge so the lip overhang doesn't immediately
// block the ascent. Only fires once per jump, only on pipe body side contact.
const WALL_NUDGE_PX = 3; // pixels of outward push on jump-start near wall

// ── Head-Center Rule ───────────────────────────────────
// For pipe-lip top-bonk: only count as a ceiling hit if the player's
// head center region overlaps the lip. Corner brushes become side-deflections.
const HEAD_CENTER_RATIO = 0.45; // fraction of player width that counts as "center"

// ── Breakable Brick Constants ─────────────────────────
const BRICK_W = 32;
const BRICK_H = 24;
const BRICK_SCORE = 5;            // points per brick broken
const BRICK_TIME_BONUS = 5;       // seconds added to survival timer per brick broken
const BRICK_FRAGMENT_COUNT = 6;   // number of debris fragments
const BRICK_SPAWN_CHANCE = 0.30;  // chance to spawn brick with pipe group
const STANDALONE_BRICK_MIN_COUNT = 1;
const STANDALONE_BRICK_MAX_COUNT = 3;
// Minimum brick height above ground: brick top must be at least 2× player height from ground.
// This prevents bricks from appearing too close to ground level.
const BRICK_MIN_HEIGHT_ABOVE_GROUND = 36 * 2; // 72px (2× player.h)

// ── Question Block & Coin Constants ──────────────────
const QUESTION_BLOCK_CHANCE = 0.30;  // chance a brick becomes a question block (coin reward)
const COIN_SCORE = 10;               // points per coin collected from question block
const COIN_COMBO_WINDOW = 1.2;       // seconds — hits within this window count as combo
const COIN_COMBO_MAX = 8;            // max combo level (caps pitch scaling)
const COIN_BASE_FREQ = 988;          // B5 — base coin sound frequency
const BLOCK_BUMP_FRAMES = 8;         // total frames for bump animation
const BLOCK_BUMP_HEIGHT = 6;         // max upward pixel offset during bump

// ── Hidden Block Constants ──────────────────────────
const HIDDEN_BLOCK_SCORE = 10;        // points awarded when a hidden block is revealed
const HIDDEN_BLOCK_CHANCE = 0.20;     // chance a chunk spawns a hidden block (shortcut stepping stone)
const HIDDEN_HINT_RANGE = 60;         // horizontal proximity range for spark hint (px)
const HIDDEN_HINT_FREQ = 8;           // spawn a hint spark every N frames (low frequency)
const HIDDEN_REVEAL_BONUS = 5;        // extra bonus points on reveal ("SECRET!" reward)
const HIDDEN_SHORTCUT_CHANCE = 0.12;  // chance a chunk spawns a 2-block shortcut corridor
const HIDDEN_SHORTCUT_COIN = true;    // shortcut blocks award a bonus coin on reveal

// ── Special Brick & Mushroom Constants ───────────────
const SPECIAL_BRICK_CHANCE = 0.25;   // chance a stepping-stone brick becomes a special brick
const MUSHROOM_W = 20;
const MUSHROOM_H = 20;
const MUSHROOM_SPEED = 1.8;          // horizontal movement speed
const MUSHROOM_GRAVITY = 0.4;        // gravity for mushroom
const MUSHROOM_POP_VY = -3;          // initial upward velocity (pop out of brick) — restored to v1 feel
const MUSHROOM_SPAWN_GRACE = 30;     // frames of pickup immunity after spawn (~0.5s)
const MUSHROOM_PICKUP_INSET_X = 4;   // px inset on each side for strict mushroom pickup box
const MUSHROOM_PICKUP_INSET_Y = 4;   // px inset on top/bottom for strict mushroom pickup box
const PLAYER_PICKUP_INSET_X = 2;     // px inset on each side for strict player pickup box
const PLAYER_PICKUP_INSET_Y = 2;     // px inset on top/bottom for strict player pickup box
// (swept pickup and arming removed — contact-only pickup)
const DOUBLE_JUMP_DURATION = 25;     // seconds of double jump power after eating mushroom

// ── Turtle Enemy Constants ──────────────────────────
const TURTLE_W = 24;
const TURTLE_H = 28;
const TURTLE_WALK_SPEED = 1.0;       // horizontal walk speed (always leftward)
const TURTLE_GRAVITY = 0.45;         // gravity for turtle
const SHELL_W = 24;
const SHELL_H = 16;
const SHELL_MOVE_SPEED = 5.5;        // shell sliding speed
const TURTLE_STOMP_SCORE = 10;       // points for stomping a turtle
const TURTLE_SHELL_KILL_SCORE = 20;  // points for shell killing another turtle
const TURTLE_SHELL_STOMP_SCORE = 5;  // points for stomping an idle shell
const TURTLE_STOMP_BOUNCE_VY = -5.5; // bounce velocity when player stomps turtle
const TURTLE_SPAWN_CHANCE = 0.30;    // chance to spawn turtle per pipe spawn
const TURTLE_MIN_SPAWN_GAP = 400;    // min px between turtle spawns
const TURTLE_SHELL_IDLE_KICK_GRACE = 10; // frames after stomp before shell can be kicked
const TURTLE_DEAD_FRAMES = 30;       // frames for dead turtle to linger before removal
const TURTLE_TURN_COOLDOWN = 12;     // min frames between direction reversals (prevents jitter)
const SHELL_BOUNCE_COOLDOWN = 4;     // frames of bounce immunity after shell wall-bounce (prevents sticking)
const SHELL_COMBO_MAX = 5;           // max shell combo multiplier
const SHELL_COMBO_BASE = 20;         // base score for shell kill (doubles each combo hit)
const TURTLE_NEARBY_CAP = 2;         // max walk/idle turtles within TURTLE_MIN_SPAWN_GAP of a new spawn
const SPAWN_RHYTHM_CYCLE = 1200;     // px per full pressure+relief cycle
const SPAWN_RHYTHM_RELIEF = 0.4;     // fraction of cycle that is "relief" (no random spawns)

// ── Difficulty System ─────────────────────────────────
// 5 levels with smooth interpolation between them
// Each level defines target values; actual values lerp continuously
const DIFFICULTY_LEVELS = [
  { name: 'EASY',   time: 0,   speedMul: 1.0, gapMin: 280, gapMax: 380, pipeMaxH: 150, topMaxH: 140, pairChance: 0.35, brickReplace: 0.15 },
  { name: 'NORMAL', time: 30,  speedMul: 1.25, gapMin: 250, gapMax: 340, pipeMaxH: 170, topMaxH: 155, pairChance: 0.40, brickReplace: 0.18 },
  { name: 'HARD',   time: 75,  speedMul: 1.55, gapMin: 220, gapMax: 300, pipeMaxH: 195, topMaxH: 170, pairChance: 0.47, brickReplace: 0.22 },
  { name: 'EXPERT', time: 140, speedMul: 1.85, gapMin: 195, gapMax: 270, pipeMaxH: 220, topMaxH: 190, pairChance: 0.52, brickReplace: 0.25 },
  { name: 'INSANE', time: 240, speedMul: 2.15, gapMin: 175, gapMax: 245, pipeMaxH: 240, topMaxH: 200, pairChance: 0.55, brickReplace: 0.28 },
];

// ── Chunk-Based Level Generation ─────────────────────
// Player physics-derived reachability limits
// Full jump height ≈ 156px, short jump ≈ 45px
// Full jump horizontal range at max speed ≈ 258px
const CHUNK_PLAYER_MAX_JUMP_H = 150;    // conservative max jump height (px)
const CHUNK_PLAYER_MAX_JUMP_X = 240;    // conservative max horizontal jump range (px)
const CHUNK_PLAYER_SHORT_JUMP_H = 40;   // short tap jump height (px)
const CHUNK_MIN_WIDTH = 600;
const CHUNK_MAX_WIDTH = 900;
const CHUNK_MAX_CONSEC_DANGER = 2;      // max consecutive danger chunks before forced rest
const CHUNK_SAFE_INTERVAL = 5;          // every N chunks, guarantee a safe/reward chunk
const CHUNK_MAX_REROLLS = 5;            // max rerolls per chunk for reachability

// ── Theme Chunk System ──────────────────────────────
// Themes define visual style and generation biases for sequences of chunks.
// Each theme lasts 4-8 chunks, then transitions to the next.
const THEME_NAMES = ['PLAINS', 'CAVE', 'TOWER'];
const THEME_MIN_CHUNKS = 4;
const THEME_MAX_CHUNKS = 8;
const THEME_TRANSITION_CHUNKS = 1;  // first chunk of a new theme is a smooth transition
const THEME_ANNOUNCE_DURATION = 120; // frames to show theme transition announcement

// Theme-specific weight multipliers (applied on top of difficulty phase weights)
// Values > 1 increase that chunk type's weight, < 1 decrease it
const THEME_WEIGHT_MULTS = {
  PLAINS: { rest: 1.8, single_platform: 1.2, double_platform: 0.5, pipe_mix: 0.3, turtle_zone: 0.7, reward: 1.5 },
  CAVE:   { rest: 0.5, single_platform: 1.0, double_platform: 1.5, pipe_mix: 1.8, turtle_zone: 0.8, reward: 0.8 },
  TOWER:  { rest: 0.4, single_platform: 1.3, double_platform: 1.8, pipe_mix: 1.0, turtle_zone: 0.5, reward: 1.2 },
};

// Theme-specific parameter offsets (added to difficulty phase params)
const THEME_PARAM_OFFSETS = {
  PLAINS: { maxPipeH: -20, maxTopH: -20, turtleChanceMult: 0.6, rewardChanceMult: 1.4 },
  CAVE:   { maxPipeH: 10,  maxTopH: 30,  turtleChanceMult: 1.0, rewardChanceMult: 0.8 },
  TOWER:  { maxPipeH: 20,  maxTopH: -10, turtleChanceMult: 0.5, rewardChanceMult: 1.1 },
};

// Theme-specific sky gradient colors for visual distinction
const THEME_SKY_COLORS = {
  PLAINS: { top: '#5c94fc', bottom: '#92c4f8' },  // default blue sky
  CAVE:   { top: '#2a2a3e', bottom: '#3d3d5c' },  // dark cave ceiling
  TOWER:  { top: '#4a3a6e', bottom: '#7a6a9e' },  // twilight purple
};

// Theme-specific ground colors
const THEME_GROUND_COLORS = {
  PLAINS: { fill: '#c0784a', line: '#a0603a', top: '#8B4513' },
  CAVE:   { fill: '#555566', line: '#444455', top: '#333344' },
  TOWER:  { fill: '#887766', line: '#776655', top: '#665544' },
};

// Theme-specific hill colors
const THEME_HILL_COLORS = {
  PLAINS: '#3a9d5c',
  CAVE:   '#2a3a4c',
  TOWER:  '#5a4a6c',
};

// Theme-specific announce text and color
const THEME_ANNOUNCE = {
  PLAINS: { text: 'OPEN PLAINS', color: '#5cfc5c' },
  CAVE:   { text: 'ENTER CAVE',  color: '#8888ff' },
  TOWER:  { text: 'HIGH TOWER',  color: '#ffaa44' },
};

// Theme state variables
let currentTheme = 'PLAINS';
let themeChunksRemaining = 0;
let nextTheme = null;
let themeTransitionActive = false; // true during the first chunk of a new theme
let themeAnnounceTimer = 0;        // countdown for theme announcement HUD
let themeAnnounceName = '';        // theme name being announced
let themeColorLerp = 0;            // 0-1 lerp factor for smooth color transitions
let themeColorFrom = 'PLAINS';     // previous theme for color interpolation
let themeColorTarget = 'PLAINS';   // target theme for color interpolation

// Pick a random theme different from the current one
function pickNextTheme() {
  const candidates = THEME_NAMES.filter(t => t !== currentTheme);
  return candidates[Math.floor(Math.random() * candidates.length)];
}

// Initialize theme state for a new game
function initThemeState() {
  currentTheme = 'PLAINS';
  themeChunksRemaining = THEME_MIN_CHUNKS + Math.floor(Math.random() * (THEME_MAX_CHUNKS - THEME_MIN_CHUNKS + 1));
  nextTheme = pickNextTheme();
  themeTransitionActive = false;
  themeAnnounceTimer = 0;
  themeAnnounceName = '';
  themeColorLerp = 1;
  themeColorFrom = 'PLAINS';
  themeColorTarget = 'PLAINS';
}

// Advance theme state after each chunk spawn
function advanceThemeState() {
  themeChunksRemaining--;
  themeTransitionActive = false;
  if (themeChunksRemaining <= 0) {
    // Switch to next theme
    themeColorFrom = currentTheme;
    currentTheme = nextTheme || pickNextTheme();
    themeColorTarget = currentTheme;
    themeColorLerp = 0;
    nextTheme = pickNextTheme();
    themeChunksRemaining = THEME_MIN_CHUNKS + Math.floor(Math.random() * (THEME_MAX_CHUNKS - THEME_MIN_CHUNKS + 1));
    themeTransitionActive = true; // first chunk is a transition
    themeAnnounceTimer = THEME_ANNOUNCE_DURATION;
    themeAnnounceName = currentTheme;
  }
}

// Apply theme weight multipliers to base weights
function applyThemeWeights(baseWeights, theme, isTransition) {
  const mults = THEME_WEIGHT_MULTS[theme];
  const result = {};
  for (const type of CHUNK_TYPES) {
    let w = baseWeights[type] * (mults[type] || 1);
    // During transition, blend toward neutral (reduce extreme biases)
    if (isTransition) {
      w = baseWeights[type] * 0.6 + w * 0.4;
    }
    result[type] = Math.max(0, w);
  }
  return result;
}

// Apply theme parameter offsets to difficulty params
function applyThemeParams(diffParams, theme, isTransition) {
  const offsets = THEME_PARAM_OFFSETS[theme];
  const result = { ...diffParams };
  const blend = isTransition ? 0.4 : 1.0;
  result.maxPipeH = Math.max(60, result.maxPipeH + Math.round(offsets.maxPipeH * blend));
  result.maxTopH = Math.max(40, result.maxTopH + Math.round(offsets.maxTopH * blend));
  // Clamp to reachability limits
  result.maxPipeH = Math.min(result.maxPipeH, CHUNK_PLAYER_MAX_JUMP_H);
  result.maxTopH = Math.min(result.maxTopH, DESIGN_H - GROUND_H - 42);
  return result;
}

// Lerp hex color helper
function lerpColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1, 3), 16), g1 = parseInt(c1.slice(3, 5), 16), b1 = parseInt(c1.slice(5, 7), 16);
  const r2 = parseInt(c2.slice(1, 3), 16), g2 = parseInt(c2.slice(3, 5), 16), b2 = parseInt(c2.slice(5, 7), 16);
  const r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
  return '#' + ((1 << 24) | (r << 16) | (g << 8) | b).toString(16).slice(1);
}

// Get current sky colors (with smooth transition)
function getThemeSkyColors() {
  const from = THEME_SKY_COLORS[themeColorFrom];
  const to = THEME_SKY_COLORS[themeColorTarget];
  const t = themeColorLerp;
  return {
    top: lerpColor(from.top, to.top, t),
    bottom: lerpColor(from.bottom, to.bottom, t),
  };
}

// Get current ground colors (with smooth transition)
function getThemeGroundColors() {
  const from = THEME_GROUND_COLORS[themeColorFrom];
  const to = THEME_GROUND_COLORS[themeColorTarget];
  const t = themeColorLerp;
  return {
    fill: lerpColor(from.fill, to.fill, t),
    line: lerpColor(from.line, to.line, t),
    top: lerpColor(from.top, to.top, t),
  };
}

// Get current hill color (with smooth transition)
function getThemeHillColor() {
  return lerpColor(THEME_HILL_COLORS[themeColorFrom], THEME_HILL_COLORS[themeColorTarget], themeColorLerp);
}

// ── Rhythm Section System ────────────────────────────────
// Rhythm sections overlay on top of themes, cycling between
// UNDERWORLD (dense low-pipe ground patterns) and TOWER (vertical platform layers).
const SECTION_NAMES = ['UNDERWORLD', 'TOWER'];
const SECTION_MIN_CHUNKS = 5;
const SECTION_MAX_CHUNKS = 9;
const SECTION_ANNOUNCE_DURATION = 120; // frames

// Section-specific weight multipliers (stacked on top of theme mults)
const SECTION_WEIGHT_MULTS = {
  UNDERWORLD: { rest: 0.6, single_platform: 1.4, double_platform: 0.5, pipe_mix: 1.6, turtle_zone: 1.3, reward: 1.0 },
  TOWER:      { rest: 0.5, single_platform: 0.8, double_platform: 1.8, pipe_mix: 0.7, turtle_zone: 0.4, reward: 1.3 },
};

// Section-specific parameter offsets (stacked on top of theme offsets)
const SECTION_PARAM_OFFSETS = {
  UNDERWORLD: { maxPipeH: -25, maxTopH: 15 },   // shorter pipes, more ceiling pipes → dense low corridors
  TOWER:      { maxPipeH: 30,  maxTopH: -15 },   // taller bottom pipes → vertical climbing
};

// Subtle sky tint per section (rgba overlaid on sky gradient for ambient cue)
const SECTION_SKY_TINT = {
  UNDERWORLD: 'rgba(180, 80, 40, 0.06)',   // warm amber undertone
  TOWER:      'rgba(60, 120, 200, 0.06)',   // cool blue-ish undertone
};

// Section announce text and color
const SECTION_ANNOUNCE = {
  UNDERWORLD: { text: 'ENTER UNDERWORLD', color: '#ff6644' },
  TOWER:      { text: 'CLIMB TOWER',      color: '#44ccff' },
};

// Section state variables
let currentSection = 'UNDERWORLD';
let sectionChunksRemaining = 0;
let sectionAnnounceTimer = 0;
let sectionAnnounceName = '';
let sectionTransitionActive = false; // true during the first chunk of a new section
let sectionTransitionCountdown = 0;  // ramp-in counter: 2→1→0 over first 2 chunks
let sectionFlashTimer = 0;          // visual flash overlay timer (frames)
let sectionFlashColor = '';          // color for the flash overlay
const SECTION_FLASH_DURATION = 45;   // ~0.75 seconds at 60fps

function pickNextSection() {
  return currentSection === 'UNDERWORLD' ? 'TOWER' : 'UNDERWORLD';
}

function initSectionState() {
  currentSection = 'UNDERWORLD';
  sectionChunksRemaining = SECTION_MIN_CHUNKS + Math.floor(Math.random() * (SECTION_MAX_CHUNKS - SECTION_MIN_CHUNKS + 1));
  sectionAnnounceTimer = SECTION_ANNOUNCE_DURATION;
  sectionAnnounceName = currentSection;
  sectionTransitionActive = false;
  sectionTransitionCountdown = 0;
  sectionFlashTimer = 0;
  sectionFlashColor = '';
}

function advanceSectionState() {
  sectionChunksRemaining--;
  // Ramp-in countdown: decrement each chunk, transition smoothing active while > 0
  if (sectionTransitionCountdown > 0) sectionTransitionCountdown--;
  sectionTransitionActive = sectionTransitionCountdown > 0;
  if (sectionChunksRemaining <= 0) {
    currentSection = pickNextSection();
    sectionChunksRemaining = SECTION_MIN_CHUNKS + Math.floor(Math.random() * (SECTION_MAX_CHUNKS - SECTION_MIN_CHUNKS + 1));
    sectionAnnounceTimer = SECTION_ANNOUNCE_DURATION;
    sectionAnnounceName = currentSection;
    sectionTransitionCountdown = 2; // smooth over first 2 chunks of new section
    sectionTransitionActive = true; // first chunk of new section is a transition
    // Trigger visual flash overlay
    const sann = SECTION_ANNOUNCE[currentSection];
    sectionFlashTimer = SECTION_FLASH_DURATION;
    sectionFlashColor = sann ? sann.color : '#ffffff';
  }
}

function applySectionWeights(weights, section, isTransition) {
  const mults = SECTION_WEIGHT_MULTS[section];
  const result = {};
  // Graduated blend: countdown 2→blend 0.4, countdown 1→blend 0.7, 0→full 1.0
  const blend = isTransition ? (sectionTransitionCountdown >= 2 ? 0.4 : 0.7) : 1.0;
  for (const type of CHUNK_TYPES) {
    let w = (weights[type] || 0) * (mults[type] || 1);
    // During transition ramp-in, blend toward neutral to avoid sudden difficulty spike
    if (blend < 1.0) {
      w = (weights[type] || 0) * (1 - blend) + w * blend;
    }
    result[type] = Math.max(0, w);
  }
  return result;
}

function applySectionParams(diffParams, section, isTransition) {
  const offsets = SECTION_PARAM_OFFSETS[section];
  // Graduated ramp-in: countdown 2→0.4, countdown 1→0.7, 0→full 1.0
  const blend = isTransition ? (sectionTransitionCountdown >= 2 ? 0.4 : 0.7) : 1.0;
  const result = { ...diffParams };
  result.maxPipeH = Math.max(60, result.maxPipeH + Math.round(offsets.maxPipeH * blend));
  result.maxTopH = Math.max(40, result.maxTopH + Math.round(offsets.maxTopH * blend));
  // Clamp to reachability limits
  result.maxPipeH = Math.min(result.maxPipeH, CHUNK_PLAYER_MAX_JUMP_H);
  result.maxTopH = Math.min(result.maxTopH, DESIGN_H - GROUND_H - 42);
  return result;
}

// Chunk types:
// 'rest'            – flat ground, no obstacles (breathing room)
// 'single_platform' – 1 bottom pipe as platform + optional bricks
// 'double_platform' – 2 bottom pipes at different heights (staircase)
// 'pipe_mix'        – pipe pair (bottom+top) or mixed obstacles
// 'turtle_zone'     – flat ground with turtle enemies + low obstacles
// 'reward'          – brick clusters with high special chance + easy spacing
const CHUNK_TYPES = ['rest', 'single_platform', 'double_platform', 'pipe_mix', 'turtle_zone', 'reward'];

// Difficulty phase definitions for chunk system
// Phase 0: Tutorial (0-60s) – mostly rest + single_platform
// Phase 1: Medium (60-180s) – add double_platform, pipe_mix, turtle_zone
// Phase 2: Hard (180s+) – all types, higher complexity, still reachable
const CHUNK_DIFFICULTY_PHASES = [
  { time: 0,   maxPipeH: 100, maxTopH: 80,  weights: { rest: 35, single_platform: 40, double_platform: 5, pipe_mix: 0,  turtle_zone: 15, reward: 5 } },
  { time: 60,  maxPipeH: 140, maxTopH: 120, weights: { rest: 15, single_platform: 25, double_platform: 15, pipe_mix: 15, turtle_zone: 15, reward: 15 } },
  { time: 180, maxPipeH: 200, maxTopH: 170, weights: { rest: 10, single_platform: 20, double_platform: 20, pipe_mix: 25, turtle_zone: 10, reward: 15 } },
  { time: 300, maxPipeH: 240, maxTopH: 200, weights: { rest: 8,  single_platform: 18, double_platform: 22, pipe_mix: 30, turtle_zone: 10, reward: 12 } },
];

// Chunk state tracking
let chunkIdCounter = 0;           // unique chunk ID
let chunkHistory = [];            // recent chunk records: { id, type, x, width, diffPhase, rerolls, reachable }
let consecutiveDangerChunks = 0;  // tracks consecutive danger chunks
let chunksSinceLastSafe = 0;      // tracks chunks since last safe/reward chunk
let nextChunkX = 0;               // world X where next chunk starts
let chunkDebugInfo = null;        // latest chunk debug info for overlay

// Get interpolated chunk difficulty parameters at current survival time
function getChunkDiffPhase() {
  const t = survivalTime;
  const phases = CHUNK_DIFFICULTY_PHASES;
  for (let i = phases.length - 1; i >= 0; i--) {
    if (t >= phases[i].time) {
      if (i === phases.length - 1) return { phase: i, ...phases[i] };
      const curr = phases[i];
      const next = phases[i + 1];
      const frac = (t - curr.time) / (next.time - curr.time);
      const s = frac * frac * (3 - 2 * frac); // smoothstep
      const result = { phase: i, time: curr.time };
      result.maxPipeH = Math.round(curr.maxPipeH + (next.maxPipeH - curr.maxPipeH) * s);
      result.maxTopH = Math.round(curr.maxTopH + (next.maxTopH - curr.maxTopH) * s);
      // Interpolate weights
      result.weights = {};
      for (const type of CHUNK_TYPES) {
        result.weights[type] = curr.weights[type] + (next.weights[type] - curr.weights[type]) * s;
      }
      return result;
    }
  }
  return { phase: 0, ...phases[0] };
}

// Weighted random selection from chunk types
function selectChunkType(weights) {
  const total = Object.values(weights).reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (const type of CHUNK_TYPES) {
    r -= weights[type];
    if (r <= 0) return type;
  }
  return 'rest'; // fallback
}

// Check if a chunk type is "dangerous" (can potentially kill the player)
function isChunkDangerous(type) {
  return type === 'double_platform' || type === 'pipe_mix';
}

// Check if a chunk type is "safe" (breathing room)
function isChunkSafe(type) {
  return type === 'rest' || type === 'reward';
}

// Validate reachability within a chunk's obstacles
// Returns true if all platforms are reachable from the entry point
function validateChunkReachability(chunkObstacles, chunkX, chunkWidth) {
  const groundY = DESIGN_H - GROUND_H;
  // Player enters chunk at ground level from the left
  // Check each obstacle is reachable
  let prevStandY = groundY; // player stands on ground
  let prevX = chunkX;

  for (const obs of chunkObstacles) {
    if (obs.type === 'pipe_bottom') {
      const pipeTopY = groundY - obs.h;
      // Player must be able to jump over or onto this pipe
      // Check: can player jump high enough from ground?
      if (obs.h > CHUNK_PLAYER_MAX_JUMP_H) return false;
      // Check: is the horizontal gap from previous obstacle reachable?
      const horizDist = obs.x - prevX;
      if (horizDist < 30) return false; // too close, no room to jump
      // If there's a gap to cross, check horizontal range
      prevStandY = Math.min(prevStandY, pipeTopY);
      prevX = obs.x + LIP_W;
    } else if (obs.type === 'pipe_top') {
      // Ceiling pipe — player must pass under
      const ceilingBottomY = obs.h; // from top of screen
      const clearance = groundY - ceilingBottomY;
      // Player height is 36px, need at least 40px clearance
      if (clearance < 42) return false;
    } else if (obs.type === 'pipe_pair') {
      // Bottom + top pipe — check the gap is passable
      const bottomTopY = groundY - obs.bottomH;
      const topBottomY = obs.topH;
      const gap = bottomTopY - topBottomY;
      // Gap must be at least player height + margin
      if (gap < player.h + 20) return false;
      // Bottom pipe must be jumpable
      if (obs.bottomH > CHUNK_PLAYER_MAX_JUMP_H) return false;
      prevStandY = Math.min(prevStandY, bottomTopY);
      prevX = obs.x + LIP_W;
    } else if (obs.type === 'brick') {
      // Brick must be reachable from ground
      const brickHeight = groundY - obs.y;
      if (brickHeight > CHUNK_PLAYER_MAX_JUMP_H) return false;
    }
  }

  // Check that the chunk exit is reachable (player can walk to the right edge)
  // This is generally true if individual obstacles are passable
  return true;
}

// Generate a single chunk of level content
// Returns: { pipes: [], bricks: [], turtleSpawns: [], width, type, obstacles (for validation) }
function generateChunk(chunkX, type, diffParams) {
  const groundY = DESIGN_H - GROUND_H;
  const width = CHUNK_MIN_WIDTH + Math.random() * (CHUNK_MAX_WIDTH - CHUNK_MIN_WIDTH);
  const result = { pipes: [], bricks: [], turtleSpawns: [], width, type, obstacles: [] };
  const maxPipeH = diffParams.maxPipeH;
  const maxTopH = diffParams.maxTopH;

  // Helper: random pipe height within limits
  const randBottomH = (maxH) => {
    const pool = PIPE_HEIGHTS_BOTTOM.filter(h => h <= maxH);
    if (maxH >= 170) pool.push(170);
    if (maxH >= 195) pool.push(195);
    if (maxH >= 220) pool.push(220);
    return pool[Math.floor(Math.random() * pool.length)] || 60;
  };
  const randTopH = (maxH) => {
    const pool = PIPE_HEIGHTS_TOP.filter(h => h <= maxH);
    if (maxH >= 155) pool.push(155);
    if (maxH >= 170) pool.push(170);
    return pool[Math.floor(Math.random() * pool.length)] || 60;
  };

  switch (type) {
    case 'rest': {
      // Flat ground with maybe 1 very low pipe for visual variety
      if (Math.random() < 0.3) {
        const x = chunkX + 200 + Math.random() * (width - 400);
        const h = 40 + Math.floor(Math.random() * 30); // very low: 40-70px
        result.pipes.push({ x, h, fromTop: false, scored: false });
        result.obstacles.push({ type: 'pipe_bottom', x, h });
      }
      // Maybe a reward brick
      if (Math.random() < 0.4) {
        const bx = chunkX + 150 + Math.random() * (width - 300);
        const by = groundY - (BRICK_MIN_HEIGHT_ABOVE_GROUND + Math.random() * 20);
        result.bricks.push(makeBrick(bx, by, 0.4));
        result.obstacles.push({ type: 'brick', x: bx, y: by });
      }
      break;
    }

    case 'single_platform': {
      // 1 bottom pipe as platform + optional stepping bricks
      const pipeX = chunkX + 150 + Math.random() * (width - 350);
      const pipeH = randBottomH(Math.min(maxPipeH, CHUNK_PLAYER_MAX_JUMP_H));
      result.pipes.push({ x: pipeX, h: pipeH, fromTop: false, scored: false });
      result.obstacles.push({ type: 'pipe_bottom', x: pipeX, h: pipeH });

      // Stepping brick if pipe is tall
      if (pipeH >= 100) {
        const bx = pipeX - 60 - Math.random() * 60;
        const stepH = BRICK_MIN_HEIGHT_ABOVE_GROUND + Math.random() * 15;
        const by = groundY - stepH;
        result.bricks.push(makeBrick(bx, by, SPECIAL_BRICK_CHANCE));
        result.obstacles.push({ type: 'brick', x: bx, y: by });
      }

      // Optional second brick at different position
      if (Math.random() < 0.35) {
        const bx2 = pipeX + LIP_W + 30 + Math.random() * 80;
        const stepH2 = BRICK_MIN_HEIGHT_ABOVE_GROUND + Math.random() * 30;
        const by2 = groundY - stepH2;
        if (bx2 < chunkX + width - 50) {
          result.bricks.push(makeBrick(bx2, by2, SPECIAL_BRICK_CHANCE));
          result.obstacles.push({ type: 'brick', x: bx2, y: by2 });
        }
      }

      // Hidden block shortcut: placed higher up near pipe top as a secret stepping stone
      if (pipeH >= 100 && Math.random() < HIDDEN_BLOCK_CHANCE) {
        const hbx = pipeX - 40 - Math.random() * 50;
        // Place at 70-90% of pipe height — reachable with a full jump, acts as shortcut to pipe top
        const hbH = pipeH * (0.70 + Math.random() * 0.20);
        const hby = groundY - hbH;
        if (hby > 30 && hbx > chunkX + 30) {
          result.bricks.push(makeHiddenBrick(hbx, hby));
        }
      }
      // Hidden shortcut corridor: 2 consecutive hidden blocks forming a short shortcut path
      // over the pipe — rarer than single hidden blocks, awards bonus coins
      else if (pipeH >= 130 && Math.random() < HIDDEN_SHORTCUT_CHANCE) {
        const hb1x = pipeX - 50 - Math.random() * 30;
        const hb1H = pipeH * 0.55;    // first block: mid-height stepping stone
        const hb1y = groundY - hb1H;
        const hb2x = hb1x - BRICK_W - 8; // second block: slightly left, higher
        const hb2H = pipeH * 0.80;    // close to pipe top — shortcut landing
        const hb2y = groundY - hb2H;
        if (hb2y > 30 && hb2x > chunkX + 30) {
          result.bricks.push(makeHiddenBrick(hb1x, hb1y, true));
          result.bricks.push(makeHiddenBrick(hb2x, hb2y, true));
        }
      }
      break;
    }

    case 'double_platform': {
      // 2 pipes at staggered heights — staircase platforming
      const gap = 120 + Math.random() * 100; // horizontal gap between pipes
      const pipe1X = chunkX + 100 + Math.random() * 100;
      const pipe2X = pipe1X + gap;
      // First pipe: lower
      const h1 = randBottomH(Math.min(maxPipeH, 120));
      // Second pipe: higher but reachable from first pipe top
      const maxH2 = Math.min(maxPipeH, h1 + CHUNK_PLAYER_MAX_JUMP_H - 20);
      const h2 = Math.max(h1 + 20, randBottomH(maxH2));

      result.pipes.push({ x: pipe1X, h: h1, fromTop: false, scored: false });
      result.pipes.push({ x: pipe2X, h: h2, fromTop: false, scored: false });
      result.obstacles.push({ type: 'pipe_bottom', x: pipe1X, h: h1 });
      result.obstacles.push({ type: 'pipe_bottom', x: pipe2X, h: h2 });

      // Optional brick between pipes for extra platforming
      if (Math.random() < 0.4 && gap > 160) {
        const midX = (pipe1X + pipe2X) / 2 - BRICK_W / 2;
        const midH = (h1 + h2) / 2;
        const by = groundY - midH;
        result.bricks.push(makeBrick(midX, by, SPECIAL_BRICK_CHANCE));
        result.obstacles.push({ type: 'brick', x: midX, y: by });
      }

      // Hidden shortcut corridor between pipes: 2 hidden blocks as secret bridge
      if (h2 >= 120 && gap >= 150 && Math.random() < HIDDEN_SHORTCUT_CHANCE) {
        const hb1x = pipe1X + LIP_W + 15;
        const hb1y = groundY - h1 - 30;  // just above first pipe top
        const hb2x = pipe2X - BRICK_W - 10;
        const hb2y = groundY - h2 + 5;   // near second pipe top — serves as bridge
        if (hb1y > 30 && hb2y > 30) {
          result.bricks.push(makeHiddenBrick(hb1x, hb1y, true));
          result.bricks.push(makeHiddenBrick(hb2x, hb2y, true));
        }
      }

      // Make sure pipe2 is still within chunk bounds
      if (pipe2X + LIP_W > chunkX + width) {
        result.width = pipe2X + LIP_W + 60 - chunkX;
      }
      break;
    }

    case 'pipe_mix': {
      // Mixed obstacles: bottom pipe + optional top pipe (pair), bricks
      const pipeX = chunkX + 150 + Math.random() * (width - 400);
      const bottomH = randBottomH(Math.min(maxPipeH, CHUNK_PLAYER_MAX_JUMP_H));

      result.pipes.push({ x: pipeX, h: bottomH, fromTop: false, scored: false });
      result.obstacles.push({ type: 'pipe_bottom', x: pipeX, h: bottomH });

      // Stepping bricks for taller pipes
      if (bottomH >= TALL_PIPE_THRESHOLD) {
        const bx = pipeX - 50 - Math.random() * 60;
        const stepH = BRICK_MIN_HEIGHT_ABOVE_GROUND + Math.random() * 15;
        result.bricks.push(makeBrick(bx, groundY - stepH, SPECIAL_BRICK_CHANCE));
        result.obstacles.push({ type: 'brick', x: bx, y: groundY - stepH });
      }

      // Add ceiling pipe? (50% chance if difficulty allows)
      if (Math.random() < 0.5 && maxTopH >= 60) {
        // Place ceiling pipe at a different X to avoid instant death trap
        const topX = pipeX + (Math.random() < 0.5 ? -(120 + Math.random() * 100) : (120 + Math.random() * 100));
        const topH = randTopH(maxTopH);
        // Ensure clearance: ceiling bottom must be above ground with enough gap
        const ceilingBottomY = topH;
        const clearance = groundY - ceilingBottomY;
        if (clearance >= player.h + 25 && topX > chunkX + 50 && topX < chunkX + width - 50) {
          result.pipes.push({ x: topX, h: topH, fromTop: true, scored: false });
          result.obstacles.push({ type: 'pipe_top', x: topX, h: topH });
        }
      }

      // Possible second bottom pipe farther in the chunk
      if (Math.random() < 0.4 && width > 650) {
        const pipe2X = pipeX + 200 + Math.random() * 150;
        if (pipe2X + LIP_W < chunkX + width - 60) {
          const h2 = randBottomH(Math.min(maxPipeH, CHUNK_PLAYER_MAX_JUMP_H));
          result.pipes.push({ x: pipe2X, h: h2, fromTop: false, scored: false });
          result.obstacles.push({ type: 'pipe_bottom', x: pipe2X, h: h2 });
        }
      }

      // Hidden block shortcut: secret stepping stone for pipe_mix with tall pipes
      if (bottomH >= TALL_PIPE_THRESHOLD && Math.random() < HIDDEN_BLOCK_CHANCE) {
        const hbx = pipeX + LIP_W + 20 + Math.random() * 60;
        // Place at 60-80% of pipe height — hidden stepping stone past the pipe
        const hbH = bottomH * (0.60 + Math.random() * 0.20);
        const hby = groundY - hbH;
        if (hby > 30 && hbx < chunkX + width - 50) {
          result.bricks.push(makeHiddenBrick(hbx, hby));
        }
      }
      // Hidden shortcut corridor for pipe_mix: 2-block path over the tall pipe
      else if (bottomH >= 160 && Math.random() < HIDDEN_SHORTCUT_CHANCE) {
        const hb1x = pipeX + LIP_W + 15;
        const hb1H = bottomH * 0.50;  // first block: mid-height past the pipe
        const hb1y = groundY - hb1H;
        const hb2x = hb1x + BRICK_W + 10; // second block: farther right, higher
        const hb2H = bottomH * 0.78;  // near pipe top for landing
        const hb2y = groundY - hb2H;
        if (hb2y > 30 && hb2x < chunkX + width - 50) {
          result.bricks.push(makeHiddenBrick(hb1x, hb1y, true));
          result.bricks.push(makeHiddenBrick(hb2x, hb2y, true));
        }
      }
      break;
    }

    case 'turtle_zone': {
      // Flat/low terrain with turtle enemies — enough ground space for turtle interaction
      // Maybe 1 low pipe for variety
      if (Math.random() < 0.5) {
        const pipeX = chunkX + 250 + Math.random() * (width - 400);
        const pipeH = 40 + Math.floor(Math.random() * 40); // very low: 40-80px
        result.pipes.push({ x: pipeX, h: pipeH, fromTop: false, scored: false });
        result.obstacles.push({ type: 'pipe_bottom', x: pipeX, h: pipeH });
      }
      // Spawn 1-2 turtles with adequate spacing
      const turtleCount = 1 + Math.floor(Math.random() * 2);
      const spacing = width / (turtleCount + 1);
      for (let i = 0; i < turtleCount; i++) {
        const tx = chunkX + spacing * (i + 1) + (Math.random() - 0.5) * 60;
        // Validate turtle position: must have at least 80px clear ground on each side
        let turtleOK = true;
        for (const p of result.pipes) {
          const pr = getPipeRects(p);
          if (rectsOverlap(tx, groundY - TURTLE_H, TURTLE_W, TURTLE_H,
            pr.lipRect.x, pr.lipRect.y, pr.lipRect.w, pr.lipRect.h) ||
            rectsOverlap(tx, groundY - TURTLE_H, TURTLE_W, TURTLE_H,
            pr.bodyRect.x, pr.bodyRect.y, pr.bodyRect.w, pr.bodyRect.h)) {
            turtleOK = false;
          }
          // Also check turtle has room to walk (not wedged against pipe)
          if (Math.abs(tx - pr.lipRect.x) < 60 || Math.abs(tx - (pr.lipRect.x + pr.lipRect.w)) < 60) {
            // Close to pipe — check more carefully
            const pipeLeft = pr.bodyRect.x;
            const pipeRight = pr.bodyRect.x + pr.bodyRect.w;
            if (tx + TURTLE_W > pipeLeft - 40 && tx < pipeRight + 40) {
              // Too close, but may still be OK if on the open side
              if (tx >= pipeLeft && tx + TURTLE_W <= pipeRight) turtleOK = false; // inside pipe
            }
          }
        }
        if (turtleOK && tx > chunkX + 60 && tx < chunkX + width - 60) {
          result.turtleSpawns.push(tx);
        }
      }
      // Maybe a brick for scoring
      if (Math.random() < 0.4) {
        const bx = chunkX + 100 + Math.random() * (width - 200);
        const by = groundY - (BRICK_MIN_HEIGHT_ABOVE_GROUND + Math.random() * 20);
        result.bricks.push(makeBrick(bx, by, SPECIAL_BRICK_CHANCE));
      }
      break;
    }

    case 'reward': {
      // Brick cluster with high special chance — easy spacing, lots of pickups
      const brickCount = 2 + Math.floor(Math.random() * 3); // 2-4 bricks
      const startX = chunkX + 100 + Math.random() * 100;
      const spread = (width - 300) / brickCount;
      for (let i = 0; i < brickCount; i++) {
        const bx = startX + i * spread + Math.random() * 40;
        // Heights in reachable tiers
        const tierIdx = i % 3;
        const tiers = [
          { minH: BRICK_MIN_HEIGHT_ABOVE_GROUND, maxH: 95 },
          { minH: 100, maxH: 130 },
          { minH: BRICK_MIN_HEIGHT_ABOVE_GROUND, maxH: 110 },
        ];
        const tier = tiers[tierIdx];
        const heightAboveGround = tier.minH + Math.random() * (tier.maxH - tier.minH);
        const by = groundY - heightAboveGround;

        if (bx < chunkX + width - 50) {
          // Higher special chance in reward chunks
          result.bricks.push(makeBrick(bx, by, 0.45));
          result.obstacles.push({ type: 'brick', x: bx, y: by });
        }
      }
      // Optional low pipe as visual anchor
      if (Math.random() < 0.3) {
        const px = chunkX + width / 2 + Math.random() * 100;
        const ph = 50 + Math.floor(Math.random() * 30);
        result.pipes.push({ x: px, h: ph, fromTop: false, scored: false });
        result.obstacles.push({ type: 'pipe_bottom', x: px, h: ph });
      }
      break;
    }
  }

  return result;
}

// Spawn a complete chunk into the game world
function spawnChunk() {
  const diffParams = getChunkDiffPhase();
  // Apply theme parameter offsets (pipe heights etc.)
  const themedParams = applyThemeParams(diffParams, currentTheme, themeTransitionActive);
  // Apply rhythm section parameter offsets on top of theme params
  const sectionedParams = applySectionParams(themedParams, currentSection, sectionTransitionActive);
  let weights = { ...diffParams.weights };

  // Apply theme weight multipliers
  weights = applyThemeWeights(weights, currentTheme, themeTransitionActive);
  // Apply rhythm section weight multipliers on top
  weights = applySectionWeights(weights, currentSection, sectionTransitionActive);

  // Force rest chunk after too many consecutive danger chunks
  if (consecutiveDangerChunks >= CHUNK_MAX_CONSEC_DANGER) {
    weights = { rest: 70, single_platform: 15, double_platform: 0, pipe_mix: 0, turtle_zone: 10, reward: 5 };
  }

  // Force safe/reward chunk periodically
  if (chunksSinceLastSafe >= CHUNK_SAFE_INTERVAL) {
    weights = { rest: 30, single_platform: 10, double_platform: 0, pipe_mix: 0, turtle_zone: 10, reward: 50 };
  }

  // During theme transition, bias toward safe chunk types
  if (themeTransitionActive) {
    weights.rest = Math.max(weights.rest, 25);
    weights.pipe_mix *= 0.5;
    weights.double_platform *= 0.5;
  }

  // During section transition ramp-in, bias toward safer chunks (stronger for chunk 1)
  if (sectionTransitionActive) {
    const safetyMult = sectionTransitionCountdown >= 2 ? 1.0 : 0.5;
    weights.rest = Math.max(weights.rest, 20 * safetyMult + 10);
    weights.pipe_mix *= (1 - 0.4 * safetyMult);
    weights.turtle_zone *= (1 - 0.5 * safetyMult);
  }

  let type = selectChunkType(weights);
  let chunk = null;
  let rerolls = 0;

  // Generate and validate, reroll if unreachable
  for (let attempt = 0; attempt <= CHUNK_MAX_REROLLS; attempt++) {
    chunk = generateChunk(nextChunkX, type, sectionedParams);
    if (validateChunkReachability(chunk.obstacles, nextChunkX, chunk.width)) {
      rerolls = attempt;
      break;
    }
    rerolls = attempt + 1;
    // On reroll, try a simpler type
    if (attempt >= 2) {
      type = Math.random() < 0.5 ? 'rest' : 'single_platform';
    }
    chunk = null;
  }

  // Final fallback: force rest chunk
  if (!chunk) {
    type = 'rest';
    chunk = generateChunk(nextChunkX, type, sectionedParams);
    rerolls = CHUNK_MAX_REROLLS + 1;
  }

  // Commit chunk to game world
  for (const p of chunk.pipes) {
    pipes.push(p);
  }
  for (const b of chunk.bricks) {
    // Hidden bricks skip overlap check (they're non-solid until revealed)
    if (b.hidden) { bricks.push(b); continue; }
    // Prevent overlap with existing bricks/pipes
    let overlaps = false;
    for (const existing of bricks) {
      if (existing.broken) continue;
      if (existing.hidden && !existing.revealed) continue;
      if (rectsOverlap(b.x, b.y, b.w, b.h, existing.x - 8, existing.y - 8, existing.w + 16, existing.h + 16)) {
        overlaps = true; break;
      }
    }
    if (!overlaps) bricks.push(b);
  }
  // Spawn turtles from chunk — apply theme turtle chance multiplier
  const turtleMult = THEME_PARAM_OFFSETS[currentTheme].turtleChanceMult;
  for (const tx of chunk.turtleSpawns) {
    if (tx - lastTurtleSpawnX >= TURTLE_MIN_SPAWN_GAP) {
      if (turtleMult >= 1 || Math.random() < turtleMult) {
        spawnTurtle(tx);
      }
    }
  }

  // We need at least one marker pipe for scoring/spawn tracking
  if (chunk.pipes.length === 0) {
    pipes.push({ x: nextChunkX + chunk.width / 2, h: 0, fromTop: false, scored: false });
  }

  // Update tracking state
  const chunkId = ++chunkIdCounter;
  const chunkRecord = {
    id: chunkId,
    type: type,
    x: nextChunkX,
    width: chunk.width,
    diffPhase: diffParams.phase,
    rerolls: rerolls,
    reachable: true,
    theme: currentTheme,
  };
  chunkHistory.push(chunkRecord);
  // Keep only recent history (last 20 chunks)
  if (chunkHistory.length > 20) chunkHistory.shift();

  // Update danger/safe counters
  if (isChunkDangerous(type)) {
    consecutiveDangerChunks++;
  } else {
    consecutiveDangerChunks = 0;
  }
  if (isChunkSafe(type)) {
    chunksSinceLastSafe = 0;
  } else {
    chunksSinceLastSafe++;
  }

  // Debug info
  chunkDebugInfo = chunkRecord;
  if (DEBUG_MODE) {
    console.log(`%c[Chunk] #${chunkId} type=${type} theme=${currentTheme} section=${currentSection} x=${Math.round(nextChunkX)} w=${Math.round(chunk.width)} phase=${diffParams.phase} rerolls=${rerolls} themeRemain=${themeChunksRemaining} sectionRemain=${sectionChunksRemaining}`, 'color: #42d4f4');
  }

  nextChunkX += chunk.width;

  // Advance theme state machine
  advanceThemeState();
  // Advance rhythm section state machine
  advanceSectionState();
}

// Initialize first chunks at game start
function spawnInitialChunks() {
  // Reset chunk state
  chunkIdCounter = 0;
  chunkHistory = [];
  consecutiveDangerChunks = 0;
  chunksSinceLastSafe = 0;
  nextChunkX = cameraX + DESIGN_W * 0.3; // start generating a bit ahead of player
  chunkDebugInfo = null;

  // Initialize theme state machine
  initThemeState();
  // Initialize rhythm section state machine
  initSectionState();

  // Generate first rest chunk (safe start)
  const firstChunk = generateChunk(nextChunkX, 'rest', getChunkDiffPhase());
  for (const p of firstChunk.pipes) pipes.push(p);
  for (const b of firstChunk.bricks) bricks.push(b);
  if (firstChunk.pipes.length === 0) {
    pipes.push({ x: nextChunkX + firstChunk.width / 2, h: 0, fromTop: false, scored: false });
  }
  chunkIdCounter++;
  chunkHistory.push({ id: 1, type: 'rest', x: nextChunkX, width: firstChunk.width, diffPhase: 0, rerolls: 0, reachable: true, theme: currentTheme });
  nextChunkX += firstChunk.width;
  advanceThemeState(); // count first chunk
  advanceSectionState(); // count first chunk for section too

  // Generate a couple more chunks ahead
  spawnChunk();
  spawnChunk();
}

// ── Swept AABB Settings ──────────────────────────────
const SWEEP_MAX_ITERATIONS = 4;   // max resolve iterations per frame
const SWEEP_EPSILON = 0.001;      // floating-point tolerance for contact

// ── Fun Pack v1: Combo System ────────────────────────
const COMBO_WINDOW = 2.5;          // seconds to chain next combo event
const COMBO_MAX = 5;               // max combo multiplier
const COMBO_POPUP_DURATION = 60;   // frames to show combo popup
const COMBO_PERFECT_LAND_VY = 4.0; // max |vy| on landing to count as "perfect"

// ── Fun Pack v1: Speed Wave ─────────────────────────
const SPEED_WAVE_PERIOD = 20;      // seconds per wave cycle
const SPEED_WAVE_AMP = 0.10;       // ±10% amplitude

// ── Fun Pack v1: Mission System ─────────────────────
const MISSION_REWARD_SCORE = 50;
const MISSION_COMPLETE_DISPLAY = 120; // frames to show MISSION COMPLETE

// ── Fun Pack v2: Boss Wave ──────────────────────────
const BOSS_WAVE_INTERVAL = 60;       // seconds between boss waves
const BOSS_WAVE_DURATION = 10;       // seconds each boss wave lasts
const BOSS_WAVE_REWARD_SCORE = 100;  // bonus score for surviving boss wave
const BOSS_WAVE_SPEED_WAVE_DAMP = 0.3; // dampen speed wave amplitude during boss (30% of normal)
const BOSS_WAVE_SPAWN_GAP = 120;     // pixels between boss wave obstacles (tighter than normal)

// ── Fun Pack v2.1: Boss Audio / Haptics ─────────────
let sfxEnabled = true;
let vibEnabled = true;
let audioCtx = null; // lazily created on first user gesture

function ensureAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

// ── SFX: Boss Wave Start (alarm/siren feel) ──────────
function sfxBossStart() {
  if (!sfxEnabled) return;
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  // Two-tone alarm: descending then ascending
  for (let i = 0; i < 3; i++) {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(880, now + i * 0.15);
    osc.frequency.linearRampToValueAtTime(440, now + i * 0.15 + 0.07);
    osc.frequency.linearRampToValueAtTime(880, now + i * 0.15 + 0.14);
    gain.gain.setValueAtTime(0.08, now + i * 0.15);
    gain.gain.linearRampToValueAtTime(0, now + i * 0.15 + 0.14);
    osc.connect(gain).connect(ctx.destination);
    osc.start(now + i * 0.15);
    osc.stop(now + i * 0.15 + 0.15);
  }
}

// ── SFX: Countdown Beep (last 3 seconds) ─────────────
function sfxCountdownBeep() {
  if (!sfxEnabled) return;
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(1000, now);
  gain.gain.setValueAtTime(0.10, now);
  gain.gain.linearRampToValueAtTime(0, now + 0.1);
  osc.connect(gain).connect(ctx.destination);
  osc.start(now);
  osc.stop(now + 0.12);
}

// ── SFX: Boss Clear (ascending triumphant) ───────────
function sfxBossClear() {
  if (!sfxEnabled) return;
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
  notes.forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, now + i * 0.09);
    gain.gain.setValueAtTime(0.10, now + i * 0.09);
    gain.gain.linearRampToValueAtTime(0, now + i * 0.09 + 0.15);
    osc.connect(gain).connect(ctx.destination);
    osc.start(now + i * 0.09);
    osc.stop(now + i * 0.09 + 0.16);
  });
}

// ── SFX: 1UP (classic ascending two-note jingle) ─────
function sfx1UP() {
  if (!sfxEnabled) return;
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  const notes = [660, 880]; // E5 → A5
  notes.forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, now + i * 0.12);
    gain.gain.setValueAtTime(0.12, now + i * 0.12);
    gain.gain.linearRampToValueAtTime(0, now + i * 0.12 + 0.18);
    osc.connect(gain).connect(ctx.destination);
    osc.start(now + i * 0.12);
    osc.stop(now + i * 0.12 + 0.20);
  });
}

// ── SFX: Coin Pop (short chirp, pitch rises with combo) ──
function sfxCoinPop(comboLevel) {
  if (!sfxEnabled) return;
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  // Pitch rises by ~100 cents per combo step (one semitone)
  const step = Math.min(comboLevel, COIN_COMBO_MAX);
  const freq = COIN_BASE_FREQ * Math.pow(2, step / 12);
  // Two quick notes for a classic coin "ding-ding"
  const notes = [freq, freq * 1.5]; // root + fifth above
  notes.forEach((f, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(f, now + i * 0.07);
    gain.gain.setValueAtTime(0.06, now + i * 0.07);
    gain.gain.linearRampToValueAtTime(0, now + i * 0.07 + 0.06);
    osc.connect(gain).connect(ctx.destination);
    osc.start(now + i * 0.07);
    osc.stop(now + i * 0.07 + 0.07);
  });
}

// ── SFX: Hidden Block Reveal (distinct rising chime) ──
function sfxHiddenReveal() {
  if (!sfxEnabled) return;
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  // Three quick rising notes — teal "secret found" chime
  const freqs = [660, 880, 1100];
  freqs.forEach((f, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(f, now + i * 0.06);
    gain.gain.setValueAtTime(0.07, now + i * 0.06);
    gain.gain.linearRampToValueAtTime(0, now + i * 0.06 + 0.08);
    osc.connect(gain).connect(ctx.destination);
    osc.start(now + i * 0.06);
    osc.stop(now + i * 0.06 + 0.09);
  });
}

// ── SFX: Shell Combo Kill (escalating pitch/timbre) ──
function sfxShellCombo(comboLevel) {
  if (!sfxEnabled) return;
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  const step = Math.min(comboLevel, SHELL_COMBO_MAX);
  // Base freq rises with combo: 330 → 370 → 415 → 466 → 523 Hz (approx semitones)
  const baseFreq = 330 * Math.pow(2, (step - 1) * 2 / 12);
  // Quick rising two-tone "thwack-ping"
  const osc1 = ctx.createOscillator();
  const gain1 = ctx.createGain();
  osc1.type = step >= 3 ? 'sawtooth' : 'square'; // grittier at high combo
  osc1.frequency.setValueAtTime(baseFreq * 0.8, now);
  osc1.frequency.linearRampToValueAtTime(baseFreq, now + 0.04);
  gain1.gain.setValueAtTime(0.07, now);
  gain1.gain.linearRampToValueAtTime(0, now + 0.08);
  osc1.connect(gain1).connect(ctx.destination);
  osc1.start(now);
  osc1.stop(now + 0.09);
  // Second note: higher "ping" delayed slightly
  const osc2 = ctx.createOscillator();
  const gain2 = ctx.createGain();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(baseFreq * 1.5, now + 0.05);
  gain2.gain.setValueAtTime(0.05 + step * 0.01, now + 0.05); // louder at higher combo
  gain2.gain.linearRampToValueAtTime(0, now + 0.14);
  osc2.connect(gain2).connect(ctx.destination);
  osc2.start(now + 0.05);
  osc2.stop(now + 0.15);
  // Third "sparkle" note for combo >= 3
  if (step >= 3) {
    const osc3 = ctx.createOscillator();
    const gain3 = ctx.createGain();
    osc3.type = 'sine';
    osc3.frequency.setValueAtTime(baseFreq * 2, now + 0.10);
    gain3.gain.setValueAtTime(0.04, now + 0.10);
    gain3.gain.linearRampToValueAtTime(0, now + 0.20);
    osc3.connect(gain3).connect(ctx.destination);
    osc3.start(now + 0.10);
    osc3.stop(now + 0.21);
  }
}

// ── Haptics: Vibration API wrapper ───────────────────
const vibSupported = typeof navigator !== 'undefined' && typeof navigator.vibrate === 'function';

function vibrate(pattern) {
  if (!vibEnabled || !vibSupported) return;
  try { navigator.vibrate(pattern); } catch (_) { /* ignore */ }
}

function vibBossStart() { vibrate([80, 40, 80, 40, 120]); }
function vibBossClear() { vibrate([40, 30, 40]); }

// Countdown beep last-second tracker (prevents duplicate beeps per second)
let bossCountdownLastSec = -1;

// ── Debug Mode ───────────────────────────────────────
const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === '1';

// ── Sprite Mode ─────────────────────────────────────
// Render mode: 'sprite' uses sprite.png + sprite.json, 'procedural' uses code-drawn character.
// Default: attempt sprite mode; fallback to procedural if loading fails.
let spriteMode = 'sprite'; // 'sprite' | 'procedural'
let spriteImg = null;       // Image object when loaded
let spriteData = null;      // Parsed sprite.json data
let spriteReady = false;    // true when both image + json loaded successfully

function loadSprite() {
  const basePath = 'assets/';

  // Load JSON first, then use it to determine image path
  fetch(basePath + 'sprite.json')
    .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
    .then(data => {
      spriteData = data;
      // Now load the image using the path from JSON
      const img = new Image();
      img.onload = () => {
        spriteImg = img;
        onSpriteReady();
      };
      img.onerror = () => {
        console.warn('[Sprite] Failed to load ' + data.meta.image + ', falling back to procedural.');
        spriteMode = 'procedural';
      };
      img.src = basePath + data.meta.image;
    })
    .catch(err => {
      console.warn('[Sprite] Failed to load sprite.json, falling back to procedural:', err.message);
      spriteMode = 'procedural';
    });
}

function onSpriteReady() {
  spriteReady = true;
  spriteMode = 'sprite';
  if (DEBUG_MODE) {
    console.log('%c[Sprite] Sprite mode active — ' + spriteData.meta.columns + ' frames loaded', 'color: #42d4f4');
  }
}

// Resolve the sprite frame index for the current animation state and player frame
function getSpriteFrame() {
  if (!spriteData || !spriteData.animations) return 0;
  const anim = spriteData.animations[player.animState];
  if (!anim) return 0;
  if (anim.frames.length === 1) return anim.frames[0];
  // For multi-frame animations (run), use player.frame to index
  return anim.frames[player.frame % anim.frames.length];
}

// Draw player using the sprite sheet
function drawPlayerSprite(px, py) {
  if (!spriteReady || !spriteImg || !spriteData) return;
  const frameIdx = getSpriteFrame();
  const fw = spriteData.meta.frameWidth;
  const fh = spriteData.meta.frameHeight;
  const cols = spriteData.meta.columns;
  const sx = (frameIdx % cols) * fw;
  const sy = Math.floor(frameIdx / cols) * fh;
  ctx.drawImage(spriteImg, sx, sy, fw, fh, Math.round(px), Math.round(py), fw, fh);
}

// ── Canvas Setup ───────────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = DESIGN_W;
canvas.height = DESIGN_H;

function resizeCanvas() {
  const ww = window.innerWidth;
  const wh = window.innerHeight;
  const scale = Math.min(ww / DESIGN_W, wh / DESIGN_H);
  canvas.style.width = (DESIGN_W * scale) + 'px';
  canvas.style.height = (DESIGN_H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ── UI refs ────────────────────────────────────────────
const overlay = document.getElementById('overlay');
const olTitle = document.getElementById('ol-title');
const olMsg = document.getElementById('ol-msg');
const olScore = document.getElementById('ol-score');
const olBtn = document.getElementById('ol-btn');
const olVersion = document.getElementById('ol-version');
const scoreDisplay = document.getElementById('score-display');
const hudCoin = document.getElementById('hud-coin');
const hudLife = document.getElementById('hud-life');
const hudTime = document.getElementById('hud-time');
const hudLevel = document.getElementById('hud-level');
const hudLevelFill = document.getElementById('hud-level-fill');
const hudMushroom = document.getElementById('hud-mushroom');
const hudBoost = document.getElementById('hud-boost');
const hudCombo = document.getElementById('hud-combo');
const hudComboBar = document.getElementById('hud-combo-bar');
const hudMission = document.getElementById('hud-mission');
const hudMissionComplete = document.getElementById('hud-mission-complete');
const hudBossWave = document.getElementById('hud-boss-wave');
const hudBossClear = document.getElementById('hud-boss-clear');
const hudTheme = document.getElementById('hud-theme');
const hudThemeAnnounce = document.getElementById('hud-theme-announce');
const hudSectionAnnounce = document.getElementById('hud-section-announce');
const hudSectionLabel = document.getElementById('hud-section-label');
const btnSfx = document.getElementById('btn-sfx');
const btnVib = document.getElementById('btn-vib');

// ── Fun Pack v2.1: Settings toggle handlers ───────────
btnSfx.addEventListener('click', (e) => {
  e.stopPropagation();
  sfxEnabled = !sfxEnabled;
  btnSfx.textContent = sfxEnabled ? 'SFX ON' : 'SFX OFF';
  btnSfx.classList.toggle('off', !sfxEnabled);
});
btnVib.addEventListener('click', (e) => {
  e.stopPropagation();
  vibEnabled = !vibEnabled;
  btnVib.textContent = vibEnabled ? 'VIB ON' : 'VIB OFF';
  btnVib.classList.toggle('off', !vibEnabled);
});

// ── Game State ─────────────────────────────────────────
let state = 'title'; // title | playing | dead
let score = 0;
let highScore = 0;
let frameCount = 0;
let scrollSpeed = 0;  // no auto-scroll; kept for API compat
let jumpPressed = false;
let jumpConsumed = false;  // true after jump initiated; must release to jump again
let jumpHoldFrames = 0;
let coyoteFrames = 0;      // jump forgiveness after leaving ground (Mario-like coyote time)
let wallNudgeUsed = false; // true after wall-kick nudge fires; reset on landing
let justJumped = false;    // true during the frame a jump was initiated; prevents swept movement from re-grounding
let moveLeftPressed = false;  // true when left key/button is held
let moveRightPressed = false; // true when right key/button is held
let playerVX = 0;             // horizontal velocity (positive = right)
let playerBraking = false;    // true when reverse-braking (for anim & debug)
let brakeTimer = 0;           // remaining ground-brake time (seconds); 0 = not braking
let cameraX = 0;              // world X of camera left edge

// ── Edge-Protection Debug Overlay ──────────────────────
// Stores short-lived messages like "EDGE-FORGIVE" / "WALL-NUDGE" for display
let edgeDebugMsgs = []; // { text, ttl (frames remaining) }
let depenFixCount = 0;  // cumulative depenetration fallback fixes (debug display)
let survivalTime = 0;       // seconds survived (includes bonus time)
let bonusTime = 0;          // accumulated bonus seconds from breaking bricks
let diffLevel = 0;          // current difficulty level index (0-4)
let diffProgress = 0;       // 0..1 progress within current level toward next

// ── Fun Pack v1: Combo State ─────────────────────────
let comboCount = 0;           // current combo level (0 = no combo)
let comboTimer = 0;           // seconds remaining in combo window
let comboPopupTimer = 0;      // frames remaining for combo popup display
let comboPopupText = '';      // text to show in popup
let coinRushWindowTimer = 0;  // seconds left to continue coin chain
let coinRushChain = 0;        // coins collected in current chain
let coinRushTimer = 0;        // seconds left for active rush buff

// ── Fun Pack v1: Speed Wave State ───────────────────
let speedWavePhase = 0;       // current wave phase in radians

// ── Fun Pack v1: Mission State ──────────────────────
let mission = null;           // { type, desc, target, progress, done }
let missionCompleteTimer = 0; // frames remaining for MISSION COMPLETE display
let missionPlatformLandCount = 0; // consecutive platform landings for mission type 2

// ── Fun Pack v2: Boss Wave State ────────────────────
let bossWaveActive = false;          // true during a boss wave
let bossWaveTimer = 0;               // seconds remaining in current boss wave
let bossWaveCount = 0;               // how many boss waves have occurred this run
let bossWaveMode = 'A';              // current boss wave mode: 'A' or 'B'
let bossWaveCleared = false;         // true when boss wave ends by surviving
let bossWaveClearTimer = 0;          // frames remaining for BOSS CLEAR popup
let bossWaveSpawnX = 0;              // tracks next boss obstacle spawn X position
let bossWaveStepCounter = 0;         // obstacle step counter within current boss wave (for Mode B pattern)
let bossWaveNextTrigger = BOSS_WAVE_INTERVAL; // survivalTime threshold for next boss wave

// ── Life / 1UP State ───────────────────────────────────
const INITIAL_LIVES = 3;
let lives = INITIAL_LIVES;

// ── Coin State ──────────────────────────────────────────
let coins = 0;                // total coins collected this run
let coinComboLevel = 0;       // current coin combo streak (resets after COIN_COMBO_WINDOW)
let coinComboTimer = 0;       // seconds remaining in combo window
let coinPops = [];            // active coin pop animations: { x, y, vy, life }

// ── Mushroom & Double Jump State ─────────────────────
let mushrooms = [];           // active mushroom items: { x, y, vx, vy, onGround }
let doubleJumpTimer = 0;      // remaining seconds of double jump ability (0 = inactive)
let airJumpsUsed = 0;         // number of air jumps used this airborne session
let isAirJump = false;        // true when current jump is an air jump (half-height)
const MAX_AIR_JUMPS = 1;      // maximum air jumps allowed when mushroom is active

// ── Turtle Enemy State ──────────────────────────────────
// Each turtle: { x, y, vx, vy, onGround, state, direction, animFrame, deadTimer, kickGrace, turnCooldown, shellCombo }
// States: 'walk', 'shell_idle', 'shell_move', 'shell_bounce_dead', 'dead'
let turtles = [];
let lastTurtleSpawnX = -9999;  // tracks X of last turtle spawn to enforce gap
let spawnRhythmBase = 0;       // cameraX snapshot at game start for rhythm cycle

// ── Flagpole / Level Clear ──────────────────────────────
const FLAGPOLE_DISTANCE = 5000;     // world X where flagpole spawns
const FLAGPOLE_W = 16;              // pole width
const FLAGPOLE_H = 200;             // pole height (from ground up)
const FLAGPOLE_FLAG_W = 40;         // flag rectangle width
const FLAGPOLE_FLAG_H = 30;         // flag rectangle height
const LEVEL_CLEAR_BONUS = 50;       // one-time score bonus when touching flagpole
const LEVEL_CLEAR_SLIDE_FRAMES = 75; // ~1.25s slide-down animation before overlay
let flagpoleX = 0;                  // world X of the flagpole
let levelCleared = false;           // true once player touches flagpole
let levelClearTimer = 0;            // frames since level was cleared
let levelClearPhase = 'none';       // 'none' | 'sliding' | 'done'

// ── Player ─────────────────────────────────────────────
const player = {
  x: RECENTER_TARGET_X, y: 0, w: 28, h: 36,
  vy: 0, onGround: true, frame: 0,
  animState: 'idle',  // idle | run | jump_up | fall | land | brake
  landTimer: 0,       // frames remaining in land animation
  wasOnGround: true,  // track previous frame for landing detection
};

// ── Pipes ──────────────────────────────────────────────
// Each pipe: { x, h, fromTop (bool), scored }
let pipes = [];

// ── Clouds (decorative) ────────────────────────────────
let clouds = [];
function initClouds() {
  clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * DESIGN_W,
      y: 20 + Math.random() * 100,
      w: 50 + Math.random() * 60,
      speed: 0.3 + Math.random() * 0.5,
    });
  }
}

// ── Hills (decorative bg) ──────────────────────────────
let hills = [];
function initHills() {
  hills = [];
  for (let i = 0; i < 4; i++) {
    hills.push({
      x: i * 250,
      w: 180 + Math.random() * 100,
      h: 40 + Math.random() * 40,
    });
  }
}

// ── Breakable Bricks ──────────────────────────────────
// Each brick: { x, y, w, h, broken }
let bricks = [];

// ── Brick Fragments (debris particles) ────────────────
// Each fragment: { x, y, vx, vy, size, color, life }
let fragments = [];

// ── Hidden Block Hint Sparks ──────────────────────────
// Tiny teal sparks near unrevealed hidden blocks when player is close
// Each spark: { x, y, vy, life, maxLife }
let hintSparks = [];
let hintSparkTimer = 0; // throttle spark spawning

// ── Score popups (floating +5 text) ───────────────────
// Each popup: { x, y, text, life }
let scorePopups = [];
let milestonePipeCount = 0;  // counts pipes for milestone bonus

// ── Brick Factory Helper ─────────────────────────────────
// Creates a brick object. If not special, has a chance to be a question block.
function makeBrick(x, y, specialChance) {
  const isSpecial = Math.random() < specialChance;
  const isQuestion = !isSpecial && Math.random() < QUESTION_BLOCK_CHANCE;
  return { x, y, w: BRICK_W, h: BRICK_H, broken: false, special: isSpecial, question: isQuestion, used: false };
}

// Creates a hidden block. Invisible & non-solid until revealed by head bump from below.
// Once revealed, becomes a permanent solid platform (like a used question block).
// shortcut=true marks this block as part of a shortcut corridor — awards a bonus coin on reveal.
function makeHiddenBrick(x, y, shortcut) {
  return { x, y, w: BRICK_W, h: BRICK_H, broken: false, special: false, question: false, used: false, hidden: true, revealed: false, shortcut: !!shortcut };
}

// ── Drawing helpers ────────────────────────────────────

function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), w, h);
}

// ── Animation State Machine ───────────────────────────
// States: idle, run, jump_up, fall, land, brake
const LAND_DURATION = 6; // frames for land squash animation

function updateAnimState() {
  const prev = player.animState;

  // Landing detection: was airborne, now on ground
  if (!player.wasOnGround && player.onGround && prev !== 'land') {
    player.animState = 'land';
    player.landTimer = LAND_DURATION;
    player.wasOnGround = player.onGround;
    return;
  }

  player.wasOnGround = player.onGround;

  // Land animation countdown
  if (player.animState === 'land') {
    player.landTimer--;
    if (player.landTimer <= 0) {
      player.animState = Math.abs(playerVX) > 0.3 ? 'run' : 'idle';
    }
    return;
  }

  // Airborne states
  if (!player.onGround) {
    if (player.vy < -0.5) {
      player.animState = 'jump_up';
    } else {
      player.animState = 'fall';
    }
    return;
  }

  // On ground and not landing
  if (playerBraking) {
    player.animState = 'brake';
  } else {
    player.animState = Math.abs(playerVX) > 0.3 ? 'run' : 'idle';
  }
}

// Draw the player character — original "Pippo" the plumber
// 28x36 px, original design: round-nosed plumber with red cap, blue overalls, mustache
// NOT derived from any Nintendo or copyrighted IP — original proportions & details
function drawPlayer(px, py, frame) {
  // Flip sprite when moving left
  const facingLeft = playerVX < -0.1;
  if (facingLeft) {
    ctx.save();
    ctx.translate(Math.round(px) + player.w / 2, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(Math.round(px) + player.w / 2), 0);
  }
  // Sprite mode: use sprite sheet if available
  if (spriteMode === 'sprite' && spriteReady) {
    drawPlayerSprite(px, py);
    if (facingLeft) ctx.restore();
    return;
  }
  // Procedural mode: code-drawn character below
  const x = Math.round(px);
  const y = Math.round(py);
  const st = player.animState;

  // ── Original color palette — "Pippo" the Plumber ──
  const CAP     = '#c62828';  // deep red cap
  const CAP_HI  = '#ef5350';  // cap highlight
  const CAP_SH  = '#8e0000';  // cap shadow/brim
  const BADGE   = '#fdd835';  // yellow hexagonal badge
  const SKIN    = '#ffccaa';  // warm light skin
  const SKIN_SH = '#d4956a';  // skin shadow
  const STACHE  = '#3e2723';  // dark brown mustache
  const EYES    = '#1a1a1a';  // near-black eyes
  const EYE_W   = '#ffffff';  // eye whites
  const NOSE    = '#e8a070';  // round nose, slightly darker skin
  const SHIRT   = '#c62828';  // red shirt (matches cap)
  const SHIRT_HI= '#ef5350';  // shirt highlight
  const OVERALL = '#1a3a6e';  // deep navy overalls
  const OVER_HI = '#2e5ea0';  // overalls highlight
  const OVER_SH = '#0d1f3c';  // overalls shadow
  const STRAP   = '#1a3a6e';  // overall strap
  const BUTTON  = '#fdd835';  // yellow buttons on straps
  const GLOVE   = '#eeeeee';  // off-white work gloves
  const GLOVE_SH= '#bdbdbd';  // glove shadow
  const BOOTS_C = '#4e342e';  // dark brown work boots
  const BOOTS_H = '#795548';  // boot highlight
  const MOUTH   = '#5d1414';  // mouth (dark)

  // ── IDLE: relaxed stance, subtle breathing bob ──
  if (st === 'idle') {
    const bob = Math.sin(frameCount * 0.06) * 1.5;
    const by = y + Math.round(bob);
    // Cap — rounded with brim and hexagonal badge
    drawPixelRect(x + 5, by - 2, 18, 3, CAP);     // cap crown
    drawPixelRect(x + 7, by - 4, 14, 3, CAP);     // cap top
    drawPixelRect(x + 9, by - 5, 8, 2, CAP_HI);   // cap highlight
    drawPixelRect(x + 3, by + 1, 22, 2, CAP_SH);  // brim
    drawPixelRect(x + 12, by - 3, 4, 2, BADGE);   // hex badge
    // Head
    drawPixelRect(x + 6, by + 3, 16, 11, SKIN);
    drawPixelRect(x + 6, by + 10, 3, 4, SKIN_SH);
    // Eyes
    drawPixelRect(x + 8, by + 5, 3, 3, EYE_W);
    drawPixelRect(x + 17, by + 5, 3, 3, EYE_W);
    drawPixelRect(x + 9, by + 6, 2, 2, EYES);
    drawPixelRect(x + 18, by + 6, 2, 2, EYES);
    // Nose — big round
    drawPixelRect(x + 12, by + 7, 5, 4, NOSE);
    drawPixelRect(x + 13, by + 6, 3, 1, NOSE);
    // Mustache
    drawPixelRect(x + 8, by + 10, 12, 2, STACHE);
    drawPixelRect(x + 7, by + 10, 2, 1, STACHE);
    drawPixelRect(x + 19, by + 10, 2, 1, STACHE);
    // Mouth
    drawPixelRect(x + 12, by + 12, 4, 1, MOUTH);
    // Shirt (visible at collar)
    drawPixelRect(x + 7, by + 14, 14, 3, SHIRT);
    drawPixelRect(x + 7, by + 14, 4, 2, SHIRT_HI);
    // Overalls
    drawPixelRect(x + 6, by + 16, 16, 8, OVERALL);
    drawPixelRect(x + 6, by + 16, 3, 6, OVER_HI);
    drawPixelRect(x + 19, by + 18, 3, 4, OVER_SH);
    // Straps
    drawPixelRect(x + 8, by + 14, 3, 3, STRAP);
    drawPixelRect(x + 17, by + 14, 3, 3, STRAP);
    drawPixelRect(x + 9, by + 14, 1, 1, BUTTON);
    drawPixelRect(x + 18, by + 14, 1, 1, BUTTON);
    // Arms at sides (shirt sleeves + gloves)
    drawPixelRect(x + 2, by + 15, 4, 5, SHIRT);
    drawPixelRect(x + 2, by + 20, 4, 3, GLOVE);
    drawPixelRect(x + 22, by + 15, 4, 5, SHIRT);
    drawPixelRect(x + 22, by + 20, 4, 3, GLOVE);
    // Legs
    drawPixelRect(x + 7, by + 24, 6, 8, OVERALL);
    drawPixelRect(x + 15, by + 24, 6, 8, OVERALL);
    drawPixelRect(x + 9, by + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 17, by + 26, 2, 2, OVER_HI);
    // Boots
    drawPixelRect(x + 5, by + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 15, by + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 6, by + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 16, by + 32, 3, 1, BOOTS_H);
    return;
  }

  // ── LAND: squash impact pose ──
  if (st === 'land') {
    // Cap — squished flat
    drawPixelRect(x + 3, y + 4, 22, 2, CAP);
    drawPixelRect(x + 5, y + 2, 16, 3, CAP);
    drawPixelRect(x + 7, y + 2, 8, 1, CAP_HI);
    drawPixelRect(x + 2, y + 6, 24, 2, CAP_SH);
    drawPixelRect(x + 12, y + 3, 4, 2, BADGE);
    // Head — squished wider
    drawPixelRect(x + 4, y + 8, 20, 8, SKIN);
    drawPixelRect(x + 4, y + 13, 3, 3, SKIN_SH);
    // Eyes
    drawPixelRect(x + 7, y + 9, 3, 3, EYE_W);
    drawPixelRect(x + 17, y + 9, 3, 3, EYE_W);
    drawPixelRect(x + 8, y + 10, 2, 2, EYES);
    drawPixelRect(x + 18, y + 10, 2, 2, EYES);
    // Nose
    drawPixelRect(x + 11, y + 11, 5, 3, NOSE);
    // Mustache
    drawPixelRect(x + 7, y + 13, 14, 2, STACHE);
    // Mouth — strained grimace
    drawPixelRect(x + 11, y + 15, 6, 1, MOUTH);
    // Shirt
    drawPixelRect(x + 3, y + 16, 22, 2, SHIRT);
    // Overalls — squashed wide
    drawPixelRect(x + 2, y + 18, 24, 5, OVERALL);
    drawPixelRect(x + 2, y + 18, 4, 3, OVER_HI);
    drawPixelRect(x + 22, y + 19, 4, 3, OVER_SH);
    // Straps
    drawPixelRect(x + 7, y + 16, 3, 3, STRAP);
    drawPixelRect(x + 18, y + 16, 3, 3, STRAP);
    drawPixelRect(x + 8, y + 16, 1, 1, BUTTON);
    drawPixelRect(x + 19, y + 16, 1, 1, BUTTON);
    // Arms — bracing wide
    drawPixelRect(x + 0, y + 17, 4, 4, SHIRT);
    drawPixelRect(x + 0, y + 21, 3, 2, GLOVE);
    drawPixelRect(x + 24, y + 17, 4, 4, SHIRT);
    drawPixelRect(x + 25, y + 21, 3, 2, GLOVE);
    // Legs — wide squat
    drawPixelRect(x + 2, y + 23, 8, 5, OVERALL);
    drawPixelRect(x + 18, y + 23, 8, 5, OVERALL);
    drawPixelRect(x + 4, y + 25, 2, 2, OVER_HI);
    drawPixelRect(x + 20, y + 25, 2, 2, OVER_HI);
    // Boots — wide stance
    drawPixelRect(x + 0, y + 28, 10, 4, BOOTS_C);
    drawPixelRect(x + 18, y + 28, 10, 4, BOOTS_C);
    drawPixelRect(x + 1, y + 28, 3, 1, BOOTS_H);
    drawPixelRect(x + 19, y + 28, 3, 1, BOOTS_H);
    // Dust puffs
    if (player.landTimer > 3) {
      ctx.fillStyle = 'rgba(180,160,130,0.6)';
      ctx.fillRect(x - 4, y + 30, 5, 3);
      ctx.fillRect(x + 27, y + 30, 5, 3);
      ctx.fillStyle = 'rgba(180,160,130,0.3)';
      ctx.fillRect(x - 6, y + 29, 3, 2);
      ctx.fillRect(x + 31, y + 29, 3, 2);
    }
    return;
  }

  // ── JUMP_UP: fist raised, legs tucked, determined look ──
  if (st === 'jump_up') {
    // Cap — tilted up slightly from wind
    drawPixelRect(x + 5, y - 3, 18, 3, CAP);
    drawPixelRect(x + 7, y - 5, 14, 3, CAP);
    drawPixelRect(x + 9, y - 6, 8, 2, CAP_HI);
    drawPixelRect(x + 3, y + 0, 22, 2, CAP_SH);
    drawPixelRect(x + 12, y - 4, 4, 2, BADGE);
    // Head
    drawPixelRect(x + 6, y + 2, 16, 11, SKIN);
    drawPixelRect(x + 6, y + 9, 3, 4, SKIN_SH);
    // Eyes — looking up, excited
    drawPixelRect(x + 8, y + 3, 3, 3, EYE_W);
    drawPixelRect(x + 17, y + 3, 3, 3, EYE_W);
    drawPixelRect(x + 9, y + 4, 2, 2, EYES);
    drawPixelRect(x + 18, y + 4, 2, 2, EYES);
    // Nose
    drawPixelRect(x + 12, y + 6, 5, 4, NOSE);
    drawPixelRect(x + 13, y + 5, 3, 1, NOSE);
    // Mustache
    drawPixelRect(x + 8, y + 9, 12, 2, STACHE);
    drawPixelRect(x + 7, y + 9, 2, 1, STACHE);
    drawPixelRect(x + 19, y + 9, 2, 1, STACHE);
    // Mouth — open determined
    drawPixelRect(x + 12, y + 11, 4, 2, MOUTH);
    // Shirt
    drawPixelRect(x + 7, y + 13, 14, 3, SHIRT);
    drawPixelRect(x + 7, y + 13, 4, 2, SHIRT_HI);
    // Overalls
    drawPixelRect(x + 6, y + 15, 16, 8, OVERALL);
    drawPixelRect(x + 6, y + 15, 3, 6, OVER_HI);
    drawPixelRect(x + 19, y + 17, 3, 4, OVER_SH);
    // Straps
    drawPixelRect(x + 8, y + 13, 3, 3, STRAP);
    drawPixelRect(x + 17, y + 13, 3, 3, STRAP);
    drawPixelRect(x + 9, y + 13, 1, 1, BUTTON);
    drawPixelRect(x + 18, y + 13, 1, 1, BUTTON);
    // Right arm — raised fist up!
    drawPixelRect(x + 22, y + 7, 4, 6, SHIRT);
    drawPixelRect(x + 23, y + 3, 4, 5, SHIRT);
    drawPixelRect(x + 23, y + 1, 4, 3, GLOVE);
    // Left arm — down behind
    drawPixelRect(x + 1, y + 15, 5, 5, SHIRT);
    drawPixelRect(x + 1, y + 20, 4, 2, GLOVE);
    // Legs — tucked up together
    drawPixelRect(x + 7, y + 23, 6, 5, OVERALL);
    drawPixelRect(x + 15, y + 23, 6, 5, OVERALL);
    // Boots — tucked
    drawPixelRect(x + 6, y + 28, 7, 4, BOOTS_C);
    drawPixelRect(x + 15, y + 28, 7, 4, BOOTS_C);
    drawPixelRect(x + 7, y + 28, 3, 1, BOOTS_H);
    drawPixelRect(x + 16, y + 28, 3, 1, BOOTS_H);
    return;
  }

  // ── FALL: arms out for balance, legs dangling, worried face ──
  if (st === 'fall') {
    // Cap — pushed back by wind
    drawPixelRect(x + 7, y + 0, 18, 3, CAP);
    drawPixelRect(x + 9, y - 2, 14, 3, CAP);
    drawPixelRect(x + 11, y - 3, 8, 2, CAP_HI);
    drawPixelRect(x + 5, y + 3, 20, 2, CAP_SH);
    drawPixelRect(x + 14, y - 1, 4, 2, BADGE);
    // Head
    drawPixelRect(x + 6, y + 5, 16, 11, SKIN);
    drawPixelRect(x + 6, y + 12, 3, 4, SKIN_SH);
    // Eyes — wide worried
    drawPixelRect(x + 8, y + 6, 4, 4, EYE_W);
    drawPixelRect(x + 16, y + 6, 4, 4, EYE_W);
    drawPixelRect(x + 9, y + 7, 2, 3, EYES);
    drawPixelRect(x + 17, y + 7, 2, 3, EYES);
    // Nose
    drawPixelRect(x + 12, y + 9, 5, 4, NOSE);
    // Mustache
    drawPixelRect(x + 8, y + 12, 12, 2, STACHE);
    // Mouth — worried O
    drawPixelRect(x + 12, y + 14, 4, 2, MOUTH);
    drawPixelRect(x + 13, y + 14, 2, 1, SKIN);
    // Shirt
    drawPixelRect(x + 7, y + 16, 14, 3, SHIRT);
    // Overalls
    drawPixelRect(x + 6, y + 18, 16, 7, OVERALL);
    drawPixelRect(x + 6, y + 18, 3, 5, OVER_HI);
    drawPixelRect(x + 19, y + 20, 3, 3, OVER_SH);
    // Straps
    drawPixelRect(x + 8, y + 16, 3, 3, STRAP);
    drawPixelRect(x + 17, y + 16, 3, 3, STRAP);
    drawPixelRect(x + 9, y + 16, 1, 1, BUTTON);
    drawPixelRect(x + 18, y + 16, 1, 1, BUTTON);
    // Arms — spread wide for balance
    drawPixelRect(x + 0, y + 16, 6, 4, SHIRT);
    drawPixelRect(x + 0, y + 14, 4, 3, SHIRT);
    drawPixelRect(x + 0, y + 13, 3, 2, GLOVE);
    drawPixelRect(x + 22, y + 17, 6, 4, SHIRT);
    drawPixelRect(x + 25, y + 15, 3, 3, SHIRT);
    drawPixelRect(x + 25, y + 14, 3, 2, GLOVE);
    // Legs — dangling apart
    drawPixelRect(x + 6, y + 25, 6, 7, OVERALL);
    drawPixelRect(x + 16, y + 25, 6, 7, OVERALL);
    drawPixelRect(x + 8, y + 27, 2, 2, OVER_HI);
    drawPixelRect(x + 18, y + 27, 2, 2, OVER_HI);
    // Boots — dangling
    drawPixelRect(x + 5, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 15, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 6, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 16, y + 32, 3, 1, BOOTS_H);
    return;
  }

  // ── BRAKE: skidding pose, leaning back, one foot forward, dust puffs ──
  if (st === 'brake') {
    // Cap — tilted back slightly
    drawPixelRect(x + 5, y - 2, 18, 3, CAP);
    drawPixelRect(x + 7, y - 4, 14, 3, CAP);
    drawPixelRect(x + 9, y - 5, 8, 2, CAP_HI);
    drawPixelRect(x + 3, y + 1, 22, 2, CAP_SH);
    drawPixelRect(x + 12, y - 3, 4, 2, BADGE);
    // Head — leaning back
    drawPixelRect(x + 6, y + 3, 16, 11, SKIN);
    drawPixelRect(x + 6, y + 10, 3, 4, SKIN_SH);
    // Eyes — wide, surprised
    drawPixelRect(x + 8, y + 4, 4, 4, EYE_W);
    drawPixelRect(x + 16, y + 4, 4, 4, EYE_W);
    drawPixelRect(x + 9, y + 5, 2, 3, EYES);
    drawPixelRect(x + 17, y + 5, 2, 3, EYES);
    // Nose
    drawPixelRect(x + 12, y + 7, 5, 4, NOSE);
    drawPixelRect(x + 13, y + 6, 3, 1, NOSE);
    // Mustache
    drawPixelRect(x + 8, y + 10, 12, 2, STACHE);
    // Mouth — gritting teeth
    drawPixelRect(x + 11, y + 12, 6, 2, MOUTH);
    drawPixelRect(x + 12, y + 12, 1, 1, '#ffffff');
    drawPixelRect(x + 15, y + 12, 1, 1, '#ffffff');
    // Shirt — leaning back
    drawPixelRect(x + 7, y + 14, 14, 3, SHIRT);
    // Overalls — wide stance, skidding
    drawPixelRect(x + 6, y + 16, 16, 8, OVERALL);
    drawPixelRect(x + 6, y + 16, 3, 6, OVER_HI);
    // Straps
    drawPixelRect(x + 8, y + 14, 3, 3, STRAP);
    drawPixelRect(x + 17, y + 14, 3, 3, STRAP);
    drawPixelRect(x + 9, y + 14, 1, 1, BUTTON);
    drawPixelRect(x + 18, y + 14, 1, 1, BUTTON);
    // Arms — bracing backward
    drawPixelRect(x + 22, y + 14, 5, 5, SHIRT);
    drawPixelRect(x + 24, y + 19, 4, 3, GLOVE);
    drawPixelRect(x + 1, y + 15, 5, 5, SHIRT);
    drawPixelRect(x + 0, y + 20, 4, 2, GLOVE);
    // Front leg — extended forward, skidding
    drawPixelRect(x + 2, y + 24, 9, 6, OVERALL);
    drawPixelRect(x + 4, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 0, y + 30, 11, 4, BOOTS_C);
    drawPixelRect(x + 1, y + 30, 3, 1, BOOTS_H);
    // Back leg — planted under body
    drawPixelRect(x + 16, y + 24, 6, 8, OVERALL);
    drawPixelRect(x + 18, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 16, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 17, y + 32, 3, 1, BOOTS_H);
    // Dust puffs from skidding
    const dustAlpha = 0.4 + Math.sin(frameCount * 0.4) * 0.2;
    ctx.fillStyle = `rgba(180,160,130,${dustAlpha})`;
    ctx.fillRect(x - 3, y + 32, 4, 3);
    ctx.fillRect(x - 5, y + 30, 3, 2);
    ctx.fillStyle = `rgba(180,160,130,${dustAlpha * 0.6})`;
    ctx.fillRect(x - 7, y + 31, 3, 2);
    if (facingLeft) ctx.restore();
    return;
  }

  // ── RUN: 4-frame cycle with body bob, arm swing, leg stride ──
  // Body bob: phases 0 & 2 (full stride) bob up 1px, phases 1 & 3 (contact) sit lower
  const runBob = (frame % 2 === 0) ? -1 : 1;
  const ry = y + runBob;
  // Cap — bouncing with body
  drawPixelRect(x + 5, ry - 2, 18, 3, CAP);
  drawPixelRect(x + 7, ry - 4, 14, 3, CAP);
  drawPixelRect(x + 9, ry - 5, 8, 2, CAP_HI);
  drawPixelRect(x + 3, ry + 1, 22, 2, CAP_SH);
  drawPixelRect(x + 12, ry - 3, 4, 2, BADGE);
  // Head
  drawPixelRect(x + 6, ry + 3, 16, 11, SKIN);
  drawPixelRect(x + 6, ry + 10, 3, 4, SKIN_SH);
  // Eyes
  drawPixelRect(x + 8, ry + 5, 3, 3, EYE_W);
  drawPixelRect(x + 17, ry + 5, 3, 3, EYE_W);
  drawPixelRect(x + 9, ry + 6, 2, 2, EYES);
  drawPixelRect(x + 18, ry + 6, 2, 2, EYES);
  // Nose
  drawPixelRect(x + 12, ry + 7, 5, 4, NOSE);
  drawPixelRect(x + 13, ry + 6, 3, 1, NOSE);
  // Mustache
  drawPixelRect(x + 8, ry + 10, 12, 2, STACHE);
  drawPixelRect(x + 7, ry + 10, 2, 1, STACHE);
  drawPixelRect(x + 19, ry + 10, 2, 1, STACHE);
  // Mouth — determined
  drawPixelRect(x + 12, ry + 12, 5, 1, MOUTH);
  // Shirt
  drawPixelRect(x + 7, ry + 14, 14, 3, SHIRT);
  drawPixelRect(x + 7, ry + 14, 4, 2, SHIRT_HI);
  // Overalls
  drawPixelRect(x + 6, ry + 16, 16, 8, OVERALL);
  drawPixelRect(x + 6, ry + 16, 3, 6, OVER_HI);
  drawPixelRect(x + 19, ry + 18, 3, 4, OVER_SH);
  // Straps
  drawPixelRect(x + 8, ry + 14, 3, 3, STRAP);
  drawPixelRect(x + 17, ry + 14, 3, 3, STRAP);
  drawPixelRect(x + 9, ry + 14, 1, 1, BUTTON);
  drawPixelRect(x + 18, ry + 14, 1, 1, BUTTON);

  // ── Arms & Legs — 4-frame run cycle with pronounced swing ──
  const phase = frame % 4;
  if (phase === 0) {
    // Left arm swung far forward, right arm far back
    drawPixelRect(x + 0, y + 14, 5, 6, SHIRT);   // left arm forward-down
    drawPixelRect(x + 0, y + 20, 4, 3, GLOVE);
    drawPixelRect(x + 23, y + 11, 4, 5, SHIRT);   // right arm back-up
    drawPixelRect(x + 24, y + 10, 3, 2, GLOVE);
    // Left leg forward (extended), right leg back
    drawPixelRect(x + 3, y + 24, 7, 8, OVERALL);
    drawPixelRect(x + 5, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 17, y + 26, 5, 6, OVERALL);
    drawPixelRect(x + 1, y + 32, 9, 4, BOOTS_C);
    drawPixelRect(x + 2, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 17, y + 32, 7, 4, BOOTS_C);
  } else if (phase === 1) {
    // Arms mid-swing, passing through
    drawPixelRect(x + 1, y + 16, 5, 4, SHIRT);
    drawPixelRect(x + 1, y + 20, 4, 2, GLOVE);
    drawPixelRect(x + 22, y + 16, 5, 4, SHIRT);
    drawPixelRect(x + 22, y + 20, 4, 2, GLOVE);
    // Legs passing — together under body
    drawPixelRect(x + 8, y + 24, 5, 8, OVERALL);
    drawPixelRect(x + 10, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 14, y + 24, 5, 8, OVERALL);
    drawPixelRect(x + 16, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 6, y + 32, 7, 4, BOOTS_C);
    drawPixelRect(x + 7, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 14, y + 32, 7, 4, BOOTS_C);
    drawPixelRect(x + 15, y + 32, 3, 1, BOOTS_H);
  } else if (phase === 2) {
    // Right arm swung far forward, left arm far back (mirror of 0)
    drawPixelRect(x + 23, y + 14, 5, 6, SHIRT);   // right arm forward-down
    drawPixelRect(x + 24, y + 20, 4, 3, GLOVE);
    drawPixelRect(x + 1, y + 11, 4, 5, SHIRT);    // left arm back-up
    drawPixelRect(x + 1, y + 10, 3, 2, GLOVE);
    // Right leg forward, left leg back
    drawPixelRect(x + 16, y + 24, 7, 8, OVERALL);
    drawPixelRect(x + 18, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 6, y + 26, 5, 6, OVERALL);
    drawPixelRect(x + 16, y + 32, 9, 4, BOOTS_C);
    drawPixelRect(x + 17, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 4, y + 32, 7, 4, BOOTS_C);
  } else {
    // phase 3: arms mid-swing returning, legs passing
    drawPixelRect(x + 22, y + 16, 5, 4, SHIRT);
    drawPixelRect(x + 22, y + 20, 4, 2, GLOVE);
    drawPixelRect(x + 1, y + 16, 5, 4, SHIRT);
    drawPixelRect(x + 1, y + 20, 4, 2, GLOVE);
    drawPixelRect(x + 7, y + 24, 6, 8, OVERALL);
    drawPixelRect(x + 9, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 15, y + 24, 6, 8, OVERALL);
    drawPixelRect(x + 17, y + 26, 2, 2, OVER_HI);
    drawPixelRect(x + 5, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 6, y + 32, 3, 1, BOOTS_H);
    drawPixelRect(x + 15, y + 32, 8, 4, BOOTS_C);
    drawPixelRect(x + 16, y + 32, 3, 1, BOOTS_H);
  }
  if (facingLeft) ctx.restore();
}

// Get pipe collision rectangles
// Returns { lipRect, bodyRect, topY (top of entire pipe visual) }
function getPipeRects(pipe) {
  // Marker pipes (h=0, used for brick-replaced spawns) have no collision
  if (pipe.h <= 0) {
    return {
      lipRect: { x: pipe.x, y: -100, w: 0, h: 0 },
      bodyRect: { x: pipe.x, y: -100, w: 0, h: 0 },
      standY: null,
    };
  }
  const groundY = DESIGN_H - GROUND_H;
  const lipOffset = (LIP_W - PIPE_W) / 2;
  if (!pipe.fromTop) {
    // Bottom pipe
    const topY = groundY - pipe.h;
    return {
      lipRect: { x: pipe.x, y: topY, w: LIP_W, h: LIP_H },
      bodyRect: { x: pipe.x + lipOffset, y: topY + LIP_H, w: PIPE_W, h: pipe.h - LIP_H },
      standY: topY, // top surface Y for standing
    };
  } else {
    // Top (ceiling) pipe — hangs from y=0
    const bottomY = pipe.h;
    return {
      lipRect: { x: pipe.x, y: bottomY - LIP_H, w: LIP_W, h: LIP_H },
      bodyRect: { x: pipe.x + lipOffset, y: 0, w: PIPE_W, h: pipe.h - LIP_H },
      standY: null, // cannot stand on top pipes
    };
  }
}

// Draw a bottom pipe (green, with lip at top)
function drawBottomPipe(px, ph) {
  const x = Math.round(px);
  const groundY = DESIGN_H - GROUND_H;
  const lipOffset = (LIP_W - PIPE_W) / 2;
  const bodyY = groundY - ph + LIP_H;
  const bodyH = ph - LIP_H;
  const topY = groundY - ph;
  // Pipe body
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x + lipOffset, bodyY, PIPE_W, bodyH);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + lipOffset + 4, bodyY, 8, bodyH);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + lipOffset + PIPE_W - 8, bodyY, 8, bodyH);
  // Lip
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x, topY, LIP_W, LIP_H);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + 4, topY + 2, 8, LIP_H - 4);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + LIP_W - 8, topY + 2, 6, LIP_H - 4);
  ctx.fillStyle = '#196f3d';
  ctx.fillRect(x, topY, LIP_W, 2);
}

// Draw a top (ceiling) pipe (hanging from top, lip at bottom)
function drawTopPipe(px, ph) {
  const x = Math.round(px);
  const lipOffset = (LIP_W - PIPE_W) / 2;
  const bodyH = ph - LIP_H;
  const lipY = bodyH;
  // Pipe body
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x + lipOffset, 0, PIPE_W, bodyH);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + lipOffset + 4, 0, 8, bodyH);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + lipOffset + PIPE_W - 8, 0, 8, bodyH);
  // Lip (at bottom of top pipe)
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(x, lipY, LIP_W, LIP_H);
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(x + 4, lipY + 2, 8, LIP_H - 4);
  ctx.fillStyle = '#1e8449';
  ctx.fillRect(x + LIP_W - 8, lipY + 2, 6, LIP_H - 4);
  // Bottom line of lip
  ctx.fillStyle = '#196f3d';
  ctx.fillRect(x, lipY + LIP_H - 2, LIP_W, 2);
}

// Draw ground with brick pattern
function drawGround() {
  const groundY = DESIGN_H - GROUND_H;
  const gc = getThemeGroundColors();
  // Draw ground covering the camera-visible area (in world coords)
  const drawLeft = cameraX - 32;
  const drawW = DESIGN_W + 96;
  ctx.fillStyle = gc.fill;
  ctx.fillRect(drawLeft, groundY, drawW, GROUND_H);
  const brickW = 32;
  const brickH = 16;
  // Align bricks to world grid (camera transform handles visual scrolling)
  const startX = Math.floor(drawLeft / brickW) * brickW;
  ctx.fillStyle = gc.line;
  for (let row = 0; row < Math.ceil(GROUND_H / brickH); row++) {
    const rowOffset = (row % 2) * (brickW / 2);
    for (let col = 0; col < Math.ceil(drawW / brickW) + 4; col++) {
      const bx = startX + col * brickW + rowOffset;
      const by = groundY + row * brickH;
      ctx.fillRect(bx, by, brickW, 1);
      ctx.fillRect(bx, by, 1, brickH);
    }
  }
  ctx.fillStyle = gc.top;
  ctx.fillRect(drawLeft, groundY, drawW, 3);
}

function drawCloud(cx, cy, cw) {
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  const h = cw * 0.4;
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.3, cy + h * 0.5, cw * 0.3, h * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.6, cy + h * 0.35, cw * 0.25, h * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + cw * 0.5, cy + h * 0.6, cw * 0.35, h * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawHill(hx, hw, hh) {
  const groundY = DESIGN_H - GROUND_H;
  ctx.fillStyle = getThemeHillColor();
  ctx.beginPath();
  ctx.moveTo(hx, groundY);
  ctx.quadraticCurveTo(hx + hw / 2, groundY - hh, hx + hw, groundY);
  ctx.fill();
}

// ── Draw breakable brick (original pixel-art style) ───
// A 32x24 terracotta/sandy brick with cracks and mortar lines
function drawBrick(bx, by) {
  const x = Math.round(bx);
  const y = Math.round(by);
  // Main brick body — warm sandy brown
  ctx.fillStyle = '#c8874a';
  ctx.fillRect(x, y, BRICK_W, BRICK_H);
  // Lighter highlight strip (top)
  ctx.fillStyle = '#daa06d';
  ctx.fillRect(x + 1, y + 1, BRICK_W - 2, 3);
  // Darker shadow strip (bottom)
  ctx.fillStyle = '#8b5e3c';
  ctx.fillRect(x + 1, y + BRICK_H - 3, BRICK_W - 2, 2);
  // Mortar lines (horizontal center)
  ctx.fillStyle = '#a07040';
  ctx.fillRect(x, y + 11, BRICK_W, 2);
  // Mortar lines (vertical, staggered)
  ctx.fillRect(x + 15, y, 2, 11);
  ctx.fillRect(x + 8, y + 13, 2, 11);
  ctx.fillRect(x + 24, y + 13, 2, 11);
  // Crack detail — small diagonal scratches
  ctx.fillStyle = '#6b4226';
  ctx.fillRect(x + 5, y + 4, 1, 3);
  ctx.fillRect(x + 6, y + 6, 2, 1);
  ctx.fillRect(x + 20, y + 15, 1, 3);
  ctx.fillRect(x + 21, y + 17, 2, 1);
  // Question mark / sparkle decoration (original, not Mario's ?)
  ctx.fillStyle = '#f4d03f';
  // Small diamond sparkle in center
  ctx.fillRect(x + 15, y + 3, 2, 2);
  ctx.fillRect(x + 14, y + 4, 1, 1);
  ctx.fillRect(x + 17, y + 4, 1, 1);
  ctx.fillRect(x + 15, y + 6, 2, 1);
  // Outline
  ctx.strokeStyle = '#5a3a1a';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, BRICK_W - 1, BRICK_H - 1);
}

// ── Draw special brick (purple/magical, contains mushroom) ───
function drawSpecialBrick(bx, by) {
  const x = Math.round(bx);
  const y = Math.round(by);
  // Main body — deep purple
  ctx.fillStyle = '#7b1fa2';
  ctx.fillRect(x, y, BRICK_W, BRICK_H);
  // Lighter highlight strip (top)
  ctx.fillStyle = '#ab47bc';
  ctx.fillRect(x + 1, y + 1, BRICK_W - 2, 3);
  // Darker shadow strip (bottom)
  ctx.fillStyle = '#4a148c';
  ctx.fillRect(x + 1, y + BRICK_H - 3, BRICK_W - 2, 2);
  // Mortar lines
  ctx.fillStyle = '#6a1b9a';
  ctx.fillRect(x, y + 11, BRICK_W, 2);
  ctx.fillRect(x + 15, y, 2, 11);
  ctx.fillRect(x + 8, y + 13, 2, 11);
  ctx.fillRect(x + 24, y + 13, 2, 11);
  // Sparkle/star decorations (animated shimmer)
  const shimmer = Math.sin(frameCount * 0.12) * 0.4 + 0.6;
  ctx.fillStyle = `rgba(255,215,0,${shimmer})`;
  // Star pattern
  ctx.fillRect(x + 7, y + 5, 2, 2);
  ctx.fillRect(x + 6, y + 6, 1, 1);
  ctx.fillRect(x + 9, y + 6, 1, 1);
  ctx.fillRect(x + 7, y + 7, 2, 1);
  ctx.fillRect(x + 22, y + 14, 2, 2);
  ctx.fillRect(x + 21, y + 15, 1, 1);
  ctx.fillRect(x + 24, y + 15, 1, 1);
  // Mushroom icon in center
  ctx.fillStyle = '#e53935';
  ctx.fillRect(x + 13, y + 4, 6, 4);
  ctx.fillRect(x + 12, y + 5, 8, 3);
  ctx.fillStyle = '#fff';
  ctx.fillRect(x + 14, y + 5, 2, 2);
  ctx.fillRect(x + 18, y + 6, 1, 1);
  ctx.fillStyle = '#f5e6cc';
  ctx.fillRect(x + 14, y + 8, 4, 3);
  // Outline
  ctx.strokeStyle = '#311b92';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, BRICK_W - 1, BRICK_H - 1);
}

// ── Draw question block (golden, animated "?" icon) ─────
function drawQuestionBlock(bx, by) {
  const x = Math.round(bx);
  const y = Math.round(by);
  // Main body — golden yellow
  ctx.fillStyle = '#e8a317';
  ctx.fillRect(x, y, BRICK_W, BRICK_H);
  // Lighter highlight strip (top)
  ctx.fillStyle = '#f4d03f';
  ctx.fillRect(x + 1, y + 1, BRICK_W - 2, 3);
  // Darker shadow strip (bottom)
  ctx.fillStyle = '#b8860b';
  ctx.fillRect(x + 1, y + BRICK_H - 3, BRICK_W - 2, 2);
  // Border rivets (4 corner dots)
  ctx.fillStyle = '#8b6914';
  ctx.fillRect(x + 2, y + 2, 2, 2);
  ctx.fillRect(x + BRICK_W - 4, y + 2, 2, 2);
  ctx.fillRect(x + 2, y + BRICK_H - 4, 2, 2);
  ctx.fillRect(x + BRICK_W - 4, y + BRICK_H - 4, 2, 2);
  // Animated "?" — shimmer via frameCount
  const shimmer = Math.sin(frameCount * 0.1) * 0.3 + 0.7;
  ctx.fillStyle = `rgba(255,255,255,${shimmer})`;
  // Question mark glyph (pixel art)
  ctx.fillRect(x + 13, y + 5, 6, 2);   // top bar
  ctx.fillRect(x + 17, y + 7, 2, 3);   // right stem
  ctx.fillRect(x + 15, y + 10, 2, 3);  // middle drop
  ctx.fillRect(x + 15, y + 15, 2, 2);  // dot
  // Outline
  ctx.strokeStyle = '#6b4226';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, BRICK_W - 1, BRICK_H - 1);
}

// ── Draw used block (dark, empty — spent question block) ─
function drawUsedBlock(bx, by) {
  const x = Math.round(bx);
  const y = Math.round(by);
  // Main body — dark metallic grey
  ctx.fillStyle = '#5a5a5a';
  ctx.fillRect(x, y, BRICK_W, BRICK_H);
  // Subtle highlight
  ctx.fillStyle = '#6e6e6e';
  ctx.fillRect(x + 1, y + 1, BRICK_W - 2, 2);
  // Shadow strip
  ctx.fillStyle = '#3e3e3e';
  ctx.fillRect(x + 1, y + BRICK_H - 3, BRICK_W - 2, 2);
  // Outline
  ctx.strokeStyle = '#2a2a2a';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, BRICK_W - 1, BRICK_H - 1);
}

// ── Draw revealed hidden block (teal/cyan metallic — secret found!) ─
function drawRevealedHiddenBlock(bx, by) {
  const x = Math.round(bx);
  const y = Math.round(by);
  // Main body — teal metallic
  ctx.fillStyle = '#3a8a8a';
  ctx.fillRect(x, y, BRICK_W, BRICK_H);
  // Highlight strip (top)
  ctx.fillStyle = '#5ababa';
  ctx.fillRect(x + 1, y + 1, BRICK_W - 2, 3);
  // Shadow strip (bottom)
  ctx.fillStyle = '#2a6a6a';
  ctx.fillRect(x + 1, y + BRICK_H - 3, BRICK_W - 2, 2);
  // "!" mark in center (secret found indicator)
  ctx.fillStyle = '#e0f0f0';
  ctx.fillRect(x + 15, y + 5, 2, 8);   // vertical bar
  ctx.fillRect(x + 15, y + 15, 2, 2);  // dot
  // Outline
  ctx.strokeStyle = '#1a4a4a';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, BRICK_W - 1, BRICK_H - 1);
}

// ── Coin Pop Animation ──────────────────────────────────
// Each coinPop: { x, y, vy, life }
function spawnCoinPop(x, y) {
  coinPops.push({ x: x, y: y - 4, vy: -6, life: 40, maxLife: 40 });
}

function updateCoinPops() {
  for (let i = coinPops.length - 1; i >= 0; i--) {
    const c = coinPops[i];
    c.y += c.vy;
    c.vy += 0.2; // gravity
    c.life--;
    if (c.life <= 0) {
      coinPops.splice(i, 1);
    }
  }
}

function updateBrickBumps() {
  for (const brick of bricks) {
    if (brick.bumpTimer > 0) brick.bumpTimer--;
  }
}

function getBumpOffset(brick) {
  if (!brick.bumpTimer || brick.bumpTimer <= 0) return 0;
  // Sine-based bump: peaks at halfway through animation
  const t = brick.bumpTimer / BLOCK_BUMP_FRAMES;  // 1→0
  return -Math.sin(t * Math.PI) * BLOCK_BUMP_HEIGHT;
}

function drawCoinPops() {
  for (const c of coinPops) {
    // Smooth fade-out over last 15 frames; full opacity otherwise
    const alpha = c.life <= 15 ? c.life / 15 : 1;
    const cx = Math.round(c.x);
    const cy = Math.round(c.y);
    // Slight spin effect: stretch width based on life cycle
    const spin = Math.cos((c.maxLife - c.life) * 0.5);
    const coinW = Math.max(2, Math.round(8 * Math.abs(spin)));
    const coinX = cx + Math.round((8 - coinW) / 2);
    ctx.save();
    ctx.globalAlpha = alpha;
    // Coin: golden with spin stretch
    ctx.fillStyle = '#f4d03f';
    ctx.fillRect(coinX, cy, coinW, 10);
    if (coinW > 4) {
      ctx.fillStyle = '#e8a317';
      ctx.fillRect(coinX + 1, cy + 1, coinW - 2, 8);
      ctx.fillStyle = '#fff';
      ctx.fillRect(coinX + Math.floor(coinW / 2), cy + 2, 1, 2); // highlight
    }
    ctx.restore();
  }
}

// ── Draw mushroom item ──────────────────────────────────
function drawMushroom(mx, my) {
  const x = Math.round(mx);
  const y = Math.round(my);
  // Cap — red with white spots
  ctx.fillStyle = '#e53935';
  ctx.fillRect(x + 2, y + 2, 16, 8);
  ctx.fillRect(x + 4, y, 12, 4);
  ctx.fillRect(x, y + 4, 20, 6);
  // White spots
  ctx.fillStyle = '#fff';
  ctx.fillRect(x + 5, y + 2, 3, 3);
  ctx.fillRect(x + 12, y + 3, 3, 3);
  ctx.fillRect(x + 8, y + 6, 2, 2);
  // Stem — tan
  ctx.fillStyle = '#f5e6cc';
  ctx.fillRect(x + 6, y + 10, 8, 8);
  ctx.fillStyle = '#e8d5b7';
  ctx.fillRect(x + 6, y + 10, 2, 8);
  // Eyes — cute face
  ctx.fillStyle = '#000';
  ctx.fillRect(x + 8, y + 13, 2, 2);
  ctx.fillRect(x + 12, y + 13, 2, 2);
  // Outline
  ctx.strokeStyle = '#b71c1c';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, MUSHROOM_W - 1, MUSHROOM_H - 1);
}

// ── Turtle Drawing (procedural pixel art) ───────────────
// Walking turtle: 24×28 px, original green/brown creature with shell on back
// turnCooldown > 0 → turtle just turned; show brief leg-lift hint
function drawTurtleWalk(tx, ty, direction, animFrame, turnCooldown) {
  const x = Math.round(tx);
  const y = Math.round(ty);
  ctx.save();
  // Flip based on movement direction: unflipped sprite faces left (head at x+0)
  // direction > 0 means moving right → flip sprite so head faces right
  if (direction > 0) {
    ctx.translate(x + TURTLE_W / 2, 0);
    ctx.scale(-1, 1);
    ctx.translate(-(x + TURTLE_W / 2), 0);
  }
  // Shell (dome on back) — forest green
  ctx.fillStyle = '#2e7d32';
  ctx.fillRect(x + 4, y + 4, 16, 14);
  ctx.fillRect(x + 6, y + 2, 12, 4);
  // Shell pattern — darker green stripes
  ctx.fillStyle = '#1b5e20';
  ctx.fillRect(x + 7, y + 6, 3, 10);
  ctx.fillRect(x + 13, y + 6, 3, 10);
  ctx.fillRect(x + 10, y + 4, 1, 12);
  // Shell highlight
  ctx.fillStyle = '#43a047';
  ctx.fillRect(x + 6, y + 4, 12, 2);
  // Head — olive/tan
  ctx.fillStyle = '#8d6e3f';
  ctx.fillRect(x + 0, y + 6, 6, 8);
  ctx.fillRect(x + 2, y + 4, 4, 4);
  // Eye
  ctx.fillStyle = '#fff';
  ctx.fillRect(x + 1, y + 6, 3, 3);
  ctx.fillStyle = '#000';
  ctx.fillRect(x + 1, y + 7, 2, 2);
  // Legs — tan/brown, animated
  ctx.fillStyle = '#a0845c';
  const turning = turnCooldown > 0;
  const legOffset = turning ? 0 : ((animFrame % 2 === 0) ? 0 : 2);
  // Front leg — lifts up briefly when turning
  const frontLegLift = turning ? 3 : 0;
  ctx.fillRect(x + 4 - legOffset, y + 18 - frontLegLift, 4, 8);
  ctx.fillRect(x + 2 - legOffset, y + 24 - frontLegLift, 6, 4);
  // Back leg
  ctx.fillRect(x + 14 + legOffset, y + 18, 4, 8);
  ctx.fillRect(x + 14 + legOffset, y + 24, 6, 4);
  // Feet — darker
  ctx.fillStyle = '#6d4c2a';
  ctx.fillRect(x + 2 - legOffset, y + 26 - frontLegLift, 6, 2);
  ctx.fillRect(x + 14 + legOffset, y + 26, 6, 2);
  // Outline
  ctx.strokeStyle = '#1a3a1a';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, TURTLE_W - 1, TURTLE_H - 1);
  ctx.restore();
}

// Shell (idle or moving): 24×16 px, compact dome shape
function drawTurtleShell(sx, sy, isMoving, animFrame, moveDir) {
  const x = Math.round(sx);
  const y = Math.round(sy);
  // Main shell body — forest green
  ctx.fillStyle = '#2e7d32';
  ctx.fillRect(x + 2, y + 2, 20, 12);
  ctx.fillRect(x + 4, y + 0, 16, 4);
  // Dome top
  ctx.fillStyle = '#43a047';
  ctx.fillRect(x + 6, y + 0, 12, 3);
  // Shell pattern — darker green
  ctx.fillStyle = '#1b5e20';
  ctx.fillRect(x + 5, y + 4, 3, 8);
  ctx.fillRect(x + 11, y + 4, 3, 8);
  ctx.fillRect(x + 17, y + 4, 3, 8);
  // Shell rim — brown
  ctx.fillStyle = '#8d6e3f';
  ctx.fillRect(x + 2, y + 12, 20, 3);
  // Speed lines when moving (on trailing side)
  if (isMoving) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    const offset = animFrame % 3;
    if (moveDir >= 0) {
      // Moving right: speed lines on left (trailing)
      ctx.fillRect(x - 4 - offset * 2, y + 4, 3, 1);
      ctx.fillRect(x - 3 - offset * 2, y + 8, 4, 1);
      ctx.fillRect(x - 5 - offset * 2, y + 12, 3, 1);
    } else {
      // Moving left: speed lines on right (trailing)
      ctx.fillRect(x + SHELL_W + 1 + offset * 2, y + 4, 3, 1);
      ctx.fillRect(x + SHELL_W + offset * 2, y + 8, 4, 1);
      ctx.fillRect(x + SHELL_W + 2 + offset * 2, y + 12, 3, 1);
    }
  }
  // Outline
  ctx.strokeStyle = '#1a3a1a';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, SHELL_W - 1, SHELL_H - 1);
}

// Dead turtle: brief flash before removal
function drawTurtleDead(tx, ty, deadTimer) {
  const x = Math.round(tx);
  const y = Math.round(ty);
  const alpha = deadTimer / TURTLE_DEAD_FRAMES;
  ctx.save();
  ctx.globalAlpha = alpha;
  // Upside-down shell
  ctx.translate(x + SHELL_W / 2, y + SHELL_H / 2);
  ctx.scale(1, -1);
  ctx.translate(-(x + SHELL_W / 2), -(y + SHELL_H / 2));
  drawTurtleShell(x, y, false, 0, 0);
  ctx.restore();
}

// Spawn a mushroom from a broken special brick
function spawnMushroom(bx, by) {
  const dir = Math.random() < 0.5 ? 1 : -1;  // random direction (v1 feel)
  let spawnX = bx + BRICK_W / 2 - MUSHROOM_W / 2;
  let spawnY = by - MUSHROOM_H;

  // Ensure spawn position doesn't overlap unbroken bricks above
  for (const brick of bricks) {
    if (brick.broken) continue;
    if (brick.hidden && !brick.revealed) continue;
    if (rectsOverlap(spawnX, spawnY, MUSHROOM_W, MUSHROOM_H, brick.x, brick.y, brick.w, brick.h)) {
      spawnY = brick.y - MUSHROOM_H - 2;
    }
  }
  if (spawnY < 0) spawnY = 0;

  // Enforce minimum horizontal distance from player (anti-instant-eat)
  const MIN_SPAWN_DIST = 24;
  const pb = getPlayerHitbox();
  const playerCX = pb.x + pb.w / 2;
  const mushCX = spawnX + MUSHROOM_W / 2;
  const hDist = Math.abs(mushCX - playerCX);
  if (hDist < MIN_SPAWN_DIST) {
    const shift = MIN_SPAWN_DIST - hDist;
    spawnX += (mushCX >= playerCX) ? shift : -shift;
  }

  mushrooms.push({
    x: spawnX,
    y: spawnY,
    vx: MUSHROOM_SPEED * dir,
    vy: MUSHROOM_POP_VY,        // -3: gentle pop (v1)
    onGround: false,
    stuckFrames: 0,
    graceTimer: MUSHROOM_SPAWN_GRACE,  // pickup-only immunity
    state: 'pop',
  });
  if (DEBUG_MODE) {
    console.log(`%c[Mushroom] Spawned at (${Math.round(spawnX)}, ${Math.round(spawnY)}), dir=${dir > 0 ? 'right' : 'left'}, vy=${MUSHROOM_POP_VY}`, 'color: #e53935');
  }
}

// ── Strict Pickup Boxes ─────────────────────────────────
// Inset mushroom and player rects to prevent "pickup before visual contact".

function getMushroomPickupBox(mx, my) {
  return {
    x: mx + MUSHROOM_PICKUP_INSET_X,
    y: my + MUSHROOM_PICKUP_INSET_Y,
    w: MUSHROOM_W - MUSHROOM_PICKUP_INSET_X * 2,
    h: MUSHROOM_H - MUSHROOM_PICKUP_INSET_Y * 2,
  };
}

function getPlayerPickupBox(pb) {
  return {
    x: pb.x + PLAYER_PICKUP_INSET_X,
    y: pb.y + PLAYER_PICKUP_INSET_Y,
    w: pb.w - PLAYER_PICKUP_INSET_X * 2,
    h: pb.h - PLAYER_PICKUP_INSET_Y * 2,
  };
}

function mushroomPickupOverlap(pb, mx, my) {
  // Both sides use inset boxes — no expansion
  const pp = getPlayerPickupBox(pb);
  const mp = getMushroomPickupBox(mx, my);
  return rectsOverlap(pp.x, pp.y, pp.w, pp.h, mp.x, mp.y, mp.w, mp.h);
}

// Update mushroom physics
function updateMushrooms() {
  const groundY = DESIGN_H - GROUND_H;
  const pb = getPlayerHitbox();

  for (let i = mushrooms.length - 1; i >= 0; i--) {
    const m = mushrooms[i];

    // ── Grace timer: only blocks pickup, physics always runs ──
    if (m.graceTimer > 0) m.graceTimer--;

    // Apply gravity
    m.vy += MUSHROOM_GRAVITY;
    m.x += m.vx;
    m.y += m.vy;

    // ── Update state for debug ──
    const prevState = m.state;
    if (m.onGround) {
      m.state = 'ground-run';
    } else if (m.vy >= 0 && m.state === 'pop') {
      m.state = 'fall';
    }
    if (DEBUG_MODE && m.state !== prevState) {
      console.log(`%c[Mushroom] State: ${prevState} → ${m.state}`, 'color: #e53935');
    }

    // Ground collision
    if (m.y + MUSHROOM_H >= groundY) {
      m.y = groundY - MUSHROOM_H;
      m.vy = 0;
      m.onGround = true;
      m.state = 'ground-run';
    }

    // Bounce off pipes (v1 logic: always active)
    for (const pipe of pipes) {
      if (pipe.h <= 0) continue;
      const pr = getPipeRects(pipe);
      const rects = [pr.lipRect, pr.bodyRect];
      for (const r of rects) {
        if (rectsOverlap(m.x, m.y, MUSHROOM_W, MUSHROOM_H, r.x, r.y, r.w, r.h)) {
          if (m.vy > 0 && m.y + MUSHROOM_H - m.vy <= r.y + 2) {
            m.y = r.y - MUSHROOM_H;
            m.vy = 0;
            m.onGround = true;
            m.state = 'ground-run';
          } else if (m.vx > 0 && m.x + MUSHROOM_W - m.vx <= r.x + 2) {
            m.x = r.x - MUSHROOM_W;
            m.vx = -m.vx;
          } else if (m.vx < 0 && m.x - m.vx >= r.x + r.w - 2) {
            m.x = r.x + r.w;
            m.vx = -m.vx;
          }
        }
      }
    }

    // Bounce off unbroken bricks (v2 improvement)
    for (const brick of bricks) {
      if (brick.broken) continue;
      if (brick.hidden && !brick.revealed) continue;
      if (rectsOverlap(m.x, m.y, MUSHROOM_W, MUSHROOM_H, brick.x, brick.y, brick.w, brick.h)) {
        if (m.vy > 0 && m.y + MUSHROOM_H - m.vy <= brick.y + 2) {
          m.y = brick.y - MUSHROOM_H;
          m.vy = 0;
          m.onGround = true;
          m.state = 'ground-run';
        } else if (m.vy < 0 && m.y - m.vy >= brick.y + brick.h - 2) {
          m.y = brick.y + brick.h;
          m.vy = 0;
        } else if (m.vx > 0 && m.x + MUSHROOM_W - m.vx <= brick.x + 2) {
          m.x = brick.x - MUSHROOM_W;
          m.vx = -m.vx;
        } else if (m.vx < 0 && m.x - m.vx >= brick.x + brick.w - 2) {
          m.x = brick.x + brick.w;
          m.vx = -m.vx;
        }
      }
    }

    // ── Unstuck logic (v2) ──
    let stuck = false;
    for (const pipe of pipes) {
      if (pipe.h <= 0) continue;
      const pr = getPipeRects(pipe);
      for (const r of [pr.lipRect, pr.bodyRect]) {
        if (rectsOverlap(m.x, m.y, MUSHROOM_W, MUSHROOM_H, r.x, r.y, r.w, r.h)) {
          stuck = true;
          const overlapLeft = (m.x + MUSHROOM_W) - r.x;
          const overlapRight = (r.x + r.w) - m.x;
          const overlapTop = (m.y + MUSHROOM_H) - r.y;
          const overlapBottom = (r.y + r.h) - m.y;
          const minH = Math.min(overlapLeft, overlapRight);
          const minV = Math.min(overlapTop, overlapBottom);
          if (minH < minV) {
            if (overlapLeft < overlapRight) { m.x = r.x - MUSHROOM_W; m.vx = -Math.abs(m.vx); }
            else { m.x = r.x + r.w; m.vx = Math.abs(m.vx); }
          } else {
            if (overlapTop < overlapBottom) { m.y = r.y - MUSHROOM_H; m.vy = 0; m.onGround = true; m.state = 'ground-run'; }
            else { m.y = r.y + r.h; m.vy = 0; }
          }
        }
      }
    }
    for (const brick of bricks) {
      if (brick.broken) continue;
      if (brick.hidden && !brick.revealed) continue;
      if (rectsOverlap(m.x, m.y, MUSHROOM_W, MUSHROOM_H, brick.x, brick.y, brick.w, brick.h)) {
        stuck = true;
        const overlapLeft = (m.x + MUSHROOM_W) - brick.x;
        const overlapRight = (brick.x + brick.w) - m.x;
        const overlapTop = (m.y + MUSHROOM_H) - brick.y;
        const overlapBottom = (brick.y + brick.h) - m.y;
        const minH = Math.min(overlapLeft, overlapRight);
        const minV = Math.min(overlapTop, overlapBottom);
        if (minH < minV) {
          if (overlapLeft < overlapRight) { m.x = brick.x - MUSHROOM_W; m.vx = -Math.abs(m.vx); }
          else { m.x = brick.x + brick.w; m.vx = Math.abs(m.vx); }
        } else {
          if (overlapTop < overlapBottom) { m.y = brick.y - MUSHROOM_H; m.vy = 0; m.onGround = true; m.state = 'ground-run'; }
          else { m.y = brick.y + brick.h; m.vy = 0; }
        }
      }
    }
    if (stuck) {
      m.stuckFrames = (m.stuckFrames || 0) + 1;
      if (m.stuckFrames > 30) {
        m.y = groundY - MUSHROOM_H;
        m.vy = 0;
        m.onGround = true;
        m.state = 'ground-run';
        m.stuckFrames = 0;
        if (DEBUG_MODE) console.log('%c[Mushroom] Unstuck: teleported to ground', 'color: #ff6');
      }
    } else {
      m.stuckFrames = 0;
    }

    // Remove if far from camera
    if (m.x + MUSHROOM_W < cameraX - 100 || m.x > cameraX + DESIGN_W + 200 || m.y > DESIGN_H + 20) {
      mushrooms.splice(i, 1);
      continue;
    }

    // ── Contact-only pickup: grace expired + strict AABB overlap ──
    const overlap = mushroomPickupOverlap(pb, m.x, m.y);
    const picked = (m.graceTimer <= 0) && overlap;
    if (picked) {
      doubleJumpTimer = DOUBLE_JUMP_DURATION;
      mushrooms.splice(i, 1);
      advanceMission('eat_mushroom');
      spawnScorePopup(m.x, m.y - 10, 0);
      scorePopups[scorePopups.length - 1].text = 'MUSHROOM!';
      if (DEBUG_MODE) {
        edgeDebugMsgs.push({ text: 'MUSHROOM PICKUP', ttl: 120 });
        console.log(`%c[Mushroom] Collected! Double jump active for ${DOUBLE_JUMP_DURATION}s`, 'color: #e53935; font-weight: bold');
      }
    }
  }
}

// ── Turtle Enemy Update ─────────────────────────────────
// Returns true if player was killed by a turtle this frame
function updateTurtles() {
  const groundY = DESIGN_H - GROUND_H;
  const pb = getPlayerHitbox();

  for (let i = turtles.length - 1; i >= 0; i--) {
    const t = turtles[i];

    // ── Dead turtles: count down and remove ──
    if (t.state === 'dead') {
      t.deadTimer--;
      t.vy += TURTLE_GRAVITY;
      t.y += t.vy;
      if (t.deadTimer <= 0 || t.y > DESIGN_H + 50) {
        turtles.splice(i, 1);
      }
      continue;
    }

    // ── Shell bounce dead: rises then falls off-screen, no collisions ──
    if (t.state === 'shell_bounce_dead') {
      t.vy += TURTLE_GRAVITY;
      t.y += t.vy;
      if (t.y > DESIGN_H + 50) {
        turtles.splice(i, 1);
      }
      continue;
    }

    // ── Kick grace timer ──
    if (t.kickGrace > 0) t.kickGrace--;
    // ── Turn cooldown timer (prevents jitter) ──
    if (t.turnCooldown > 0) t.turnCooldown--;
    // ── Shell bounce cooldown (prevents wall-sticking) ──
    if (t.bounceCooldown > 0) t.bounceCooldown--;

    // ── Physics: gravity ──
    t.vy += TURTLE_GRAVITY;

    // ── Horizontal movement ──
    if (t.state === 'walk') {
      t.vx = TURTLE_WALK_SPEED * t.direction;  // direction matches vx sign
    } else if (t.state === 'shell_idle') {
      t.vx = 0;
    }
    // shell_move: vx already set when kicked

    t.x += t.vx;
    t.y += t.vy;

    // Current dimensions depend on state
    const tw = (t.state === 'walk') ? TURTLE_W : SHELL_W;
    const th = (t.state === 'walk') ? TURTLE_H : SHELL_H;

    // ── Ground collision ──
    if (t.y + th >= groundY) {
      t.y = groundY - th;
      t.vy = 0;
      t.onGround = true;
    }

    // ── Pipe/brick collision (terrain) ──
    for (const pipe of pipes) {
      if (pipe.h <= 0) continue;
      const pr = getPipeRects(pipe);
      const rects = [pr.lipRect, pr.bodyRect];
      for (const r of rects) {
        if (!rectsOverlap(t.x, t.y, tw, th, r.x, r.y, r.w, r.h)) continue;
        // Landing on top
        if (t.vy > 0 && t.y + th - t.vy <= r.y + 2) {
          t.y = r.y - th;
          t.vy = 0;
          t.onGround = true;
        }
        // Side collision
        else if (t.vx > 0 && t.x + tw - t.vx <= r.x + 2) {
          t.x = r.x - tw;
          if (t.state === 'walk' && t.turnCooldown <= 0) { t.direction = -1; t.turnCooldown = TURTLE_TURN_COOLDOWN; }
          else if (t.state === 'shell_move' && t.bounceCooldown <= 0) { t.vx = -Math.abs(t.vx); t.bounceCooldown = SHELL_BOUNCE_COOLDOWN; }
        } else if (t.vx < 0 && t.x - t.vx >= r.x + r.w - 2) {
          t.x = r.x + r.w;
          if (t.state === 'walk' && t.turnCooldown <= 0) { t.direction = 1; t.turnCooldown = TURTLE_TURN_COOLDOWN; }
          else if (t.state === 'shell_move' && t.bounceCooldown <= 0) { t.vx = Math.abs(t.vx); t.bounceCooldown = SHELL_BOUNCE_COOLDOWN; }
        }
      }
    }

    for (const brick of bricks) {
      if (brick.broken) continue;
      if (brick.hidden && !brick.revealed) continue;
      if (!rectsOverlap(t.x, t.y, tw, th, brick.x, brick.y, brick.w, brick.h)) continue;
      if (t.vy > 0 && t.y + th - t.vy <= brick.y + 2) {
        t.y = brick.y - th;
        t.vy = 0;
        t.onGround = true;
      } else if (t.vx > 0 && t.x + tw - t.vx <= brick.x + 2) {
        t.x = brick.x - tw;
        if (t.state === 'walk' && t.turnCooldown <= 0) { t.direction = -1; t.turnCooldown = TURTLE_TURN_COOLDOWN; }
        else if (t.state === 'shell_move' && t.bounceCooldown <= 0) { t.vx = -Math.abs(t.vx); t.bounceCooldown = SHELL_BOUNCE_COOLDOWN; }
      } else if (t.vx < 0 && t.x - t.vx >= brick.x + brick.w - 2) {
        t.x = brick.x + brick.w;
        if (t.state === 'walk' && t.turnCooldown <= 0) { t.direction = 1; t.turnCooldown = TURTLE_TURN_COOLDOWN; }
        else if (t.state === 'shell_move' && t.bounceCooldown <= 0) { t.vx = Math.abs(t.vx); t.bounceCooldown = SHELL_BOUNCE_COOLDOWN; }
      }
    }

    // ── Edge detection: if walking turtle reaches platform edge, reverse ──
    // Only for turtles on elevated platforms (feet above main ground level)
    if (t.state === 'walk' && t.onGround && t.y + th < groundY - 2) {
      // Check if there's ground ahead — use a wider probe (4×6) to avoid sub-pixel jitter
      const probeW = 4, probeH = 6;
      const checkX = t.direction < 0 ? t.x - probeW : t.x + tw;
      const checkY = t.y + th + 2;
      let hasGround = false;
      // Check pipes/bricks below
      for (const pipe of pipes) {
        if (pipe.h <= 0) continue;
        const pr = getPipeRects(pipe);
        if (rectsOverlap(checkX, checkY, probeW, probeH, pr.lipRect.x, pr.lipRect.y, pr.lipRect.w, pr.lipRect.h) ||
            rectsOverlap(checkX, checkY, probeW, probeH, pr.bodyRect.x, pr.bodyRect.y, pr.bodyRect.w, pr.bodyRect.h)) {
          hasGround = true;
          break;
        }
      }
      if (!hasGround) {
        for (const brick of bricks) {
          if (brick.broken) continue;
          if (brick.hidden && !brick.revealed) continue;
          if (rectsOverlap(checkX, checkY, probeW, probeH, brick.x, brick.y, brick.w, brick.h)) {
            hasGround = true;
            break;
          }
        }
      }
      if (!hasGround && t.turnCooldown <= 0) {
        t.direction *= -1;
        // Snap turtle back a few px away from edge to prevent flip-flop
        t.x += t.direction * 3;
        t.turnCooldown = TURTLE_TURN_COOLDOWN;
      }
    }

    // ── Animation ──
    if (t.state === 'walk') {
      if (frameCount % 8 === 0) t.animFrame = (t.animFrame + 1) % 4;
    } else {
      t.animFrame = (t.animFrame + 1) % 6;
    }

    // ── Remove if off-screen ──
    if (t.x + tw < cameraX - 200 || t.x > cameraX + DESIGN_W + 400) {
      turtles.splice(i, 1);
      continue;
    }

    // ── Shell-vs-turtle collisions (moving shell kills other turtles) ──
    if (t.state === 'shell_move') {
      for (let j = turtles.length - 1; j >= 0; j--) {
        if (j === i) continue;
        const other = turtles[j];
        if (other.state === 'dead' || other.state === 'shell_bounce_dead') continue;
        const ow = (other.state === 'walk') ? TURTLE_W : SHELL_W;
        const oh = (other.state === 'walk') ? TURTLE_H : SHELL_H;
        if (rectsOverlap(t.x, t.y, tw, th, other.x, other.y, ow, oh)) {
          // Kill the other turtle
          other.state = 'dead';
          other.vy = -3;
          other.deadTimer = TURTLE_DEAD_FRAMES;
          // Shell combo scoring: 20, 40, 80, 160, 320 (capped at SHELL_COMBO_MAX)
          t.shellCombo++;
          const comboLevel = Math.min(t.shellCombo, SHELL_COMBO_MAX);
          const killScore = SHELL_COMBO_BASE * Math.pow(2, comboLevel - 1);
          score += killScore;
          sfxShellCombo(comboLevel);
          if (t.shellCombo >= 2) {
            // Show shell combo popup with escalating style
            spawnScorePopup(other.x, other.y - 10, 0);
            const cp = scorePopups[scorePopups.length - 1];
            cp.text = `SHELL x${t.shellCombo} +${killScore}`;
            // Color escalation: teal → cyan → gold at high combo
            const comboColors = ['#4aeadc', '#4aeadc', '#5af8ff', '#fff44f', '#ff6'];
            const comboStrokes = ['#1a4a3a', '#1a4a3a', '#0a3a5a', '#5a4a0a', '#5a3a0a'];
            const ci = Math.min(comboLevel - 1, comboColors.length - 1);
            cp.color = comboColors[ci];
            cp.strokeColor = comboStrokes[ci];
            // Font size scales with combo level (16→18→20→22→24)
            const fontSize = 16 + (comboLevel - 1) * 2;
            cp.font = `bold ${fontSize}px monospace`;
            cp.scale = 1.0 + comboLevel * 0.15; // initial scale boost
            cp.life = 55 + comboLevel * 8; // longer display at higher combo
          } else {
            spawnScorePopup(other.x, other.y - 10, killScore);
          }
          if (DEBUG_MODE) console.log(`%c[Turtle] Shell combo x${t.shellCombo}! +${killScore}`, 'color: #4caf50; font-weight: bold');
          // If j < i, adjust index since we haven't removed yet
          // (dead turtles handled next frame)
        }
      }
    }

    // ── Player collision ──
    if (!rectsOverlap(pb.x, pb.y, pb.w, pb.h, t.x, t.y, tw, th)) continue;

    if (t.state === 'walk') {
      // Check if stomp: player is falling and player bottom is above turtle center
      const playerBottom = pb.y + pb.h;
      const turtleCenter = t.y + th * 0.4;
      if (player.vy > 0 && playerBottom <= turtleCenter + 4) {
        // STOMP! Turtle becomes shell
        const oldY = t.y;
        t.state = 'shell_idle';
        t.vx = 0;
        t.vy = 0;  // stop vertical movement so shell stays on surface
        t.kickGrace = TURTLE_SHELL_IDLE_KICK_GRACE;
        // Reposition: shell is shorter, keep it on ground
        t.y = oldY + (TURTLE_H - SHELL_H);
        // Clamp to ground so shell never sinks below
        if (t.y + SHELL_H > groundY) t.y = groundY - SHELL_H;
        t.onGround = (t.y + SHELL_H >= groundY - 1);
        // Bounce player
        player.vy = TURTLE_STOMP_BOUNCE_VY;
        player.onGround = false;
        score += TURTLE_STOMP_SCORE;
        spawnScorePopup(t.x, t.y - 10, TURTLE_STOMP_SCORE);
        triggerCombo(TURTLE_STOMP_SCORE);
        if (DEBUG_MODE) console.log(`%c[Turtle] Stomped! → shell_idle +${TURTLE_STOMP_SCORE} combo:${comboCount}`, 'color: #4caf50');
      } else {
        // Side/bottom collision with walking turtle → player dies
        return true; // signal death
      }
    } else if (t.state === 'shell_idle') {
      if (t.kickGrace > 0) continue; // still in grace period, ignore
      const playerBottom = pb.y + pb.h;
      const shellCenter = t.y + SHELL_H * 0.4;
      if (player.vy > 0 && playerBottom <= shellCenter + 4) {
        // STOMP from above → score + shell bounces up and falls off-screen
        score += TURTLE_SHELL_STOMP_SCORE;
        spawnScorePopup(t.x, t.y - 10, TURTLE_SHELL_STOMP_SCORE);
        triggerCombo(TURTLE_SHELL_STOMP_SCORE);
        player.vy = TURTLE_STOMP_BOUNCE_VY;
        player.onGround = false;
        t.state = 'shell_bounce_dead';
        t.vy = -7;  // upward bounce
        t.vx = 0;
        if (DEBUG_MODE) console.log(`%c[Turtle] Shell stomped! +${TURTLE_SHELL_STOMP_SCORE} combo:${comboCount} → bounce dead`, 'color: #4caf50');
      } else {
        // Side touch → kick the shell into shell_move
        t.state = 'shell_move';
        t.shellCombo = 0; // reset combo on new kick
        t.vy = 0;
        if (t.y + SHELL_H > groundY) t.y = groundY - SHELL_H;
        const playerCX = pb.x + pb.w / 2;
        const shellCX = t.x + SHELL_W / 2;
        t.vx = (shellCX >= playerCX) ? SHELL_MOVE_SPEED : -SHELL_MOVE_SPEED;
        t.kickGrace = TURTLE_SHELL_IDLE_KICK_GRACE;
        if (DEBUG_MODE) console.log(`%c[Turtle] Shell kicked! dir=${t.vx > 0 ? 'right' : 'left'}`, 'color: #ff9800');
      }
    } else if (t.state === 'shell_move') {
      // Moving shell hits player → death
      return true; // signal death
    }
  }
  return false; // no death
}

// Spawn a turtle on ground at given X position
function spawnTurtle(spawnX) {
  const groundY = DESIGN_H - GROUND_H;
  const ty = groundY - TURTLE_H;

  // Check it doesn't overlap pipes or bricks
  for (const pipe of pipes) {
    if (pipe.h <= 0) continue;
    const pr = getPipeRects(pipe);
    if (rectsOverlap(spawnX, ty, TURTLE_W, TURTLE_H, pr.lipRect.x, pr.lipRect.y, pr.lipRect.w, pr.lipRect.h) ||
        rectsOverlap(spawnX, ty, TURTLE_W, TURTLE_H, pr.bodyRect.x, pr.bodyRect.y, pr.bodyRect.w, pr.bodyRect.h)) {
      return; // skip spawn — overlaps a pipe
    }
  }
  for (const brick of bricks) {
    if (brick.broken) continue;
    if (brick.hidden && !brick.revealed) continue;
    if (rectsOverlap(spawnX, ty, TURTLE_W, TURTLE_H, brick.x, brick.y, brick.w, brick.h)) {
      return; // skip spawn — overlaps a brick
    }
  }

  // Nearby-turtle density cap: reject spawn if too many walk/idle turtles nearby
  let nearbyCount = 0;
  for (const ot of turtles) {
    if (ot.state !== 'walk' && ot.state !== 'shell_idle') continue;
    if (Math.abs(ot.x - spawnX) < TURTLE_MIN_SPAWN_GAP) nearbyCount++;
  }
  if (nearbyCount >= TURTLE_NEARBY_CAP) return; // too crowded

  turtles.push({
    x: spawnX,
    y: ty,
    vx: -TURTLE_WALK_SPEED,
    vy: 0,
    onGround: true,
    state: 'walk',
    direction: -1, // faces left (direction sign = vx sign)
    animFrame: 0,
    deadTimer: 0,
    kickGrace: 0,
    turnCooldown: 0,
    bounceCooldown: 0,
    shellCombo: 0,
  });
  lastTurtleSpawnX = spawnX;
  if (DEBUG_MODE) console.log(`%c[Turtle] Spawned at x=${Math.round(spawnX)}`, 'color: #4caf50');
}

// Draw a single debris fragment
function drawFragment(frag) {
  ctx.fillStyle = frag.color;
  ctx.fillRect(Math.round(frag.x), Math.round(frag.y), frag.size, frag.size);
}

// Spawn a floating score popup
function spawnScorePopup(x, y, points) {
  scorePopups.push({
    x: x,
    y: y,
    text: `+${points}`,
    life: 45,
  });
}

// Update score popups
function updateScorePopups() {
  for (let i = scorePopups.length - 1; i >= 0; i--) {
    const p = scorePopups[i];
    p.y -= 1.2; // float upward
    p.life--;
    if (p.life <= 0) {
      scorePopups.splice(i, 1);
    }
  }
}

// Draw score popups
function drawScorePopups() {
  for (const p of scorePopups) {
    const alpha = Math.min(1, p.life / 15);
    ctx.save();
    ctx.globalAlpha = alpha;
    // Scale support: shrink from initial scale → 1.0 over life
    const sc = p.scale ? 1 + (p.scale - 1) * Math.min(1, p.life / 30) : 1;
    if (sc !== 1) {
      ctx.translate(Math.round(p.x), Math.round(p.y));
      ctx.scale(sc, sc);
      ctx.translate(-Math.round(p.x), -Math.round(p.y));
    }
    ctx.font = p.font || 'bold 14px monospace';
    ctx.fillStyle = p.color || '#f4d03f';
    ctx.strokeStyle = p.strokeColor || '#5a3a1a';
    ctx.lineWidth = 2;
    ctx.strokeText(p.text, Math.round(p.x), Math.round(p.y));
    ctx.fillText(p.text, Math.round(p.x), Math.round(p.y));
    ctx.restore();
  }
}

// ── 1UP: 100 coins → extra life ──────────────────────
function check1UP() {
  while (coins >= 100) {
    coins -= 100;
    lives++;
    sfx1UP();
    spawnScorePopup(player.x, player.y - 30, 0);
    scorePopups[scorePopups.length - 1].text = '1UP!';
    if (DEBUG_MODE) console.log(`%c[1UP] Extra life! lives=${lives}`, 'color: #7fff7f; font-weight: bold');
  }
}

// ── Respawn player in-place (life lost, keep score/coins) ──
function respawnPlayer() {
  lives--;
  // Reset player position to safe ground near camera
  player.x = cameraX + RECENTER_TARGET_X;
  player.y = DESIGN_H - GROUND_H - player.h;
  player.vy = 0;
  player.onGround = true;
  player.frame = 0;
  player.animState = 'idle';
  player.landTimer = 0;
  player.wasOnGround = true;
  playerVX = 0;
  playerBraking = false;
  brakeTimer = 0;
  jumpHoldFrames = 0;
  jumpConsumed = false;
  coyoteFrames = 0;
  justJumped = false;
  airJumpsUsed = 0;
  isAirJump = false;
  doubleJumpTimer = 0;
  // Remove nearby enemies/shells that could instantly re-kill
  turtles = turtles.filter(t => {
    const dist = Math.abs(t.x - player.x);
    return dist > 200;
  });
  // Brief invincibility popup
  spawnScorePopup(player.x, player.y - 20, 0);
  scorePopups[scorePopups.length - 1].text = `LIFE -1 (${lives} left)`;
  if (DEBUG_MODE) console.log(`%c[Life] Respawn! lives=${lives}`, 'color: #ff9800; font-weight: bold');
}

// ── Time Bonus Popup ──────────────────────────────────
let timeBonusPopups = []; // { x, y, life }

function spawnTimeBonusPopup(x, y) {
  timeBonusPopups.push({ x: x, y: y, life: 60 });
}

function updateTimeBonusPopups() {
  for (let i = timeBonusPopups.length - 1; i >= 0; i--) {
    const p = timeBonusPopups[i];
    p.y -= 0.8;
    p.life--;
    if (p.life <= 0) timeBonusPopups.splice(i, 1);
  }
}

function drawTimeBonusPopups() {
  for (const p of timeBonusPopups) {
    const alpha = Math.min(1, p.life / 20);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 13px monospace';
    ctx.fillStyle = '#2ecc71';
    ctx.strokeStyle = '#145a2a';
    ctx.lineWidth = 2;
    ctx.strokeText(`+${BRICK_TIME_BONUS}s`, Math.round(p.x), Math.round(p.y));
    ctx.fillText(`+${BRICK_TIME_BONUS}s`, Math.round(p.x), Math.round(p.y));
    ctx.restore();
  }
}

// Spawn debris fragments when a brick breaks
function spawnBrickFragments(bx, by) {
  const colors = ['#c8874a', '#daa06d', '#8b5e3c', '#a07040', '#6b4226', '#f4d03f'];
  for (let i = 0; i < BRICK_FRAGMENT_COUNT; i++) {
    const angle = (Math.PI * 2 * i) / BRICK_FRAGMENT_COUNT + (Math.random() - 0.5) * 0.5;
    const speed = 2.5 + Math.random() * 3;
    fragments.push({
      x: bx + BRICK_W / 2 + (Math.random() - 0.5) * BRICK_W * 0.6,
      y: by + BRICK_H / 2 + (Math.random() - 0.5) * BRICK_H * 0.4,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 3 - Math.random() * 2, // bias upward initially
      size: 3 + Math.floor(Math.random() * 5),
      color: colors[Math.floor(Math.random() * colors.length)],
      life: 40 + Math.floor(Math.random() * 20), // frames before despawn
    });
  }
}

// Update all fragments (gravity + movement + lifetime)
function updateFragments() {
  for (let i = fragments.length - 1; i >= 0; i--) {
    const f = fragments[i];
    f.vy += 0.35; // gravity on fragments
    f.x += f.vx;
    f.y += f.vy;
    f.life--;
    if (f.life <= 0 || f.y > DESIGN_H + 20) {
      fragments.splice(i, 1);
    }
  }
}

// ── Hidden Block Hint Sparks ──────────────────────────
// Check proximity to unrevealed hidden blocks and spawn subtle sparks
function updateHintSparks() {
  // Update existing sparks
  for (let i = hintSparks.length - 1; i >= 0; i--) {
    const s = hintSparks[i];
    s.y += s.vy;
    s.life--;
    if (s.life <= 0) { hintSparks.splice(i, 1); }
  }
  // Throttle spawning
  hintSparkTimer++;
  if (hintSparkTimer < HIDDEN_HINT_FREQ) return;
  hintSparkTimer = 0;
  // Check if player is near any unrevealed hidden block
  const px = player.x + player.w / 2;
  const py = player.y + player.h;
  for (const brick of bricks) {
    if (!brick.hidden || brick.revealed || brick.broken) continue;
    const bCenterX = brick.x + brick.w / 2;
    const dx = Math.abs(px - bCenterX);
    // Player must be horizontally close and below the block (within ~1.5 block heights)
    if (dx < HIDDEN_HINT_RANGE && py > brick.y && py < brick.y + brick.h + 50) {
      // Spawn one tiny spark near the hidden block (randomized position)
      hintSparks.push({
        x: brick.x + Math.random() * brick.w,
        y: brick.y + brick.h + Math.random() * 4,
        vy: -0.5 - Math.random() * 0.5,
        life: 18,
        maxLife: 18,
      });
      break; // only one spark per check
    }
  }
}

function drawHintSparks() {
  for (const s of hintSparks) {
    const alpha = s.life / s.maxLife * 0.5; // very subtle, max 0.5 alpha
    const size = 1.5 + (s.life / s.maxLife);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#7eeaea';
    ctx.fillRect(Math.round(s.x) - size / 2, Math.round(s.y) - size / 2, size, size);
    ctx.restore();
  }
}

// ── Collision — Swept AABB Continuous Collision Detection ──

function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// Get player hitbox (slightly shrunken for fairness)
function getPlayerHitbox() {
  return {
    x: player.x + 4,
    y: player.y + 2,
    w: player.w - 8,
    h: player.h - 4,
  };
}

// ── Collision-Safe Horizontal Move ──────────────────────
// Moves player.x by dx while respecting pipe/brick collision.
// Uses swept AABB on the horizontal axis to find the maximum safe displacement.
// Returns the actual dx applied.
function collisionSafeMoveX(dx) {
  if (Math.abs(dx) < 0.01) return 0;
  const HB_OX = 4, HB_OY = 2, HB_W = player.w - 8, HB_H = player.h - 4;
  const hx = player.x + HB_OX;
  const hy = player.y + HB_OY;

  // Gather all collision rects (pipes + bricks + ground)
  const rects = gatherCollisionRects();

  // Swept AABB: move hitbox by (dx, 0), find earliest collision
  let bestT = 1.0;
  for (const r of rects) {
    if (r.type === 'ground') continue; // ground doesn't block horizontal
    const result = sweptAABB(hx, hy, HB_W, HB_H, dx, 0, r.x, r.y, r.w, r.h);
    if (result.t < bestT) {
      bestT = result.t;
    }
  }

  // Apply safe displacement with small epsilon pullback
  const safeT = Math.max(0, bestT - 0.001);
  const safeDX = dx * safeT;
  player.x += safeDX;
  return safeDX;
}

// Gather all solid collision AABBs in the world.
// Each rect: { x, y, w, h, type }
// type: 'ground' | 'pipe_lip' | 'pipe_body' | 'brick' | 'ceiling_pipe_lip' | 'ceiling_pipe_body'
function gatherCollisionRects() {
  const rects = [];
  const groundY = DESIGN_H - GROUND_H;

  // Ground (extends infinitely left/right, thick enough to never tunnel)
  rects.push({ x: player.x - 2000, y: groundY, w: 4000, h: 500, type: 'ground' });

  // Pipes
  for (const pipe of pipes) {
    if (pipe.h <= 0) continue;
    const pr = getPipeRects(pipe);
    if (!pipe.fromTop) {
      rects.push({ x: pr.lipRect.x, y: pr.lipRect.y, w: pr.lipRect.w, h: pr.lipRect.h, type: 'pipe_lip', standY: pr.standY });
      rects.push({ x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h, type: 'pipe_body' });
    } else {
      rects.push({ x: pr.lipRect.x, y: pr.lipRect.y, w: pr.lipRect.w, h: pr.lipRect.h, type: 'ceiling_pipe_lip' });
      rects.push({ x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h, type: 'ceiling_pipe_body' });
    }
  }

  // Bricks (hidden unrevealed bricks are non-solid — skip them)
  for (const brick of bricks) {
    if (brick.broken) continue;
    if (brick.hidden && !brick.revealed) continue;
    rects.push({ x: brick.x, y: brick.y, w: brick.w, h: brick.h, type: 'brick', brickRef: brick });
  }

  return rects;
}

// ── Swept AABB ──────────────────────────────────────────
// Given a moving AABB (pos + size) and velocity (dx, dy),
// and a static AABB (obstacle), compute the time of first contact [0, 1].
// Returns { t, normalX, normalY } where t is in [0,1] (fraction of movement),
// or { t: 1, normalX: 0, normalY: 0 } if no collision in this movement.
//
// The player AABB moves by (dx, dy) relative to the obstacle.
// Obstacles are treated as static for each sweep call; scroll motion is
// folded into the relative velocity before calling.
function sweptAABB(px, py, pw, ph, dx, dy, ox, oy, ow, oh) {
  // Compute entry and exit distances on each axis
  let xEntryDist, xExitDist, yEntryDist, yExitDist;

  if (dx > 0) {
    xEntryDist = ox - (px + pw);
    xExitDist = (ox + ow) - px;
  } else if (dx < 0) {
    xEntryDist = (ox + ow) - px;
    xExitDist = ox - (px + pw);
  } else {
    xEntryDist = ox - (px + pw);
    xExitDist = (ox + ow) - px;
  }

  if (dy > 0) {
    yEntryDist = oy - (py + ph);
    yExitDist = (oy + oh) - py;
  } else if (dy < 0) {
    yEntryDist = (oy + oh) - py;
    yExitDist = oy - (py + ph);
  } else {
    yEntryDist = oy - (py + ph);
    yExitDist = (oy + oh) - py;
  }

  // Compute entry and exit times
  let xEntry, xExit, yEntry, yExit;

  if (dx === 0) {
    // Not moving on X — check static overlap
    if (xEntryDist < 0 && xExitDist > 0) {
      // Overlapping on X already
      xEntry = -Infinity;
      xExit = Infinity;
    } else {
      // No overlap on X, can never collide
      return { t: 1, normalX: 0, normalY: 0 };
    }
  } else {
    xEntry = xEntryDist / dx;
    xExit = xExitDist / dx;
  }

  if (dy === 0) {
    if (yEntryDist < 0 && yExitDist > 0) {
      yEntry = -Infinity;
      yExit = Infinity;
    } else {
      return { t: 1, normalX: 0, normalY: 0 };
    }
  } else {
    yEntry = yEntryDist / dy;
    yExit = yExitDist / dy;
  }

  // The overall entry time is the latest entry, exit is the earliest exit
  const entryTime = Math.max(xEntry, yEntry);
  const exitTime = Math.min(xExit, yExit);

  // No collision conditions:
  // - Entry after exit (swept past without overlap)
  // - Entry after end of movement (t > 1)
  // - Both entries negative (moving away)
  if (entryTime > exitTime || entryTime > 1 || (xEntry < 0 && yEntry < 0)) {
    return { t: 1, normalX: 0, normalY: 0 };
  }

  // Entry time must be >= 0 for a valid future collision
  // (if < 0, we started overlapping — handle as depenetration)
  if (entryTime < -SWEEP_EPSILON) {
    return { t: 1, normalX: 0, normalY: 0 };
  }

  const t = Math.max(0, entryTime);

  // Determine collision normal (which axis was entered last)
  let normalX = 0, normalY = 0;
  if (xEntry > yEntry) {
    normalX = dx > 0 ? -1 : 1;
  } else {
    normalY = dy > 0 ? -1 : 1;
  }

  return { t, normalX, normalY };
}

// Depenetrate player from any overlapping obstacles.
// Called once before the sweep loop to fix any pre-existing overlaps.
function depenetratePlayer(collisionRects) {
  const HB_OX = 4, HB_OY = 2, HB_W = player.w - 8, HB_H = player.h - 4;

  for (let iter = 0; iter < 4; iter++) {
    let pushed = false;
    const hx = player.x + HB_OX;
    const hy = player.y + HB_OY;

    for (const r of collisionRects) {
      if (!rectsOverlap(hx, hy, HB_W, HB_H, r.x, r.y, r.w, r.h)) continue;

      // Compute minimum penetration vector
      const overlapLeft = (hx + HB_W) - r.x;
      const overlapRight = (r.x + r.w) - hx;
      const overlapTop = (hy + HB_H) - r.y;
      const overlapBottom = (r.y + r.h) - hy;

      const minX = overlapLeft < overlapRight ? -overlapLeft : overlapRight;
      const minY = overlapTop < overlapBottom ? -overlapTop : overlapBottom;

      // Lip corner forgiveness: if overlapping a lip rect and the horizontal
      // overlap is within the forgiveness margin, always push sideways so the
      // player can clear the lip corner instead of being pushed down.
      // Also apply head-center rule: if head center doesn't overlap lip, force sideways.
      const isLip = r.type === 'pipe_lip' || r.type === 'ceiling_pipe_lip';
      const horizOverlap = Math.min(overlapLeft, overlapRight);
      let forceSideways = isLip && player.vy < 0 && horizOverlap <= LIP_CORNER_FORGIVE;
      // Head-center rule for depenetration
      if (isLip && player.vy < 0 && !forceSideways) {
        const headCW = (player.w - 8) * HEAD_CENTER_RATIO;
        const headCL = hx + ((player.w - 8) - headCW) / 2;
        const headCR = headCL + headCW;
        if (!(headCR > r.x && headCL < r.x + r.w)) {
          forceSideways = true;
        }
      }
      if (forceSideways) {
        // Verify sideways push won't create a new overlap with another rect
        const testHX = player.x + minX + HB_OX;
        let sidewaysBlocked = false;
        for (const cr of collisionRects) {
          if (cr === r) continue;
          if (rectsOverlap(testHX, hy, HB_W, HB_H, cr.x, cr.y, cr.w, cr.h)) {
            sidewaysBlocked = true;
            break;
          }
        }
        if (sidewaysBlocked) {
          forceSideways = false; // fall through to normal min-axis push
        } else {
          edgeDebugMsgs.push({ text: 'EDGE-FORGIVE', ttl: 90 });
        }
      }

      if (forceSideways || Math.abs(minX) < Math.abs(minY)) {
        // Verify the push direction won't create a new overlap
        const testX = player.x + minX + HB_OX;
        let xBlocked = false;
        for (const cr of collisionRects) {
          if (cr === r) continue;
          if (rectsOverlap(testX, hy, HB_W, HB_H, cr.x, cr.y, cr.w, cr.h)) {
            xBlocked = true;
            break;
          }
        }
        if (xBlocked && !forceSideways) {
          // X push blocked, try Y push instead
          player.y += minY;
          if (minY < 0 && player.vy > 0 && !justJumped) {
            player.vy = 0;
            player.onGround = true;
          }
          if (minY > 0 && player.vy < 0) {
            player.vy = 0;
          }
        } else {
          player.x += minX;
        }
      } else {
        player.y += minY;
        if (minY < 0 && player.vy > 0 && !justJumped) {
          // Pushed up = landed on surface (skip if just jumped to preserve airborne state)
          player.vy = 0;
          player.onGround = true;
        }
        if (minY > 0 && player.vy < 0) {
          // Pushed down = hit ceiling
          player.vy = 0;
        }
      }
      pushed = true;
    }
    if (!pushed) break;
  }
}

// ── Main Swept Movement Resolver ────────────────────────
// Resolves player movement for one frame using iterative swept AABB.
//
// Parameters:
//   playerVY: vertical velocity (pixels/frame, after gravity)
//   playerDX: horizontal displacement this frame (from manual input)
//
// After resolving, updates player.x, player.y, player.vy, player.onGround.
// Returns { hitBricks: [...], landedThisFrame, hitCeilingThisFrame }.
function resolveSweptMovement(playerVY, playerDX) {
  const HB_OX = 4, HB_OY = 2, HB_W = player.w - 8, HB_H = player.h - 4;

  // Manual movement: player moves by (playerDX, playerVY) in world coords.
  // Obstacles are static. No frame conversion needed at the end.

  let relDX = playerDX;
  let relDY = playerVY;

  // Gather obstacles
  const collisionRects = gatherCollisionRects();

  // Depenetrate first
  depenetratePlayer(collisionRects);

  let hitBricks = [];
  let remainingT = 1.0;
  let landedThisFrame = false;
  let hitCeilingThisFrame = false;

  for (let iter = 0; iter < SWEEP_MAX_ITERATIONS && remainingT > SWEEP_EPSILON; iter++) {
    const moveDX = relDX * remainingT;
    const moveDY = relDY * remainingT;

    if (Math.abs(moveDX) < SWEEP_EPSILON && Math.abs(moveDY) < SWEEP_EPSILON) break;

    // Current hitbox position
    const hx = player.x + HB_OX;
    const hy = player.y + HB_OY;

    // Find earliest collision among all obstacles
    let bestT = 1.0;
    let bestNX = 0, bestNY = 0;
    let bestRect = null;

    for (const r of collisionRects) {
      const result = sweptAABB(hx, hy, HB_W, HB_H, moveDX, moveDY, r.x, r.y, r.w, r.h);
      if (result.t < bestT - SWEEP_EPSILON) {
        bestT = result.t;
        bestNX = result.normalX;
        bestNY = result.normalY;
        bestRect = r;
      } else if (Math.abs(result.t - bestT) < SWEEP_EPSILON && result.t < 1.0) {
        // Same time — prefer the collision that blocks the most relevant axis
        // (vertical collisions take priority for landing/ceiling)
        if (result.normalY !== 0 && bestNY === 0) {
          bestNX = result.normalX;
          bestNY = result.normalY;
          bestRect = r;
        }
      }
    }

    // Move player to the contact point (with tiny epsilon pullback to avoid overlap)
    const safeT = Math.max(0, bestT - SWEEP_EPSILON);
    player.x += moveDX * safeT;
    player.y += moveDY * safeT;

    if (bestT >= 1.0 - SWEEP_EPSILON) {
      // No collision in remaining movement — done
      break;
    }

    // ── Collision response ──────────────────────────────
    // Resolve normal velocity and redirect remaining time on tangent

    if (bestNY === -1) {
      // Hit top of obstacle (landed on surface)
      // If justJumped is true, the player initiated a jump this frame and is
      // still touching the surface they jumped from — skip re-grounding so
      // the airborne state is preserved for double jump eligibility.
      if (!justJumped) {
        landedThisFrame = true;
        relDY = 0;
        player.vy = 0;
        player.onGround = true;
      }
    } else if (bestNY === 1) {
      // Hit bottom of obstacle (ceiling/brick from below)

      // ── Lip Corner Forgiveness (enhanced) ──────────────
      // When player jumps upward beside a pipe and clips the lip overhang
      // corner, nudge them sideways instead of blocking the jump.
      // Now with wider margin (LIP_CORNER_FORGIVE=14) and only while ascending.
      const isLipRect = bestRect && (bestRect.type === 'pipe_lip' || bestRect.type === 'ceiling_pipe_lip');
      if (isLipRect && playerVY < 0) {
        const hx = player.x + HB_OX;
        const lipLeft = bestRect.x;
        const lipRight = bestRect.x + bestRect.w;
        const playerLeft = hx;
        const playerRight = hx + HB_W;

        // How much the player overlaps into the lip on each side
        const overlapFromLeft = playerRight - lipLeft;   // player's right edge past lip's left
        const overlapFromRight = lipRight - playerLeft;  // lip's right edge past player's left

        // Determine which side has the smaller overlap (= which corner was clipped)
        const minOverlap = Math.min(overlapFromLeft, overlapFromRight);

        // ── Head-Center Rule ──────────────────────────────
        // Only count as a true ceiling bonk if the player's head center
        // region overlaps the lip top edge. Edge brushes → side deflection.
        const headCenterW = HB_W * HEAD_CENTER_RATIO;
        const headCenterLeft = hx + (HB_W - headCenterW) / 2;
        const headCenterRight = headCenterLeft + headCenterW;
        const headCenterOverlaps = headCenterRight > lipLeft && headCenterLeft < lipRight;

        if (minOverlap > 0 && (minOverlap <= LIP_CORNER_FORGIVE || !headCenterOverlaps)) {
          // Corner clip or head-center miss — nudge player sideways to clear the lip
          // But ONLY if the nudge doesn't push into another obstacle.
          let nudgeDX;
          if (overlapFromLeft < overlapFromRight) {
            nudgeDX = -(overlapFromLeft + 0.5);
          } else {
            nudgeDX = overlapFromRight + 0.5;
          }
          // Safety: verify the nudged position doesn't overlap any other rect
          const nudgedHX = player.x + nudgeDX + HB_OX;
          let nudgeBlocked = false;
          for (const cr of collisionRects) {
            if (cr === bestRect) continue;
            if (rectsOverlap(nudgedHX, player.y + HB_OY, HB_W, HB_H, cr.x, cr.y, cr.w, cr.h)) {
              nudgeBlocked = true;
              break;
            }
          }
          if (!nudgeBlocked) {
            player.x += nudgeDX;
            // Do NOT stop the jump — let upward motion continue
            edgeDebugMsgs.push({ text: 'EDGE-FORGIVE', ttl: 90 });
            remainingT *= (1.0 - bestT);
            continue;
          }
          // If nudge is blocked, fall through to normal ceiling hit handling
        }
      }

      hitCeilingThisFrame = true;

      // Check if we hit a brick from below (player moving up)
      if (bestRect && bestRect.type === 'brick' && bestRect.brickRef && playerVY < 0) {
        const brick = bestRect.brickRef;
        if (brick.question && !brick.used) {
          // ── Question Block: pop coin, mark used, keep block solid ──
          brick.used = true;
          brick.bumpTimer = BLOCK_BUMP_FRAMES;  // start bump animation
          coins++;
          check1UP();
          score += COIN_SCORE;
          // Coin combo: track rapid hits for pitch-rising SFX
          coinComboLevel = (coinComboTimer > 0) ? coinComboLevel + 1 : 0;
          coinComboTimer = COIN_COMBO_WINDOW;
          sfxCoinPop(coinComboLevel);
          spawnCoinPop(brick.x + BRICK_W / 2 - 4, brick.y);
          spawnScorePopup(brick.x + BRICK_W / 2 - 8, brick.y - 5, COIN_SCORE);
          triggerCombo(COIN_SCORE);
          // Coin Rush chain
          coinRushChain = (coinRushWindowTimer > 0) ? (coinRushChain + 1) : 1;
          coinRushWindowTimer = COIN_RUSH_WINDOW;
          if (coinRushChain >= COIN_RUSH_TARGET) {
            coinRushTimer = COIN_RUSH_DURATION;
            coinRushChain = 0;
            coinRushWindowTimer = 0;
            hudBoost.textContent = 'COIN RUSH! SPEED UP';
          }
          // Bounce down
          player.vy = Math.abs(player.vy) * 0.4;
          relDY = player.vy;
        } else if (!brick.broken && !brick.question) {
          // ── Normal / Special Brick: break as before ──
          brick.broken = true;
          hitBricks.push(brick);
          spawnBrickFragments(brick.x, brick.y);
          spawnScorePopup(brick.x + BRICK_W / 2 - 8, brick.y - 5, BRICK_SCORE);
          score += BRICK_SCORE;
          triggerCombo(BRICK_SCORE);
          advanceMission('break_bricks');
          // Coin Rush: treat each broken brick as a coin pickup for a small speed buff chain.
          coinRushChain = (coinRushWindowTimer > 0) ? (coinRushChain + 1) : 1;
          coinRushWindowTimer = COIN_RUSH_WINDOW;
          if (coinRushChain >= COIN_RUSH_TARGET) {
            coinRushTimer = COIN_RUSH_DURATION;
            coinRushChain = 0;
            coinRushWindowTimer = 0;
            hudBoost.textContent = 'COIN RUSH! SPEED UP';
          }
          // Time bonus: add seconds to survival timer
          bonusTime += BRICK_TIME_BONUS;
          if (DEBUG_MODE) {
            console.log(`%c[Brick] +${BRICK_TIME_BONUS}s bonus | total bonusTime=${bonusTime}s | survivalTime=${(frameCount / 60 + bonusTime).toFixed(1)}s`, 'color: #2ecc71');
          }
          spawnTimeBonusPopup(brick.x + BRICK_W / 2 - 12, brick.y - 20);
          // Special brick: spawn mushroom
          if (brick.special) {
            spawnMushroom(brick.x, brick.y);
          }
          // Bounce down
          player.vy = Math.abs(player.vy) * 0.4;
          relDY = player.vy;
          // Remove this rect from future iterations (brick is gone)
          const idx = collisionRects.indexOf(bestRect);
          if (idx >= 0) collisionRects.splice(idx, 1);
        }
      } else {
        // Hit solid ceiling — stop upward movement
        relDY = 0;
        player.vy = 0;
      }
    }

    if (bestNX === -1) {
      // Hit left face of obstacle (player moving right)
      relDX = 0;
      playerVX = 0;
    } else if (bestNX === 1) {
      // Hit right face of obstacle (player moving left)
      relDX = 0;
      playerVX = 0;
    }

    // Consume the used time fraction
    remainingT *= (1.0 - bestT);
  }

  // Manual movement: displacement is the player's own movement.
  // No frame conversion needed (obstacles are static in world coords).

  return { hitBricks, landedThisFrame, hitCeilingThisFrame };
}

// Check if player is standing on any pipe top or brick top. Returns standY or null.
// Used for edge-fall-off detection after movement resolves.
function checkStandingSupport() {
  const pb = getPlayerHitbox();
  const feetY = pb.y + pb.h;
  const groundY = DESIGN_H - GROUND_H;

  // On ground?
  if (Math.abs(feetY - groundY) < 2) return groundY;

  for (const pipe of pipes) {
    if (pipe.fromTop) continue;
    const rects = getPipeRects(pipe);
    const standY = rects.standY;
    if (standY === null) continue;
    // Feet at or very close to the surface, and horizontally overlapping lip
    if (Math.abs(feetY - standY) < 3 &&
        pb.x + pb.w > pipe.x + 4 && pb.x < pipe.x + LIP_W - 4) {
      return standY;
    }
  }

  for (const brick of bricks) {
    if (brick.broken) continue;
    if (brick.hidden && !brick.revealed) continue;
    if (Math.abs(feetY - brick.y) < 3 &&
        pb.x + pb.w > brick.x + 2 && pb.x < brick.x + brick.w - 2) {
      return brick.y;
    }
  }

  return null;
}

// Check if player is being crushed (squeezed between obstacles)
function checkCrush() {
  const pb = getPlayerHitbox();

  // 1) Crushed against left screen edge by pipe/brick pushing from right
  if (player.x <= cameraX) {
    for (const pipe of pipes) {
      const rects = getPipeRects(pipe);
      if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
          rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
          rectsOverlap(pb.x, pb.y, pb.w, pb.h,
          rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
        return true;
      }
    }
    for (const brick of bricks) {
      if (brick.broken) continue;
      if (brick.hidden && !brick.revealed) continue;
      if (rectsOverlap(pb.x, pb.y, pb.w, pb.h, brick.x, brick.y, brick.w, brick.h)) {
        return true;
      }
    }
  }

  // 2) Vertically crushed between bottom pipe/ground and top pipe/ceiling
  let floorY = DESIGN_H - GROUND_H;
  let ceilY = 0;

  for (const pipe of pipes) {
    const rects = getPipeRects(pipe);
    const horizOverlap = pb.x + pb.w > rects.lipRect.x + 4 &&
                         pb.x < rects.lipRect.x + rects.lipRect.w - 4;
    if (!horizOverlap) continue;

    if (!pipe.fromTop) {
      const pipeTop = rects.standY;
      if (pipeTop !== null && pipeTop < floorY) floorY = pipeTop;
    } else {
      const pipeBottom = pipe.h;
      if (pipeBottom > ceilY) ceilY = pipeBottom;
    }
  }

  const availableSpace = floorY - ceilY;
  if (availableSpace < pb.h - CRUSH_THRESHOLD) {
    if (pb.y + pb.h >= floorY - 2 && pb.y <= ceilY + 2) {
      return true;
    }
  }

  // 3) Head hitting ceiling pipe while standing on bottom pipe
  for (const topPipe of pipes) {
    if (!topPipe.fromTop) continue;
    const topRects = getPipeRects(topPipe);
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        topRects.lipRect.x, topRects.lipRect.y, topRects.lipRect.w, topRects.lipRect.h) ||
        rectsOverlap(pb.x, pb.y, pb.w, pb.h,
        topRects.bodyRect.x, topRects.bodyRect.y, topRects.bodyRect.w, topRects.bodyRect.h)) {
      if (player.onGround) return true;
    }
  }

  return false;
}

// ── Swept AABB Self-Test (debug=1 only) ─────────────────
// Simulates extreme velocity scenarios and asserts no penetration.
// Call via console: runCollisionSelfTest()
function runCollisionSelfTest() {
  const results = [];
  const HB_W = player.w - 8;
  const HB_H = player.h - 4;

  // Test 1: High-speed downward fall through a thin obstacle (brick 24px)
  {
    const obstacle = { x: 100, y: 200, w: 32, h: 24 };
    // Player hitbox bottom at py+HB_H=160+32=192, obstacle top at 200 → gap 8px
    // Falling at 50 px/frame (extreme) — must detect contact, not tunnel through
    const px = 105, py = 160, dx = 0, dy = 50;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const contactY = py + dy * r.t;
    const passed = r.t < 1 && r.normalY === -1 && (contactY + HB_H) <= obstacle.y + 1;
    results.push({ name: 'Downward 50px/f through 24px brick', t: r.t, normalY: r.normalY, contactY, passed });
  }

  // Test 2: High-speed upward through brick bottom
  {
    const obstacle = { x: 100, y: 200, w: 32, h: 24 };
    const px = 105, py = 280, dx = 0, dy = -60;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const contactY = py + dy * r.t;
    const passed = r.t < 1 && r.normalY === 1 && contactY >= obstacle.y + obstacle.h - 1;
    results.push({ name: 'Upward 60px/f through 24px brick', t: r.t, normalY: r.normalY, contactY, passed });
  }

  // Test 3: High-speed horizontal through pipe body (48px wide)
  {
    const obstacle = { x: 300, y: 100, w: 48, h: 200 };
    const px = 100, py = 150, dx = 250, dy = 0;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const contactX = px + dx * r.t;
    const passed = r.t < 1 && r.normalX === -1 && (contactX + HB_W) <= obstacle.x + 1;
    results.push({ name: 'Horizontal 250px/f through 48px pipe', t: r.t, normalX: r.normalX, contactX, passed });
  }

  // Test 4: Diagonal high-speed through thin lip (16px)
  {
    const obstacle = { x: 200, y: 250, w: 56, h: 16 };
    const px = 150, py = 200, dx = 80, dy = 40;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const passed = r.t < 1; // must detect collision
    results.push({ name: 'Diagonal 80,40 px/f through 16px lip', t: r.t, passed });
  }

  // Test 5: Verify no false positive (moving away from obstacle)
  {
    const obstacle = { x: 300, y: 100, w: 48, h: 200 };
    const px = 100, py = 150, dx = -50, dy = 0;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const passed = r.t >= 1; // should NOT collide
    results.push({ name: 'Moving away — no false positive', t: r.t, passed });
  }

  // Test 6: Scroll-induced collision (obstacle moves into player at high speed)
  {
    const obstacle = { x: 130, y: 200, w: 56, h: 100 };
    // Player at x=100, obstacle approaches from right. In relative frame,
    // player moves right by scrollDX=20 toward obstacle.
    const px = 100, py = 220, dx = 20, dy = 0;
    const r = sweptAABB(px, py, HB_W, HB_H, dx, dy, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
    const passed = r.t < 1 && r.normalX === -1;
    results.push({ name: 'Scroll-induced horizontal collision', t: r.t, normalX: r.normalX, passed });
  }

  // Test 7: Full movement resolver — extreme fall with obstacles below
  {
    // Save state
    const savedX = player.x, savedY = player.y, savedVY = player.vy;
    const savedOnGround = player.onGround;
    const savedPipes = [...pipes];
    const savedBricks = [...bricks];

    // Set up scenario: player close above pipe, extreme downward velocity
    // Pipe top (standY) = DESIGN_H - GROUND_H - 120 = 220
    // Player hitbox bottom = player.y + 2 + (player.h - 4) = player.y + 34
    // Set player.y = 190 → hitbox bottom = 224, just 4px below pipe top at 220
    // Actually we want player ABOVE pipe: hitbox bottom < 220
    // player.y = 180 → hitbox bottom = 214, gap = 6px, vy = 80 → easily reaches
    player.x = 100;
    player.y = 180;
    player.vy = 80; // extreme fall speed
    player.onGround = false;
    pipes = [{ x: 96, h: 120, fromTop: false, scored: false }];
    bricks = [];

    const groundY = DESIGN_H - GROUND_H;
    const pipeTopY = groundY - 120;
    resolveSweptMovement(80, 0);

    const pb = getPlayerHitbox();
    const feetY = pb.y + pb.h;
    const penetrated = feetY > pipeTopY + 3;
    results.push({ name: 'Resolver: 80px/f fall onto pipe', feetY: feetY.toFixed(1), pipeTop: pipeTopY, penetrated: penetrated, passed: !penetrated });

    // Restore state
    player.x = savedX; player.y = savedY; player.vy = savedVY;
    player.onGround = savedOnGround;
    pipes = savedPipes;
    bricks = savedBricks;
  }

  // Test 8: Large horizontal shift must not penetrate pipe
  // Simulates player at x=250, pipe body at x=270, tries to push
  // player forward via collisionSafeMoveX — must stop before pipe.
  {
    const savedX = player.x, savedY = player.y, savedVY = player.vy;
    const savedOnGround = player.onGround;
    const savedPipes = [...pipes];
    const savedBricks = [...bricks];

    const groundY = DESIGN_H - GROUND_H;
    player.x = 250;
    player.y = groundY - player.h; // standing on ground
    player.vy = 0;
    player.onGround = true;
    // Pipe right next to player — body starts at x=270
    pipes = [{ x: 270, h: 100, fromTop: false, scored: false }];
    bricks = [];

    // Try to move forward by 80px (extreme shift)
    const actualDX = collisionSafeMoveX(80);
    const pb = getPlayerHitbox();
    const pipeRects = getPipeRects(pipes[0]);
    const bodyLeft = pipeRects.bodyRect.x;
    const hbRight = pb.x + pb.w;
    const penetrated = hbRight > bodyLeft + 1;
    results.push({
      name: '80px shift blocked by pipe',
      playerRight: hbRight.toFixed(1),
      pipeBodyLeft: bodyLeft,
      actualDX: actualDX.toFixed(1),
      penetrated,
      passed: !penetrated
    });

    player.x = savedX; player.y = savedY; player.vy = savedVY;
    player.onGround = savedOnGround;
    pipes = savedPipes;
    bricks = savedBricks;
  }

  // Test 9: Repeated horizontal collisions (keep pushing toward same pipe)
  {
    const savedX = player.x, savedY = player.y, savedVY = player.vy;
    const savedOnGround = player.onGround;
    const savedPipes = [...pipes];
    const savedBricks = [...bricks];

    const groundY = DESIGN_H - GROUND_H;
    player.y = groundY - player.h;
    player.vy = 0;
    player.onGround = true;
    pipes = [{ x: 300, h: 100, fromTop: false, scored: false }];
    bricks = [];

    let everPenetrated = false;
    // Simulate 60 frames of pushing toward pipe
    for (let i = 0; i < 60; i++) {
      player.x = 250 + i * 2; // approach pipe from left
      if (player.x > 350) player.x = 350; // cap beyond pipe
      collisionSafeMoveX(10); // try to push forward 10px each frame
      const pb = getPlayerHitbox();
      const pipeRects = getPipeRects(pipes[0]);
      if (pb.x + pb.w > pipeRects.bodyRect.x + 1) {
        everPenetrated = true;
        break;
      }
    }
    results.push({
      name: '60-frame repeated pipe collision',
      penetrated: everPenetrated,
      passed: !everPenetrated
    });

    player.x = savedX; player.y = savedY; player.vy = savedVY;
    player.onGround = savedOnGround;
    pipes = savedPipes;
    bricks = savedBricks;
  }

  // Print results
  let allPassed = true;
  console.log('%c=== Swept AABB Collision Self-Test ===', 'color: #42d4f4; font-weight: bold');
  for (const r of results) {
    const icon = r.passed ? '\u2705' : '\u274c';
    console.log(`${icon} ${r.name}`, r);
    if (!r.passed) allPassed = false;
  }
  console.log(allPassed
    ? '%c\u2705 ALL TESTS PASSED — no penetration detected'
    : '%c\u274c SOME TESTS FAILED — check results above',
    `color: ${allPassed ? '#2ecc71' : '#e74c3c'}; font-weight: bold`);

  return { allPassed, results };
}

// ── Fun Pack v1: Combo Helpers ───────────────────────
function triggerCombo(eventScore) {
  comboCount = Math.min(comboCount + 1, COMBO_MAX);
  comboTimer = COMBO_WINDOW;
  const bonus = eventScore * comboCount;
  score += bonus;
  comboPopupText = comboCount >= 2 ? `COMBO x${comboCount}! +${bonus}` : '';
  comboPopupTimer = comboCount >= 2 ? COMBO_POPUP_DURATION : 0;
  if (comboCount >= 2) {
    spawnScorePopup(player.x, player.y - 20, bonus);
  }
  return bonus;
}

function resetCombo() {
  comboCount = 0;
  comboTimer = 0;
  comboPopupTimer = 0;
}

// ── Fun Pack v1: Speed Wave ─────────────────────────
function getSpeedWaveFactor() {
  // Smooth sin wave; amplitude decays slightly at early game for gentle intro
  const introFade = Math.min(1, survivalTime / 30); // ramp in over first 30s
  return 1.0 + Math.sin(speedWavePhase) * SPEED_WAVE_AMP * introFade;
}

// ── Fun Pack v1: Mission System ─────────────────────
const MISSION_DEFS = [
  { type: 'break_bricks',   desc: '30s 内破 3 磚', target: 3, timeLimit: 30 },
  { type: 'eat_mushroom',   desc: '吃到 1 顆香菇',  target: 1, timeLimit: 0  },
  { type: 'land_platforms', desc: '連續站上 2 個平台', target: 2, timeLimit: 0  },
];

function initMission() {
  const def = MISSION_DEFS[Math.floor(Math.random() * MISSION_DEFS.length)];
  mission = {
    type: def.type,
    desc: def.desc,
    target: def.target,
    progress: 0,
    done: false,
    startTime: 0, // set when game starts
    timeLimit: def.timeLimit,
  };
  missionCompleteTimer = 0;
  missionPlatformLandCount = 0;
}

function advanceMission(eventType) {
  if (!mission || mission.done) return;
  // Check time limit for timed missions
  if (mission.timeLimit > 0 && survivalTime - mission.startTime > mission.timeLimit) {
    return; // expired, no more progress possible (but we don't fail, just can't complete)
  }
  if (mission.type === eventType) {
    mission.progress = Math.min(mission.progress + 1, mission.target);
    if (mission.progress >= mission.target) {
      mission.done = true;
      missionCompleteTimer = MISSION_COMPLETE_DISPLAY;
      score += MISSION_REWARD_SCORE;
      spawnScorePopup(player.x, player.y - 30, MISSION_REWARD_SCORE);
    }
  }
}

// ── Fun Pack v2: Boss Wave Logic ───────────────────────
function startBossWave() {
  bossWaveActive = true;
  bossWaveTimer = BOSS_WAVE_DURATION;
  bossWaveCount++;
  bossWaveCleared = false;
  bossWaveStepCounter = 0;
  bossCountdownLastSec = -1; // reset countdown beep tracker
  // Alternate modes: odd waves = A, even waves = B (or random)
  bossWaveMode = (bossWaveCount % 2 === 1) ? 'A' : 'B';
  // Set next trigger time (from when the wave ENDS, not starts)
  bossWaveNextTrigger = survivalTime + BOSS_WAVE_DURATION + BOSS_WAVE_INTERVAL;
  // Fun Pack v2.1: Boss start audio + haptics
  sfxBossStart();
  vibBossStart();
}

function endBossWave() {
  bossWaveActive = false;
  bossWaveTimer = 0;
  if (!bossWaveCleared) {
    // Player survived — give reward
    bossWaveCleared = true;
    bossWaveClearTimer = 120; // 2 seconds at 60fps
    score += BOSS_WAVE_REWARD_SCORE;
    spawnScorePopup(player.x, player.y - 30, BOSS_WAVE_REWARD_SCORE);
    // Fun Pack v2.1: Boss clear audio + haptics
    sfxBossClear();
    vibBossClear();
  }
}

// Mode A: Dense low obstacles — rhythm jumping challenge
// Spawns a series of short bottom pipes at tight intervals
function spawnBossWaveObstacleA() {
  // Low pipes: heights 50-80px — easy to jump over individually but need rhythm
  const h = 50 + Math.floor(Math.random() * 30);
  pipes.push({ x: bossWaveSpawnX, h: h, fromTop: false, scored: false });
}

// Mode B: High-low alternating obstacles with platform bricks
// Mix of tall bottom pipes, short ceiling pipes, and helpful bricks
function spawnBossWaveObstacleB() {
  const groundY = DESIGN_H - GROUND_H;
  const step = bossWaveStepCounter % 3;

  if (step === 0) {
    // Tall bottom pipe (needs jump)
    const h = 90 + Math.floor(Math.random() * 40); // 90-130px
    pipes.push({ x: bossWaveSpawnX, h: h, fromTop: false, scored: false });
  } else if (step === 1) {
    // Short ceiling pipe + a helpful brick to stand on or break
    const topH = 60 + Math.floor(Math.random() * 30); // 60-90px ceiling
    pipes.push({ x: bossWaveSpawnX, h: topH, fromTop: true, scored: false });
    // Place a brick at a useful jump height
    const brickTopY = groundY - (80 + Math.floor(Math.random() * 25)); // 80-105px above ground
    bricks.push(makeBrick(bossWaveSpawnX - 20 + Math.floor(Math.random() * 40), brickTopY, 0.3));
  } else {
    // Gap with a brick platform at mid height — breathing room + reward
    const brickTopY = groundY - (90 + Math.floor(Math.random() * 30)); // 90-120px
    bricks.push(makeBrick(bossWaveSpawnX, brickTopY, 0.4));
    // Add a small marker pipe so scoring/spawn tracking continues
    pipes.push({ x: bossWaveSpawnX, h: 0, fromTop: false, scored: false });
  }
}

function spawnBossWaveObstacle() {
  if (bossWaveMode === 'A') {
    spawnBossWaveObstacleA();
  } else {
    spawnBossWaveObstacleB();
  }
  bossWaveStepCounter++;
}

// ── Game Logic ─────────────────────────────────────────
let groundOffset = 0;

function resetGame() {
  player.y = DESIGN_H - GROUND_H - player.h;
  player.x = RECENTER_TARGET_X;
  player.vy = 0;
  player.onGround = true;
  player.frame = 0;
  player.animState = 'idle';
  player.landTimer = 0;
  player.wasOnGround = true;
  pipes = [];
  bricks = [];
  fragments = [];
  hintSparks = [];
  hintSparkTimer = 0;
  scorePopups = [];
  milestonePipeCount = 0;
  timeBonusPopups = [];
  mushrooms = [];
  turtles = [];
  lastTurtleSpawnX = -9999;
  spawnRhythmBase = cameraX;
  score = 0;
  coins = 0;
  lives = INITIAL_LIVES;
  coinPops = [];
  coinComboLevel = 0;
  coinComboTimer = 0;
  frameCount = 0;
  survivalTime = 0;
  bonusTime = 0;
  doubleJumpTimer = 0;
  airJumpsUsed = 0;
  isAirJump = false;
  diffLevel = 0;
  diffProgress = 0;
  scrollSpeed = 0;
  groundOffset = 0;
  jumpHoldFrames = 0;
  jumpConsumed = false;
  coyoteFrames = 0;
  justJumped = false;
  wallNudgeUsed = false;
  moveLeftPressed = false;
  moveRightPressed = false;
  playerVX = 0;
  playerBraking = false;
  brakeTimer = 0;
  cameraX = 0;
  edgeDebugMsgs = [];
  depenFixCount = 0;
  // Fun Pack v1 resets
  resetCombo();
  coinRushWindowTimer = 0;
  coinRushChain = 0;
  coinRushTimer = 0;
  speedWavePhase = 0;
  initMission();
  mission.startTime = 0;
  missionCompleteTimer = 0;
  missionPlatformLandCount = 0;
  // Fun Pack v2 resets
  bossWaveActive = false;
  bossWaveTimer = 0;
  bossWaveCount = 0;
  bossWaveMode = 'A';
  bossWaveCleared = false;
  bossWaveClearTimer = 0;
  bossWaveSpawnX = 0;
  bossWaveStepCounter = 0;
  bossWaveNextTrigger = BOSS_WAVE_INTERVAL;
  bossCountdownLastSec = -1;
  // Flagpole / level clear reset
  levelCleared = false;
  levelClearTimer = 0;
  levelClearPhase = 'none';
  flagpoleX = FLAGPOLE_DISTANCE;
  initClouds();
  initHills();
  // Seed initial chunks (replaces old spawnInitialPipes)
  spawnInitialChunks();
}

function spawnInitialPipes() {
  const x = cameraX + DESIGN_W + 100;
  // Bottom pipe
  pipes.push({
    x: x,
    h: PIPE_HEIGHTS_BOTTOM[Math.floor(Math.random() * PIPE_HEIGHTS_BOTTOM.length)],
    fromTop: false,
    scored: false,
  });
}

// Get smoothly interpolated difficulty parameter at current survival time
function getDiffParam(key) {
  const levels = DIFFICULTY_LEVELS;
  const t = survivalTime;
  // Find which two levels we're between
  for (let i = levels.length - 1; i >= 0; i--) {
    if (t >= levels[i].time) {
      if (i === levels.length - 1) return levels[i][key]; // at max level
      const curr = levels[i];
      const next = levels[i + 1];
      const frac = (t - curr.time) / (next.time - curr.time);
      // Smooth step for less jarring transitions
      const s = frac * frac * (3 - 2 * frac);
      return curr[key] + (next[key] - curr[key]) * s;
    }
  }
  return levels[0][key];
}

function updateDifficultyInfo() {
  const levels = DIFFICULTY_LEVELS;
  const t = survivalTime;
  for (let i = levels.length - 1; i >= 0; i--) {
    if (t >= levels[i].time) {
      diffLevel = i;
      if (i < levels.length - 1) {
        diffProgress = (t - levels[i].time) / (levels[i + 1].time - levels[i].time);
      } else {
        diffProgress = 1;
      }
      break;
    }
  }
}

// Check if the last few bottom pipes already provide a staircase for a tall target
function needsStaircase(targetH) {
  if (targetH < TALL_PIPE_THRESHOLD) return false;
  // Look at recent bottom pipes (last 2) — if any is a mid-height step, no staircase needed
  const recentBottom = pipes.filter(p => !p.fromTop).slice(-2);
  for (const p of recentBottom) {
    if (p.h >= 60 && p.h < targetH - 20) return false; // already has a step
  }
  return true;
}

// Spawn staircase pipes before a tall bottom pipe
function spawnStaircaseFor(targetH, targetX, gapMin, gapMax) {
  // Create 1-2 stepping-stone pipes leading up to the tall one
  const steps = targetH >= 200 ? 2 : 1;
  let curX = targetX;
  const stepHeights = [];
  for (let i = steps; i >= 1; i--) {
    // Each step is roughly (i / (steps+1)) of the target height, with some variance
    const ratio = i / (steps + 1);
    const baseH = Math.round(targetH * ratio);
    const h = Math.max(50, Math.min(baseH + Math.floor(Math.random() * 20 - 10), targetH - 30));
    stepHeights.unshift(h);
  }
  // Place steps before the target, working backwards
  for (let i = stepHeights.length - 1; i >= 0; i--) {
    const stepGap = gapMin * 0.7 + Math.random() * (gapMax - gapMin) * 0.4;
    curX -= stepGap;
    pipes.push({
      x: curX,
      h: stepHeights[i],
      fromTop: false,
      scored: false,
    });
  }
  return curX; // returns leftmost step X so we know where steps start
}

// Spawn stepping-stone bricks before a bottom pipe
// Bricks are placed 40~140px to the LEFT of the pipe, at heights that help
// the player reach the pipe top via small or large jumps.
// Tall pipes (>= TALL_PIPE_THRESHOLD) always get bricks; shorter pipes have a random chance.
function maybeSpawnSteppingStoneBricks(pipeX, pipeH, hasCeiling) {
  if (hasCeiling) return; // don't spawn bricks under ceiling pipes
  const groundY = DESIGN_H - GROUND_H;
  const pipeTopY = groundY - pipeH;

  // Tall pipes always get stepping stones; shorter pipes use BRICK_SPAWN_CHANCE
  const isTall = pipeH >= TALL_PIPE_THRESHOLD;
  if (!isTall && Math.random() > BRICK_SPAWN_CHANCE) return;

  // Decide 1 or 2 bricks: tall pipes get 2, shorter pipes get 1
  const brickCount = (isTall && pipeH >= 180) ? 2 : 1;

  // Player physics reference:
  // Small jump apex from ground ≈ 45px above ground (JUMP_INITIAL^2 / (2*GRAVITY))
  // Full jump apex from ground ≈ 130px above ground (with hold boost)
  // Ground surface Y = groundY (DESIGN_H - GROUND_H)
  // Player stands at groundY - player.h (36)

  for (let i = 0; i < brickCount; i++) {
    // Horizontal distance: 40~140px before the pipe
    // For 2 bricks, spread them: first one farther, second one closer
    let horizDist;
    if (brickCount === 2) {
      horizDist = (i === 0)
        ? 100 + Math.random() * 40   // farther brick: 100~140px
        : 40 + Math.random() * 40;   // closer brick: 40~80px
    } else {
      horizDist = 40 + Math.random() * 100; // single brick: 40~140px
    }
    const brickX = pipeX - horizDist;

    // Vertical placement: brick top is a stepping height
    // For single or first brick: reachable from ground via small jump
    //   Place brick surface at roughly 30~60px above ground
    // For second (closer) brick: higher, bridging to pipe top
    //   Place brick surface at roughly 50~80% of pipe height
    let brickTopY;
    if (brickCount === 2 && i === 1) {
      // Higher stepping stone — between 40% and 65% of pipe height off ground
      const ratio = 0.40 + Math.random() * 0.25;
      brickTopY = groundY - Math.round(pipeH * ratio);
    } else {
      // Lower stepping stone — reachable from ground with a jump
      // Must be at least BRICK_MIN_HEIGHT_ABOVE_GROUND (72px) above ground
      const stepH = BRICK_MIN_HEIGHT_ABOVE_GROUND + Math.random() * 20; // 72~92px
      brickTopY = groundY - stepH;
    }

    // Clamp: don't place too high (above screen) or too low
    // Brick top must be at least BRICK_MIN_HEIGHT_ABOVE_GROUND above ground
    brickTopY = Math.max(30, Math.min(brickTopY, groundY - BRICK_MIN_HEIGHT_ABOVE_GROUND));

    // Prevent overlapping with existing pipes
    const brickRight = brickX + BRICK_W;
    const brickBottom = brickTopY + BRICK_H;
    let overlaps = false;
    for (const pipe of pipes) {
      const rects = getPipeRects(pipe);
      // Check against lip and body rects
      if (rectsOverlap(brickX, brickTopY, BRICK_W, BRICK_H,
          rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
          rectsOverlap(brickX, brickTopY, BRICK_W, BRICK_H,
          rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
        overlaps = true;
        break;
      }
      // Also ensure minimum 8px gap from pipe edges (no "touching")
      const lipR = rects.lipRect;
      if (Math.abs(brickX - (lipR.x + lipR.w)) < 8 || Math.abs(brickRight - lipR.x) < 8) {
        if (brickTopY < lipR.y + lipR.h && brickBottom > lipR.y) {
          overlaps = true;
          break;
        }
      }
    }

    // Also prevent overlapping with existing bricks
    if (!overlaps) {
      for (const existingBrick of bricks) {
        if (existingBrick.broken) continue;
        if (rectsOverlap(brickX, brickTopY, BRICK_W, BRICK_H,
            existingBrick.x - 8, existingBrick.y - 8,
            existingBrick.w + 16, existingBrick.h + 16)) {
          overlaps = true;
          break;
        }
      }
    }

    if (overlaps) continue; // skip this brick if overlapping

    bricks.push(makeBrick(brickX, brickTopY, SPECIAL_BRICK_CHANCE));
  }
}

// Spawn a standalone brick obstacle group (1~3 bricks) that replaces a pipe.
// Bricks are arranged as a small platforming challenge: low, mid, and optionally high.
// All heights are reachable via small/full jumps from ground or from other bricks.
function spawnStandaloneBricks(anchorX) {
  const groundY = DESIGN_H - GROUND_H;
  const count = STANDALONE_BRICK_MIN_COUNT +
    Math.floor(Math.random() * (STANDALONE_BRICK_MAX_COUNT - STANDALONE_BRICK_MIN_COUNT + 1));

  // Predefined height tiers (top-of-brick Y measured from groundY upward)
  // All tiers respect BRICK_MIN_HEIGHT_ABOVE_GROUND (72px = 2× player height)
  // Low: 72–95 px above ground — reachable with jump
  // Mid: 100–130 px above ground — reachable with medium hold
  // High: 135–165 px above ground — needs full jump
  const tiers = [
    { minH: BRICK_MIN_HEIGHT_ABOVE_GROUND, maxH: 95 },  // low
    { minH: 100, maxH: 130 },                            // mid
    { minH: 135, maxH: 165 },                            // high
  ];

  // Horizontal spread: bricks are spaced 35–55 px apart
  const startX = anchorX;

  for (let i = 0; i < count; i++) {
    const tier = tiers[i];
    const heightAboveGround = tier.minH + Math.random() * (tier.maxH - tier.minH);
    const brickTopY = groundY - heightAboveGround;
    const brickX = startX + i * (35 + Math.random() * 20);

    // Clamp within screen bounds; enforce minimum height above ground
    const clampedY = Math.max(30, Math.min(brickTopY, groundY - BRICK_MIN_HEIGHT_ABOVE_GROUND));

    // Prevent overlapping with existing bricks
    let overlaps = false;
    for (const existingBrick of bricks) {
      if (existingBrick.broken) continue;
      if (rectsOverlap(brickX, clampedY, BRICK_W, BRICK_H,
          existingBrick.x - 8, existingBrick.y - 8,
          existingBrick.w + 16, existingBrick.h + 16)) {
        overlaps = true;
        break;
      }
    }

    // Prevent overlapping with existing pipes
    if (!overlaps) {
      for (const pipe of pipes) {
        const rects = getPipeRects(pipe);
        if (rectsOverlap(brickX, clampedY, BRICK_W, BRICK_H,
            rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h) ||
            rectsOverlap(brickX, clampedY, BRICK_W, BRICK_H,
            rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h)) {
          overlaps = true;
          break;
        }
      }
    }

    if (overlaps) continue;

    bricks.push(makeBrick(brickX, clampedY, SPECIAL_BRICK_CHANCE));
  }
}

function spawnPipe() {
  const lastPipe = pipes[pipes.length - 1];
  const gapMin = getDiffParam('gapMin');
  const gapMax = getDiffParam('gapMax');
  const gap = gapMin + Math.random() * (gapMax - gapMin);
  const newX = lastPipe.x + gap;

  // ── Brick-replaces-pipe check ──────────────────────────
  const brickReplaceChance = getDiffParam('brickReplace');
  if (Math.random() < brickReplaceChance) {
    // Replace this pipe spawn with a standalone brick obstacle group
    spawnStandaloneBricks(newX);
    // Add a tiny invisible ground-level "marker pipe" so the spawn/score
    // system keeps tracking position (h=0 is invisible, scored normally)
    pipes.push({ x: newX, h: 0, fromTop: false, scored: false });
    return;
  }

  const pipeMaxH = getDiffParam('pipeMaxH');
  const topMaxH = getDiffParam('topMaxH');
  const pairChance = getDiffParam('pairChance');

  // Build height pools dynamically based on current difficulty
  const bottomHeights = PIPE_HEIGHTS_BOTTOM.filter(h => h <= pipeMaxH);
  if (pipeMaxH >= 170) bottomHeights.push(170);
  if (pipeMaxH >= 195) bottomHeights.push(195);
  if (pipeMaxH >= 220) bottomHeights.push(220);
  if (pipeMaxH >= 240) bottomHeights.push(240);

  const topHeights = PIPE_HEIGHTS_TOP.filter(h => h <= topMaxH);
  if (topMaxH >= 155) topHeights.push(155);
  if (topMaxH >= 170) topHeights.push(170);
  if (topMaxH >= 190) topHeights.push(190);
  if (topMaxH >= 200) topHeights.push(200);

  // Decide what to spawn
  const roll = Math.random();
  const topOnlyChance = 0.20;
  const bottomOnlyChance = 1 - topOnlyChance - pairChance;

  if (roll < bottomOnlyChance) {
    // Bottom pipe only
    const h = bottomHeights[Math.floor(Math.random() * bottomHeights.length)];
    // Staircase: if this pipe is tall and no recent step exists, insert stepping pipes
    if (needsStaircase(h)) {
      spawnStaircaseFor(h, newX, gapMin, gapMax);
    }
    pipes.push({ x: newX, h, fromTop: false, scored: false });
    // Maybe spawn stepping-stone bricks before this pipe
    maybeSpawnSteppingStoneBricks(newX, h, false);
  } else if (roll < bottomOnlyChance + topOnlyChance) {
    // Top pipe only
    pipes.push({
      x: newX,
      h: topHeights[Math.floor(Math.random() * topHeights.length)],
      fromTop: true,
      scored: false,
    });
  } else {
    // Both top and bottom — create a passable gap
    const groundY = DESIGN_H - GROUND_H;
    const bottomH = bottomHeights[Math.floor(Math.random() * bottomHeights.length)];
    // Staircase for tall bottom in pair
    if (needsStaircase(bottomH)) {
      spawnStaircaseFor(bottomH, newX, gapMin, gapMax);
    }
    const bottomTopY = groundY - bottomH;
    const diffFrac = Math.min(survivalTime / DIFFICULTY_LEVELS[DIFFICULTY_LEVELS.length - 1].time, 1);
    const minGapSize = player.h + 30 + (1 - diffFrac) * 30;
    const maxTopH = bottomTopY - minGapSize;
    if (maxTopH >= 50) {
      const topH = 50 + Math.floor(Math.random() * (Math.min(maxTopH, topMaxH) - 50));
      pipes.push({ x: newX, h: bottomH, fromTop: false, scored: false });
      pipes.push({ x: newX, h: Math.max(50, topH), fromTop: true, scored: false });
    } else {
      pipes.push({ x: newX, h: bottomH, fromTop: false, scored: false });
      // Spawn stepping-stone bricks before this pipe (no ceiling pipe)
      maybeSpawnSteppingStoneBricks(newX, bottomH, false);
    }
  }
}

function update() {
  if (state !== 'playing') return;
  if (levelCleared) {
    levelClearTimer++;
    if (levelClearPhase === 'sliding') {
      // Slide player down the flagpole toward ground
      const groundY = DESIGN_H - GROUND_H - player.h;
      if (player.y < groundY) {
        player.y += (groundY - player.y) * 0.08 + 1; // ease toward ground
        if (player.y > groundY) player.y = groundY;
      }
      if (levelClearTimer >= LEVEL_CLEAR_SLIDE_FRAMES) {
        levelClearPhase = 'done';
        player.y = groundY;
      }
    }
    return;
  }

  frameCount++;
  // Compute base elapsed time; bonusTime is added after sweep resolves bricks
  survivalTime = frameCount / 60 + bonusTime;
  updateDifficultyInfo();
  if (coinRushWindowTimer > 0) coinRushWindowTimer = Math.max(0, coinRushWindowTimer - FIXED_DT);
  if (coinRushTimer > 0) coinRushTimer = Math.max(0, coinRushTimer - FIXED_DT);
  if (coinRushWindowTimer <= 0 && coinRushTimer <= 0) coinRushChain = 0;
  // Coin combo timer
  if (coinComboTimer > 0) { coinComboTimer = Math.max(0, coinComboTimer - FIXED_DT); }
  if (coinComboTimer <= 0) coinComboLevel = 0;
  // ── Manual horizontal movement (auto-acceleration + reverse brake) ─────
  // Compute desired move direction from input
  let moveDir = 0;
  if (moveLeftPressed) moveDir -= 1;
  if (moveRightPressed) moveDir += 1;

  // Target speed: holding a direction auto-ramps toward max speed
  const rushMul = coinRushTimer > 0 ? COIN_RUSH_SPEED_MUL : 1.0;
  const targetVX = moveDir * PLAYER_MAX_SPEED * rushMul;

  // Detect reverse-braking: input opposes current velocity
  const reversing = moveDir !== 0 && moveDir * playerVX < 0;

  // ── Ground brake: time-based 0.5 s slide-to-stop ──
  if (reversing && player.onGround) {
    // Start brake timer on first reverse frame
    if (brakeTimer <= 0) {
      brakeTimer = BRAKE_TO_STOP_TIME;
    }
    // Compute per-frame decel so |vx| reaches 0 in remaining brakeTimer
    const framesLeft = Math.max(1, brakeTimer * 60);
    const decel = Math.min(BRAKE_DECEL_MAX, Math.max(BRAKE_DECEL_MIN, Math.abs(playerVX) / framesLeft));
    if (playerVX > 0) {
      playerVX = Math.max(0, playerVX - decel);
    } else {
      playerVX = Math.min(0, playerVX + decel);
    }
    brakeTimer = Math.max(0, brakeTimer - FIXED_DT);
    // Still braking while timer active OR speed nonzero
    if (brakeTimer > 0 && playerVX !== 0) {
      playerBraking = true;
    } else {
      // Brake complete — start reverse accel
      playerBraking = false;
      brakeTimer = 0;
      if (playerVX === 0) playerVX = moveDir * PLAYER_ACCEL;
    }
  } else if (reversing) {
    // Air brake: weaker, no time constraint
    brakeTimer = 0;
    playerBraking = Math.abs(playerVX) > 0.15;
    if (playerVX > 0) {
      playerVX = Math.max(0, playerVX - AIR_BRAKE_DECEL);
    } else {
      playerVX = Math.min(0, playerVX + AIR_BRAKE_DECEL);
    }
    if (playerVX === 0) playerVX = moveDir * PLAYER_ACCEL;
  } else {
    brakeTimer = 0;
    playerBraking = false;
  }

  // Accelerate / decelerate toward target
  if (moveDir !== 0 && !reversing) {
    // Same direction or starting from zero — normal acceleration
    if (playerVX < targetVX) {
      playerVX = Math.min(targetVX, playerVX + PLAYER_ACCEL);
    } else if (playerVX > targetVX) {
      playerVX = Math.max(targetVX, playerVX - PLAYER_ACCEL);
    }
  } else if (moveDir === 0) {
    // No input — decelerate to 0 (unchanged)
    brakeTimer = 0;
    playerBraking = false;
    if (playerVX > 0) {
      playerVX = Math.max(0, playerVX - PLAYER_DECEL);
    } else if (playerVX < 0) {
      playerVX = Math.min(0, playerVX + PLAYER_DECEL);
    }
  }

  // ── Fun Pack v2: Boss Wave trigger & timer ──────────
  if (bossWaveActive) {
    bossWaveTimer -= 1 / 60;
    // Fun Pack v2.1: Countdown beep for last 3 seconds
    if (bossWaveTimer > 0 && bossWaveTimer <= 3) {
      const sec = Math.ceil(bossWaveTimer);
      if (sec !== bossCountdownLastSec) {
        bossCountdownLastSec = sec;
        sfxCountdownBeep();
      }
    }
    if (bossWaveTimer <= 0) {
      endBossWave();
    }
  } else if (survivalTime >= bossWaveNextTrigger) {
    startBossWave();
  }
  // Boss clear popup countdown
  if (bossWaveClearTimer > 0) bossWaveClearTimer--;

  // Theme announce timer countdown
  if (themeAnnounceTimer > 0) themeAnnounceTimer--;
  // Section announce timer countdown
  if (sectionAnnounceTimer > 0) sectionAnnounceTimer--;
  // Section flash overlay countdown
  if (sectionFlashTimer > 0) sectionFlashTimer--;
  // Smooth theme color transition (lerp toward 1 over ~2 seconds)
  if (themeColorLerp < 1) {
    themeColorLerp = Math.min(1, themeColorLerp + 0.008); // ~125 frames ≈ 2s
  }

  // Fun Pack v1: Speed wave phase (kept for HUD/debug display)
  speedWavePhase = (survivalTime / SPEED_WAVE_PERIOD) * Math.PI * 2;
  // No auto-scroll: camera follows player instead

  // ── Phase 1: Compute desired velocity vector ──────────
  justJumped = false; // reset each frame; set below if a jump initiates
  if (player.onGround) coyoteFrames = COYOTE_FRAMES;
  else if (coyoteFrames > 0) coyoteFrames--;

  // Jump initiation (requires fresh press — must release before next jump)
  if (jumpPressed && !jumpConsumed && (player.onGround || coyoteFrames > 0)) {
    player.vy = JUMP_INITIAL;
    player.onGround = false;
    jumpHoldFrames = 0;
    jumpConsumed = true;
    coyoteFrames = 0;
    justJumped = true;    // prevent swept movement from re-grounding this frame
    isAirJump = false;    // ground jump uses full height
    wallNudgeUsed = false; // allow one wall-kick nudge this jump

    // ── Wall-Kick Nudge ──────────────────────────────────
    // If player is flush against a pipe body side at jump start, nudge outward
    // so the lip overhang doesn't immediately block the ascent.
    const hb = getPlayerHitbox();
    for (const pipe of pipes) {
      if (pipe.h <= 0) continue;
      const pr = getPipeRects(pipe);
      const body = pipe.fromTop
        ? { x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h }
        : { x: pr.bodyRect.x, y: pr.bodyRect.y, w: pr.bodyRect.w, h: pr.bodyRect.h };
      // Check vertical overlap with pipe body
      if (hb.y + hb.h <= body.y || hb.y >= body.y + body.h) continue;
      // Check if player's side is touching the pipe body (within 2px)
      const gapRight = body.x - (hb.x + hb.w); // player left of pipe
      const gapLeft = hb.x - (body.x + body.w); // player right of pipe
      if (gapRight >= -1 && gapRight <= 2) {
        // Player is to the LEFT of pipe body — nudge left
        // Safety: verify nudge doesn't push into another obstacle
        const testX = player.x - WALL_NUDGE_PX;
        const testHB = { x: testX + 4, y: hb.y, w: hb.w, h: hb.h };
        let nudgeOK = true;
        for (const p2 of pipes) {
          if (p2 === pipe || p2.h <= 0) continue;
          const pr2 = getPipeRects(p2);
          if (rectsOverlap(testHB.x, testHB.y, testHB.w, testHB.h, pr2.lipRect.x, pr2.lipRect.y, pr2.lipRect.w, pr2.lipRect.h) ||
              rectsOverlap(testHB.x, testHB.y, testHB.w, testHB.h, pr2.bodyRect.x, pr2.bodyRect.y, pr2.bodyRect.w, pr2.bodyRect.h)) {
            nudgeOK = false; break;
          }
        }
        if (nudgeOK) {
          player.x = testX;
          wallNudgeUsed = true;
          edgeDebugMsgs.push({ text: 'WALL-NUDGE', ttl: 90 });
          break;
        }
      } else if (gapLeft >= -1 && gapLeft <= 2) {
        // Player is to the RIGHT of pipe body — nudge right
        const testX = player.x + WALL_NUDGE_PX;
        const testHB = { x: testX + 4, y: hb.y, w: hb.w, h: hb.h };
        let nudgeOK = true;
        for (const p2 of pipes) {
          if (p2 === pipe || p2.h <= 0) continue;
          const pr2 = getPipeRects(p2);
          if (rectsOverlap(testHB.x, testHB.y, testHB.w, testHB.h, pr2.lipRect.x, pr2.lipRect.y, pr2.lipRect.w, pr2.lipRect.h) ||
              rectsOverlap(testHB.x, testHB.y, testHB.w, testHB.h, pr2.bodyRect.x, pr2.bodyRect.y, pr2.bodyRect.w, pr2.bodyRect.h)) {
            nudgeOK = false; break;
          }
        }
        if (nudgeOK) {
          player.x = testX;
          wallNudgeUsed = true;
          edgeDebugMsgs.push({ text: 'WALL-NUDGE', ttl: 90 });
          break;
        }
      }
    }
  }

  // ── Double Jump (air jump) — requires active mushroom power ──
  // Air jump uses half initial velocity and half hold frames for ~50% height
  if (jumpPressed && !jumpConsumed && !player.onGround && doubleJumpTimer > 0 && airJumpsUsed < MAX_AIR_JUMPS) {
    player.vy = AIR_JUMP_INITIAL;
    jumpHoldFrames = 0;
    jumpConsumed = true;
    isAirJump = true;
    airJumpsUsed++;
    if (DEBUG_MODE) {
      console.log(`%c[DoubleJump] Air jump used (${airJumpsUsed}/${MAX_AIR_JUMPS}), timer=${doubleJumpTimer.toFixed(1)}s`, 'color: #e53935');
    }
  }

  // Variable jump: hold to go higher (air jumps use reduced hold limit)
  const holdLimit = isAirJump ? AIR_JUMP_HOLD_MAX_T : JUMP_HOLD_MAX_T;
  if (jumpPressed && !player.onGround && jumpHoldFrames < holdLimit && player.vy < 0) {
    player.vy += JUMP_HOLD_ACCEL;
    jumpHoldFrames++;
  }

  // Apply gravity to get desired vertical velocity
  player.vy += GRAVITY;

  // ── Phase 2: Swept AABB resolve ───────────────────────
  // Combine player's vertical motion + horizontal motion (manual movement)
  // into one unified continuous collision resolve.
  const preResolveVY = player.vy; // save for perfect landing detection
  const result = resolveSweptMovement(player.vy, playerVX);

  // ── Hidden Block reveal check ─────────────────────────
  // Hidden blocks are non-solid, so swept movement passes through them.
  // Detect head-bump trigger: player was moving upward and head overlaps a hidden block.
  if (preResolveVY < 0) {
    const pb = getPlayerHitbox();
    for (const brick of bricks) {
      if (!brick.hidden || brick.revealed || brick.broken) continue;
      // Check if player head (top edge) overlaps the hidden brick's bottom region
      if (pb.x + pb.w > brick.x + 2 && pb.x < brick.x + brick.w - 2 &&
          pb.y < brick.y + brick.h && pb.y + pb.h * 0.4 > brick.y) {
        // Reveal the hidden block
        brick.revealed = true;
        brick.bumpTimer = BLOCK_BUMP_FRAMES;
        score += HIDDEN_BLOCK_SCORE + HIDDEN_REVEAL_BONUS;
        spawnScorePopup(brick.x + BRICK_W / 2 - 8, brick.y - 5, HIDDEN_BLOCK_SCORE + HIDDEN_REVEAL_BONUS);
        // "SECRET!" label popup (offset slightly so it doesn't overlap the score)
        spawnScorePopup(brick.x + BRICK_W / 2 - 14, brick.y - 18, 0);
        scorePopups[scorePopups.length - 1].text = 'SECRET!';
        scorePopups[scorePopups.length - 1].color = '#7eeaea';
        triggerCombo(HIDDEN_BLOCK_SCORE + HIDDEN_REVEAL_BONUS);
        // Shortcut blocks award a bonus coin (risk/reward for discovery)
        if (brick.shortcut && HIDDEN_SHORTCUT_COIN) {
          coins++;
          check1UP();
          spawnCoinPop(brick.x + BRICK_W / 2 - 4, brick.y);
          sfxCoinPop(0);
        }
        // Stop upward movement (bonk)
        player.vy = Math.abs(player.vy) * 0.4;
        // SFX: distinctive reveal chime (higher pitch than normal coin)
        sfxHiddenReveal();
        break; // only reveal one per frame
      }
    }
  }

  // Recompute survivalTime AFTER sweep so brick bonus is reflected immediately in HUD
  survivalTime = frameCount / 60 + bonusTime;
  updateDifficultyInfo();

  // ── Phase 3: Post-resolve checks ─────────────────────
  const groundY = DESIGN_H - GROUND_H - player.h;

  // Reset hold counter on landing
  if (result.landedThisFrame) {
    jumpHoldFrames = 0;
    coyoteFrames = COYOTE_FRAMES;
    wallNudgeUsed = false;
    airJumpsUsed = 0; // reset air jump count on landing
    isAirJump = false; // reset air jump flag on landing

    // ── Fun Pack v1: Platform mission (no score for landing) ──
    // Check if landed on pipe top or brick top (not ground)
    const landedOnPlatform = player.y < groundY - 2;
    if (landedOnPlatform) {
      // Mission: consecutive platform landings
      missionPlatformLandCount++;
      advanceMission('land_platforms');
    } else {
      // Ground landing resets consecutive platform count AND mission progress for that type
      if (missionPlatformLandCount > 0 && mission && mission.type === 'land_platforms' && !mission.done) {
        mission.progress = 0;
      }
      missionPlatformLandCount = 0;
    }
  }

  // Clamp player X within camera-visible bounds (world coords)
  if (player.x < cameraX) player.x = cameraX;
  if (player.x + player.w > cameraX + DESIGN_W) player.x = cameraX + DESIGN_W - player.w;

  // Animation state machine
  updateAnimState();

  // Animation frame (run cycle only advances on ground; faster at higher speed)
  if (player.animState === 'run') {
    const speedRatio = Math.min(1, Math.abs(playerVX) / PLAYER_MAX_SPEED);
    const runAnimInterval = Math.round(6 - 2 * speedRatio); // 6 (slow) → 4 (full speed)
    if (frameCount % runAnimInterval === 0) player.frame = (player.frame + 1) % 4;
  }

  // Update debris fragments
  updateFragments();

  // Update hidden block hint sparks
  updateHintSparks();

  // Update score popups & coin pops
  updateScorePopups();
  updateTimeBonusPopups();
  updateCoinPops();
  updateBrickBumps();

  // Update mushrooms (physics + player pickup)
  updateMushrooms();

  // Update turtles (physics, collisions, state machine, player interaction)
  if (updateTurtles()) {
    // Player killed by turtle
    if (lives > 0) { respawnPlayer(); }
    else {
      state = 'dead';
      if (score > highScore) highScore = score;
      const tMins = Math.floor(survivalTime / 60);
      const tSecs = Math.floor(survivalTime % 60);
      const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
      showOverlay('Game Over', `Score: ${score}  |  Time: ${timeStr}  |  ${DIFFICULTY_LEVELS[diffLevel].name}`, score);
      return;
    }
  }

  // Update double jump timer (count down at ~60fps)
  if (doubleJumpTimer > 0) {
    doubleJumpTimer -= 1 / 60;
    if (doubleJumpTimer <= 0) {
      doubleJumpTimer = 0;
      if (DEBUG_MODE) {
        console.log('%c[DoubleJump] Timer expired', 'color: #e53935');
      }
    }
  }

  // ── Fun Pack v1: Combo timer decay ────────────────────
  if (comboTimer > 0) {
    comboTimer -= 1 / 60;
    if (comboTimer <= 0) {
      resetCombo();
    }
  }
  if (comboPopupTimer > 0) comboPopupTimer--;
  if (missionCompleteTimer > 0) missionCompleteTimer--;

  // ── Phase 4: Camera follow (no auto-scroll) ─────────
  // No auto-scroll: obstacles stay in world-space.
  // Camera advances only when player pushes past screen midpoint.
  {
    const playerScreenX = player.x - cameraX;
    if (playerScreenX > SCREEN_HALF_X) {
      const newCam = player.x - SCREEN_HALF_X;
      cameraX = Math.max(cameraX, newCam); // monotonic: never decrease
    }
    // Ground texture offset tracks camera world position
    groundOffset = cameraX % 32;
  }

  // Safety: push player out if overlapping an obstacle after camera move
  {
    const pb = getPlayerHitbox();
    const rects = gatherCollisionRects();
    for (const r of rects) {
      if (r.type === 'ground') continue;
      if (!rectsOverlap(pb.x, pb.y, pb.w, pb.h, r.x, r.y, r.w, r.h)) continue;
      const overlapL = (pb.x + pb.w) - r.x;
      const overlapR = (r.x + r.w) - pb.x;
      const overlapT = (pb.y + pb.h) - r.y;
      const overlapB = (r.y + r.h) - pb.y;
      const minH = Math.min(overlapL, overlapR);
      const minV = Math.min(overlapT, overlapB);
      if (minH <= minV && overlapL < overlapR) {
        player.x -= overlapL;
        playerVX = Math.min(playerVX, 0);
      }
    }
    // Clamp player to camera left edge (can't go behind camera)
    if (player.x < cameraX) player.x = cameraX;
  }

  // Check if player fell off a platform edge (pipe/brick scrolled away)
  if (player.onGround && player.y < groundY - 5) {
    const support = checkStandingSupport();
    if (support === null) {
      player.onGround = false;
    }
  }

  // ── Flagpole collision check ─────────────────────────
  if (!levelCleared) {
    const pb = getPlayerHitbox();
    const groundY = DESIGN_H - GROUND_H;
    const fpX = flagpoleX;
    const fpY = groundY - FLAGPOLE_H;
    if (rectsOverlap(pb.x, pb.y, pb.w, pb.h, fpX, fpY, FLAGPOLE_W, FLAGPOLE_H)) {
      levelCleared = true;
      levelClearTimer = 0;
      levelClearPhase = 'sliding';
      player.x = fpX - player.w / 2 + FLAGPOLE_W / 2; // snap to pole
      player.vy = 0;
      player.animState = 'idle';
      score += LEVEL_CLEAR_BONUS;
      spawnScorePopup(pb.x + pb.w / 2, pb.y - 8, LEVEL_CLEAR_BONUS);
      scorePopups[scorePopups.length - 1].text = `LEVEL CLEAR +${LEVEL_CLEAR_BONUS}`;
      return;
    }
  }

  // ── Phase 5: Death checks (after obstacles moved) ────
  // Check crush death
  if (checkCrush()) {
    if (lives > 0) { respawnPlayer(); }
    else {
      state = 'dead';
      if (score > highScore) highScore = score;
      const tMins = Math.floor(survivalTime / 60);
      const tSecs = Math.floor(survivalTime % 60);
      const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
      showOverlay('Game Over', `Score: ${score}  |  Time: ${timeStr}  |  ${DIFFICULTY_LEVELS[diffLevel].name}`, score);
      return;
    }
  }

  // If player goes off left edge of camera view, die
  if (player.x + player.w < cameraX - 20) {
    if (lives > 0) { respawnPlayer(); }
    else {
      state = 'dead';
      if (score > highScore) highScore = score;
      const tMins = Math.floor(survivalTime / 60);
      const tSecs = Math.floor(survivalTime % 60);
      const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
      showOverlay('Game Over', `Score: ${score}  |  Time: ${timeStr}  |  ${DIFFICULTY_LEVELS[diffLevel].name}`, score);
      return;
    }
  }

  // Score: passed pipe
  for (const pipe of pipes) {
    if (!pipe.scored && pipe.x + LIP_W < player.x) {
      pipe.scored = true;
      score++;
      milestonePipeCount++;
      if (milestonePipeCount % 10 === 0) {
        score += 5;
        scorePopups.push({ x: player.x, y: player.y - 30, text: 'MILESTONE +5', life: 60 });
      }
    }
  }

  // Remove off-screen pipes (far behind camera)
  pipes = pipes.filter(p => p.x > cameraX - LIP_W - 100);

  // Remove off-screen or broken bricks (far behind camera)
  bricks = bricks.filter(b => !b.broken && b.x > cameraX - BRICK_W - 100);

  // Remove off-screen turtles handled inside updateTurtles()

  // Supplemental random turtle spawning (reduced — chunks also place turtles)
  // Rhythm gating: suppress random spawns during relief portion of cycle
  {
    const rhythmPos = ((cameraX - spawnRhythmBase) % SPAWN_RHYTHM_CYCLE + SPAWN_RHYTHM_CYCLE) % SPAWN_RHYTHM_CYCLE;
    const inRelief = rhythmPos > SPAWN_RHYTHM_CYCLE * (1 - SPAWN_RHYTHM_RELIEF);
    if (!inRelief) {
      const turtleSpawnX = cameraX + DESIGN_W + 80 + Math.random() * 120;
      if (turtleSpawnX - lastTurtleSpawnX >= TURTLE_MIN_SPAWN_GAP && Math.random() < TURTLE_SPAWN_CHANCE * FIXED_DT * 0.4) {
        spawnTurtle(turtleSpawnX);
      }
    }
  }

  // Spawn chunks or boss wave obstacles
  const spawnEdge = cameraX + DESIGN_W;
  if (bossWaveActive) {
    const rightmostBossX = pipes.length > 0
      ? pipes.reduce((a, b) => a.x > b.x ? a : b).x
      : 0;
    if (rightmostBossX < spawnEdge) {
      bossWaveSpawnX = rightmostBossX + BOSS_WAVE_SPAWN_GAP;
      spawnBossWaveObstacle();
    }
  } else {
    // After boss wave, ensure nextChunkX is ahead of all existing pipes
    if (pipes.length > 0) {
      const rightmostX = pipes.reduce((a, b) => a.x > b.x ? a : b).x;
      if (nextChunkX < rightmostX + 100) {
        nextChunkX = rightmostX + 100;
      }
    }
    // Chunk-based spawning: generate new chunk when nextChunkX is within view range
    if (nextChunkX < spawnEdge + CHUNK_MAX_WIDTH) {
      spawnChunk();
    }
  }

  // cameraX already updated in Phase 4 (camera follow)

  // ── Frame-End Depenetration Fallback ───────────────────
  // After all movement (obstacles moved, X-recovery applied), run a final
  // overlap check. If the player hitbox still overlaps any pipe AABB (lip or
  // body), push them out by minimum displacement. This is the last safety net
  // to prevent the player from ever being rendered inside a pipe.
  {
    const HB_OX = 4, HB_OY = 2, HB_W = player.w - 8, HB_H = player.h - 4;
    const endRects = gatherCollisionRects();
    for (let iter = 0; iter < 4; iter++) {
      let fixed = false;
      const hx = player.x + HB_OX;
      const hy = player.y + HB_OY;
      for (const r of endRects) {
        if (r.type === 'ground') continue; // ground handled normally
        if (!rectsOverlap(hx, hy, HB_W, HB_H, r.x, r.y, r.w, r.h)) continue;
        // Compute minimum penetration vector
        const oL = (hx + HB_W) - r.x;
        const oR = (r.x + r.w) - hx;
        const oT = (hy + HB_H) - r.y;
        const oB = (r.y + r.h) - hy;
        const mX = oL < oR ? -oL : oR;
        const mY = oT < oB ? -oT : oB;
        if (Math.abs(mX) < Math.abs(mY)) {
          player.x += mX;
        } else {
          player.y += mY;
          if (mY < 0 && player.vy > 0) { player.vy = 0; player.onGround = true; }
          if (mY > 0 && player.vy < 0) { player.vy = 0; }
        }
        depenFixCount++;
        fixed = true;
      }
      if (!fixed) break;
    }
    // Re-clamp after depenetration (world-space, camera bounds)
    if (player.x < cameraX) player.x = cameraX;
    if (player.x + player.w > cameraX + DESIGN_W) player.x = cameraX + DESIGN_W - player.w;
  }

  // Update clouds (screen-space drifting, independent of camera)
  for (const c of clouds) {
    c.x -= c.speed;
    if (c.x + c.w < -50) {
      c.x = DESIGN_W + Math.random() * 100;
      c.y = 20 + Math.random() * 100;
    }
  }

  // Hills: parallax based on cameraX (30% scroll rate), recycle when off-screen
  for (const h of hills) {
    const screenX = h.x - cameraX * 0.3;
    if (screenX + h.w < -100) {
      const last = hills.reduce((a, b) => a.x > b.x ? a : b);
      h.x = last.x + 200 + Math.random() * 100;
      h.w = 180 + Math.random() * 100;
      h.h = 40 + Math.random() * 40;
    }
  }

  scoreDisplay.textContent = `SCORE: ${score}`;
  hudCoin.textContent = (coinComboLevel >= 1 && coinComboTimer > 0)
    ? `COIN: ${coins}  x${coinComboLevel + 1}`
    : `COIN: ${coins}`;
  hudLife.textContent = `LIFE: ${lives}`;

  // Update HUD
  const mins = Math.floor(survivalTime / 60);
  const secs = Math.floor(survivalTime % 60);
  hudTime.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

  const lvl = DIFFICULTY_LEVELS[diffLevel];
  hudLevel.textContent = `Lv.${diffLevel + 1} ${lvl.name}`;

  const fillPct = diffLevel >= DIFFICULTY_LEVELS.length - 1 ? 100 : Math.round(diffProgress * 100);
  hudLevelFill.style.width = fillPct + '%';
  const levelColors = ['#2ecc71', '#f1c40f', '#e67e22', '#e74c3c', '#9b59b6'];
  hudLevelFill.style.background = levelColors[diffLevel];

  // Mushroom / Double Jump HUD
  if (doubleJumpTimer > 0) {
    const secs = Math.ceil(doubleJumpTimer);
    const canJump = !player.onGround && airJumpsUsed < MAX_AIR_JUMPS;
    hudMushroom.style.display = 'block';
    if (canJump) {
      hudMushroom.textContent = `DOUBLE JUMP READY [${secs}s]`;
      hudMushroom.style.color = '#2ecc71';
    } else {
      hudMushroom.textContent = `MUSHROOM: ON [${secs}s]`;
      hudMushroom.style.color = '#f1c40f';
    }
  } else {
    hudMushroom.style.display = 'none';
  }


  // ── Fun Pack v1: Combo HUD ──────────────────────────
  if (comboPopupTimer > 0 && comboPopupText) {
    hudCombo.textContent = comboPopupText;
    hudCombo.style.display = 'block';
    hudCombo.style.opacity = Math.min(1, comboPopupTimer / 15);
    // Scale effect: bigger at start, shrinks
    const scale = 1 + 0.3 * (comboPopupTimer / COMBO_POPUP_DURATION);
    hudCombo.style.transform = `translate(-50%, -50%) scale(${scale.toFixed(2)})`;
  } else {
    hudCombo.style.display = 'none';
  }
  // Persistent combo bar (top-right)
  if (comboCount >= 2 && comboTimer > 0) {
    const barPct = Math.round((comboTimer / COMBO_WINDOW) * 100);
    hudComboBar.textContent = `COMBO x${comboCount} [${'█'.repeat(Math.ceil(barPct / 20))}${'░'.repeat(5 - Math.ceil(barPct / 20))}]`;
    hudComboBar.style.display = 'block';
  } else {
    hudComboBar.style.display = 'none';
  }

  // ── Coin Rush HUD ───────────────────────────────────
  if (coinRushTimer > 0) {
    const secLeft = coinRushTimer.toFixed(1);
    hudBoost.textContent = `COIN RUSH ⚡ ${secLeft}s`;
    hudBoost.style.display = 'block';
  } else if (coinRushWindowTimer > 0 && coinRushChain > 0) {
    hudBoost.textContent = `Coin chain ${coinRushChain}/${COIN_RUSH_TARGET}`;
    hudBoost.style.display = 'block';
  } else {
    hudBoost.style.display = 'none';
  }

  // ── Fun Pack v1: Mission HUD ────────────────────────
  if (mission && !mission.done) {
    let missionText = `任務: ${mission.desc}  [${mission.progress}/${mission.target}]`;
    if (mission.timeLimit > 0) {
      const remaining = Math.max(0, mission.timeLimit - (survivalTime - mission.startTime));
      missionText += `  ${Math.ceil(remaining)}s`;
    }
    hudMission.textContent = missionText;
    hudMission.style.display = 'block';
  } else if (mission && mission.done) {
    hudMission.style.display = 'none';
  }
  // Mission complete popup
  if (missionCompleteTimer > 0) {
    hudMissionComplete.style.display = 'block';
    hudMissionComplete.style.opacity = Math.min(1, missionCompleteTimer / 20);
  } else {
    hudMissionComplete.style.display = 'none';
  }

  // ── Fun Pack v2: Boss Wave HUD ──────────────────────
  if (bossWaveActive) {
    const secLeft = Math.ceil(bossWaveTimer);
    hudBossWave.textContent = `BOSS WAVE!  ${secLeft}s`;
    hudBossWave.style.display = 'block';
    // Pulse effect: scale oscillates slightly
    const pulse = 1.0 + 0.05 * Math.sin(frameCount * 0.15);
    hudBossWave.style.transform = `translate(-50%, -50%) scale(${pulse.toFixed(3)})`;
  } else {
    hudBossWave.style.display = 'none';
  }
  // Boss clear reward popup
  if (bossWaveClearTimer > 0) {
    hudBossClear.textContent = `BOSS CLEAR +${BOSS_WAVE_REWARD_SCORE}`;
    hudBossClear.style.display = 'block';
    hudBossClear.style.opacity = Math.min(1, bossWaveClearTimer / 20);
    const clearScale = 1 + 0.2 * (bossWaveClearTimer / 120);
    hudBossClear.style.transform = `translate(-50%, -50%) scale(${clearScale.toFixed(3)})`;
  } else {
    hudBossClear.style.display = 'none';
  }

  // ── Theme Chunk System HUD ──────────────────────────
  hudTheme.textContent = `THEME: ${currentTheme}`;
  const themeAnnInfo = THEME_ANNOUNCE[currentTheme];
  hudTheme.style.color = themeAnnInfo ? themeAnnInfo.color : '#adf';

  // Theme transition announcement
  if (themeAnnounceTimer > 0 && themeAnnounceName) {
    const ann = THEME_ANNOUNCE[themeAnnounceName];
    hudThemeAnnounce.textContent = ann ? ann.text : themeAnnounceName;
    hudThemeAnnounce.style.color = ann ? ann.color : '#fff';
    hudThemeAnnounce.style.display = 'block';
    hudThemeAnnounce.style.opacity = Math.min(1, themeAnnounceTimer / 30);
  } else {
    hudThemeAnnounce.style.display = 'none';
  }

  // Rhythm section transition announcement
  if (sectionAnnounceTimer > 0 && sectionAnnounceName) {
    const sann = SECTION_ANNOUNCE[sectionAnnounceName];
    hudSectionAnnounce.textContent = sann ? sann.text : sectionAnnounceName;
    hudSectionAnnounce.style.color = sann ? sann.color : '#fff';
    hudSectionAnnounce.style.display = 'block';
    hudSectionAnnounce.style.opacity = Math.min(1, sectionAnnounceTimer / 30);
  } else {
    hudSectionAnnounce.style.display = 'none';
  }

  // Persistent section label with highlight glow on transition
  const sLabelInfo = SECTION_ANNOUNCE[currentSection];
  hudSectionLabel.textContent = currentSection;
  if (sectionAnnounceTimer > 0) {
    hudSectionLabel.style.color = sLabelInfo ? sLabelInfo.color : '#fff';
    hudSectionLabel.classList.add('highlight');
  } else {
    hudSectionLabel.style.color = '#aaa';
    hudSectionLabel.classList.remove('highlight');
  }
}

function draw() {
  // Sky gradient (theme-aware)
  const themeSky = getThemeSkyColors();
  const grad = ctx.createLinearGradient(0, 0, 0, DESIGN_H - GROUND_H);
  grad.addColorStop(0, themeSky.top);
  grad.addColorStop(1, themeSky.bottom);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, DESIGN_W, DESIGN_H);

  // Subtle section sky tint overlay for ambient differentiation
  const sectionTint = SECTION_SKY_TINT[currentSection];
  if (sectionTint) {
    ctx.fillStyle = sectionTint;
    ctx.fillRect(0, 0, DESIGN_W, DESIGN_H - GROUND_H);
  }

  // Clouds (parallax — not affected by camera)
  for (const c of clouds) {
    drawCloud(c.x, c.y, c.w);
  }

  // Hills (parallax — 30% of camera scroll rate)
  for (const h of hills) {
    drawHill(h.x - cameraX * 0.3, h.w, h.h);
  }

  // ── Camera transform for world objects ──────────────────
  ctx.save();
  ctx.translate(-cameraX, 0);

  // Ground
  drawGround();

  // Pipes
  for (const pipe of pipes) {
    if (pipe.h <= 0) continue;
    if (pipe.fromTop) {
      drawTopPipe(pipe.x, pipe.h);
    } else {
      drawBottomPipe(pipe.x, pipe.h);
    }
  }

  // Breakable bricks & question blocks
  for (const brick of bricks) {
    // Hidden blocks: invisible until revealed
    if (brick.hidden) {
      if (brick.revealed) {
        const by = brick.y + getBumpOffset(brick);
        drawRevealedHiddenBlock(brick.x, by);
      }
      // Unrevealed hidden blocks: draw nothing (invisible)
      continue;
    }
    const by = brick.y + getBumpOffset(brick);  // visual-only bump offset
    if (brick.question) {
      if (brick.used) {
        drawUsedBlock(brick.x, by);
      } else {
        drawQuestionBlock(brick.x, by);
      }
    } else if (!brick.broken) {
      if (brick.special) {
        drawSpecialBrick(brick.x, by);
      } else {
        drawBrick(brick.x, by);
      }
    }
  }

  // Mushrooms
  for (const m of mushrooms) {
    drawMushroom(m.x, m.y);
  }

  // Turtles
  for (const t of turtles) {
    if (t.state === 'walk') {
      drawTurtleWalk(t.x, t.y, t.vx, t.animFrame, t.turnCooldown || 0);
    } else if (t.state === 'shell_idle') {
      drawTurtleShell(t.x, t.y, false, t.animFrame, 0);
    } else if (t.state === 'shell_move') {
      drawTurtleShell(t.x, t.y, true, t.animFrame, t.vx);
    } else if (t.state === 'shell_bounce_dead') {
      drawTurtleShell(t.x, t.y, false, t.animFrame, 0);
    } else if (t.state === 'dead') {
      drawTurtleDead(t.x, t.y, t.deadTimer);
    }
  }

  // Flagpole
  {
    const groundY = DESIGN_H - GROUND_H;
    const fpX = flagpoleX;
    const fpY = groundY - FLAGPOLE_H;
    // Pole
    ctx.fillStyle = '#888';
    ctx.fillRect(fpX, fpY, FLAGPOLE_W, FLAGPOLE_H);
    // Ball on top
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(fpX + FLAGPOLE_W / 2, fpY, 8, 0, Math.PI * 2);
    ctx.fill();
    // Flag
    ctx.fillStyle = '#0a0';
    ctx.fillRect(fpX + FLAGPOLE_W, fpY + 10, FLAGPOLE_FLAG_W, FLAGPOLE_FLAG_H);
  }

  // Player
  if (state === 'playing' || state === 'dead') {
    drawPlayer(player.x, player.y, player.frame);
  } else {
    // Title screen: show idle animation
    const prevAnim = player.animState;
    player.animState = 'idle';
    drawPlayer(player.x, DESIGN_H - GROUND_H - player.h, 0);
    player.animState = prevAnim;
  }

  // Debris fragments (drawn on top of everything)
  for (const frag of fragments) {
    drawFragment(frag);
  }

  // Hidden block hint sparks (subtle, behind popups)
  drawHintSparks();

  // Score popups & coin pops
  drawScorePopups();
  drawTimeBonusPopups();
  drawCoinPops();

  ctx.restore(); // end camera transform

  // ── Section transition flash overlay ───────────────────
  if (sectionFlashTimer > 0 && sectionFlashColor) {
    const flashProgress = sectionFlashTimer / SECTION_FLASH_DURATION; // 1→0
    // Quick flash-in then fade-out: peak at 80%, fade linearly
    const alpha = flashProgress > 0.8
      ? (1 - flashProgress) * 5 * 0.18   // ramp up in first 20% of duration
      : flashProgress * 0.18;             // fade out over remaining 80%
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = sectionFlashColor;
    // Edge vignette: darker bars at top and bottom
    ctx.fillRect(0, 0, DESIGN_W, DESIGN_H * 0.08);
    ctx.fillRect(0, DESIGN_H * 0.92, DESIGN_W, DESIGN_H * 0.08);
    // Subtle full-screen tint
    ctx.globalAlpha = alpha * 0.35;
    ctx.fillRect(0, 0, DESIGN_W, DESIGN_H);
    ctx.restore();
  }

  // ── Level Clear overlay ────────────────────────────────
  if (levelCleared && levelClearPhase === 'done') {
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.fillRect(0, 0, DESIGN_W, DESIGN_H);
    ctx.font = 'bold 36px monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.fillText('LEVEL CLEAR!', DESIGN_W / 2, DESIGN_H / 2 - 10);
    ctx.font = '18px monospace';
    const tMins = Math.floor(survivalTime / 60);
    const tSecs = Math.floor(survivalTime % 60);
    const timeStr = `${String(tMins).padStart(2, '0')}:${String(tSecs).padStart(2, '0')}`;
    ctx.fillText(`Score: ${score}  |  Time: ${timeStr}`, DESIGN_W / 2, DESIGN_H / 2 + 25);
    ctx.font = '14px monospace';
    ctx.fillStyle = '#ccc';
    ctx.fillText('Press any key to restart', DESIGN_W / 2, DESIGN_H / 2 + 55);
    ctx.restore();
  }

  // ── Edge-Protection Debug Overlay (always visible) ────
  // Show EDGE-FORGIVE / WALL-NUDGE messages at top-left when triggered
  if (edgeDebugMsgs.length > 0) {
    ctx.save();
    ctx.font = 'bold 11px monospace';
    let dbgY = 14;
    for (let i = edgeDebugMsgs.length - 1; i >= 0; i--) {
      const msg = edgeDebugMsgs[i];
      const alpha = Math.min(1, msg.ttl / 30);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = msg.text === 'WALL-NUDGE' ? '#ff6' : msg.text === 'MUSHROOM PICKUP' ? '#f44' : '#6ff';
      ctx.fillText(msg.text, 6, dbgY);
      dbgY += 14;
      msg.ttl--;
      if (msg.ttl <= 0) edgeDebugMsgs.splice(i, 1);
    }
    ctx.restore();
  }

  // ── Debug hitbox overlay ──────────────────────────────
  if (DEBUG_MODE) {
    ctx.save();
    ctx.translate(-cameraX, 0);
    ctx.globalAlpha = 0.45;
    ctx.lineWidth = 1;

    // Player hitbox (green)
    const dbPb = getPlayerHitbox();
    ctx.strokeStyle = '#0f0';
    ctx.strokeRect(dbPb.x, dbPb.y, dbPb.w, dbPb.h);

    // Pipe collision rects (red = lip, orange = body)
    for (const pipe of pipes) {
      if (pipe.h <= 0) continue;
      const rects = getPipeRects(pipe);
      ctx.strokeStyle = '#f00';
      ctx.strokeRect(rects.lipRect.x, rects.lipRect.y, rects.lipRect.w, rects.lipRect.h);
      ctx.strokeStyle = '#f80';
      ctx.strokeRect(rects.bodyRect.x, rects.bodyRect.y, rects.bodyRect.w, rects.bodyRect.h);
      // Stand-Y line (cyan)
      if (rects.standY !== null) {
        ctx.strokeStyle = '#0ff';
        ctx.beginPath();
        ctx.moveTo(rects.lipRect.x, rects.standY);
        ctx.lineTo(rects.lipRect.x + rects.lipRect.w, rects.standY);
        ctx.stroke();
      }
    }

    // Brick hitboxes (yellow / magenta for special, dashed teal for hidden)
    for (const brick of bricks) {
      if (brick.broken) continue;
      if (brick.hidden && !brick.revealed) {
        ctx.strokeStyle = 'rgba(0,200,200,0.4)';
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(brick.x, brick.y, brick.w, brick.h);
        ctx.setLineDash([]);
        continue;
      }
      ctx.strokeStyle = (brick.hidden && brick.revealed) ? '#0aa' : brick.question ? '#0ff' : brick.special ? '#f0f' : '#ff0';
      ctx.strokeRect(brick.x, brick.y, brick.w, brick.h);
    }

    // (Mushroom hitbox / pickup box overlays disabled)

    // Turtle hitboxes (lime = walk, teal = shell_idle, red = shell_move, grey = dead/bounce)
    for (const t of turtles) {
      const tw = (t.state === 'walk') ? TURTLE_W : SHELL_W;
      const th = (t.state === 'walk') ? TURTLE_H : SHELL_H;
      ctx.strokeStyle = t.state === 'walk' ? '#8f8' : t.state === 'shell_idle' ? '#0ff' : t.state === 'shell_move' ? '#f44' : t.state === 'shell_bounce_dead' ? '#aaa' : '#888';
      ctx.strokeRect(t.x, t.y, tw, th);
      // State label
      ctx.font = '8px monospace';
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fillText(t.state, t.x, t.y - 2);
    }

    // Chunk boundary markers (vertical lines with labels)
    ctx.globalAlpha = 0.3;
    ctx.lineWidth = 1;
    ctx.font = '9px monospace';
    for (const ch of chunkHistory) {
      const chunkScreenX = ch.x;
      if (chunkScreenX > cameraX - 100 && chunkScreenX < cameraX + DESIGN_W + 100) {
        ctx.strokeStyle = '#ff0';
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(chunkScreenX, 0);
        ctx.lineTo(chunkScreenX, DESIGN_H);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#ff0';
        ctx.fillText(`#${ch.id} ${ch.type}`, chunkScreenX + 3, 12);
        if (ch.theme) {
          ctx.fillStyle = '#adf';
          ctx.fillText(ch.theme, chunkScreenX + 3, 22);
        }
        if (ch.rerolls > 0) {
          ctx.fillStyle = '#f80';
          ctx.fillText(`reroll:${ch.rerolls}`, chunkScreenX + 3, ch.theme ? 32 : 22);
        }
      }
    }
    ctx.globalAlpha = 0.45;

    // Debug text (screen-space)
    ctx.restore(); // pop camera transform
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.font = '10px monospace';
    ctx.fillStyle = '#0f0';
    ctx.fillText(`vx:${playerVX.toFixed(1)} brake:${playerBraking ? 1 : 0} brakeT:${brakeTimer.toFixed(2)} onGround:${player.onGround ? 1 : 0} vy:${player.vy.toFixed(1)} y:${player.y.toFixed(0)} cam:${cameraX.toFixed(0)} [SweptAABB]`, 4, DESIGN_H - 4);
    ctx.fillText(`onGround:${player.onGround} x:${player.x.toFixed(0)} dj:${doubleJumpTimer.toFixed(0)}s mush:${mushrooms.length} DEPEN FIX:${depenFixCount}`, 4, DESIGN_H - 14);
    ctx.fillText(`SPEED_WAVE:${getSpeedWaveFactor().toFixed(3)} COMBO:${comboCount} COMBO_T:${comboTimer.toFixed(1)} MISSION:${mission ? mission.type + ' ' + mission.progress + '/' + mission.target : 'none'}`, 4, DESIGN_H - 24);
    ctx.fillText(`BOSS:${bossWaveActive ? 'ON' : 'OFF'} BOSS_T:${bossWaveTimer.toFixed(1)} BOSS_MODE:${bossWaveMode} BOSS_COUNT:${bossWaveCount} NEXT:${bossWaveNextTrigger.toFixed(0)}s`, 4, DESIGN_H - 34);
    ctx.fillText(`SFX:${sfxEnabled ? 'ON' : 'OFF'} VIB:${vibEnabled ? 'ON' : 'OFF'} VIB_SUPPORTED:${vibSupported} CONTACT_PICKUP:ON mush:${mushrooms.length}`, 4, DESIGN_H - 44);
    // Turtle debug info — summary + sample turtle detail
    const tWalk = turtles.filter(t => t.state === 'walk').length;
    const tShellIdle = turtles.filter(t => t.state === 'shell_idle').length;
    const tShellMove = turtles.filter(t => t.state === 'shell_move').length;
    const tBounceDead = turtles.filter(t => t.state === 'shell_bounce_dead').length;
    const tDead = turtles.filter(t => t.state === 'dead').length;
    const tSample = turtles.find(t => t.state !== 'dead' && t.state !== 'shell_bounce_dead');
    const tInfo = tSample ? `vx:${tSample.vx.toFixed(1)} dir:${tSample.direction} st:${tSample.state} y:${tSample.y.toFixed(0)} gnd:${tSample.onGround?1:0}` : '-';
    ctx.fillText(`TURTLES:${turtles.length} walk:${tWalk} idle:${tShellIdle} move:${tShellMove} bdead:${tBounceDead} dead:${tDead} | ${tInfo}`, 4, DESIGN_H - 54);
    ctx.fillText(`dt:${(_debugDt * 1000).toFixed(1)}ms logicSteps:${_debugLogicSteps} fps(est):${_debugFps.toFixed(1)}`, 4, DESIGN_H - 64);
    // Chunk-based level generation debug info
    const cdi = chunkDebugInfo;
    const chunkPhaseNames = ['Tutorial', 'Medium', 'Hard', 'Max'];
    ctx.fillText(`CHUNK:${cdi ? '#' + cdi.id + ' ' + cdi.type : '-'} PHASE:${cdi ? chunkPhaseNames[cdi.diffPhase] || cdi.diffPhase : '-'} REROLLS:${cdi ? cdi.rerolls : 0} NEXT_X:${Math.round(nextChunkX)} TOTAL:${chunkIdCounter} CONSEC_DANGER:${consecutiveDangerChunks}`, 4, DESIGN_H - 74);
    ctx.fillText(`THEME:${currentTheme} REMAIN:${themeChunksRemaining} NEXT:${nextTheme || '-'} TRANSITION:${themeTransitionActive ? 'YES' : 'NO'} COLOR_LERP:${themeColorLerp.toFixed(2)}`, 4, DESIGN_H - 84);
    ctx.fillText(`SECTION:${currentSection} REMAIN:${sectionChunksRemaining} TRANSITION:${sectionTransitionActive ? 'YES' : 'NO'} RAMP:${sectionTransitionCountdown} FLASH:${sectionFlashTimer}`, 4, DESIGN_H - 94);
    ctx.restore();
  }
}

// ── Fixed Timestep Loop ─────────────────────────────────
// All game logic runs at a fixed 60 Hz (FIXED_DT = 1/60s).
// The game loop uses an accumulator: each render frame, real elapsed
// time is added to the accumulator, and update() is called in fixed
// increments until the accumulator is drained.  This ensures identical
// physics on 30 Hz phones, 60 Hz laptops, and 144+ Hz monitors.
const FIXED_DT = 1 / 60;         // seconds per logic step
const MAX_FRAME_DT = 0.1;        // clamp real dt to avoid spiral (tab-away)
const MAX_STEPS_PER_FRAME = 5;   // safety: cap logic steps per render frame
let _accumulator = 0;
let _lastTimestamp = -1;
let _debugDt = 0;         // raw dt of last render frame (seconds)
let _debugLogicSteps = 0; // logic steps executed last render frame
let _debugFps = 60;       // estimated FPS (smoothed)
let _fpsAlpha = 0.05;     // EMA smoothing factor for FPS

function gameLoop(timestamp) {
  requestAnimationFrame(gameLoop);

  // First frame: seed timestamp, skip logic to avoid a giant dt
  if (_lastTimestamp < 0) {
    _lastTimestamp = timestamp;
    draw();
    return;
  }

  // Real elapsed time in seconds; clamp to prevent death spiral
  let realDt = (timestamp - _lastTimestamp) / 1000;
  _lastTimestamp = timestamp;
  if (realDt > MAX_FRAME_DT) realDt = MAX_FRAME_DT;

  // Debug stats
  _debugDt = realDt;
  if (realDt > 0) _debugFps += _fpsAlpha * (1 / realDt - _debugFps);

  // Accumulate and run fixed-step updates
  _accumulator += realDt;
  let steps = 0;
  while (_accumulator >= FIXED_DT && steps < MAX_STEPS_PER_FRAME) {
    update();
    _accumulator -= FIXED_DT;
    steps++;
  }
  // If accumulator still has leftover (hit step cap), drain it to
  // prevent permanent lag spiral.
  if (steps >= MAX_STEPS_PER_FRAME) _accumulator = 0;
  _debugLogicSteps = steps;

  draw();
}

// ── Overlay ────────────────────────────────────────────
function showOverlay(title, msg, sc) {
  olTitle.textContent = title;
  olMsg.textContent = msg;
  if (sc !== undefined) {
    olScore.textContent = `High Score: ${highScore}`;
    olScore.style.display = 'block';
  } else {
    olScore.style.display = 'none';
  }
  olBtn.textContent = state === 'title' ? 'START' : 'RESTART';
  // Show version only on title screen
  if (state === 'title') {
    olVersion.textContent = GAME_VERSION;
    olVersion.style.display = 'block';
  } else {
    olVersion.style.display = 'none';
  }
  overlay.style.display = 'flex';
  hudBoost.style.display = 'none';
  hudCombo.style.display = 'none';
  hudComboBar.style.display = 'none';
  hudMission.style.display = 'none';
  hudMissionComplete.style.display = 'none';
  hudBossWave.style.display = 'none';
  hudBossClear.style.display = 'none';
  hudThemeAnnounce.style.display = 'none';
  hudSectionAnnounce.style.display = 'none';
  hudSectionLabel.classList.remove('highlight');
  hudSectionLabel.style.color = '#aaa';
}

function hideOverlay() {
  overlay.style.display = 'none';
}

olBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  startGame();
});

function startGame() {
  hideOverlay();
  resetGame();
  player.animState = 'idle';
  state = 'playing';
  // Reset fixed-timestep accumulator so no stale dt carries over
  _accumulator = 0;
  _lastTimestamp = -1;
}

// ── Input ──────────────────────────────────────────────
function onJumpDown() {
  if (levelCleared) { if (levelClearPhase === 'done') startGame(); return; }
  if (state === 'dead') { startGame(); return; }
  if (state === 'title') { startGame(); jumpPressed = true; return; }
  jumpPressed = true;
}
function onJumpUp() {
  jumpPressed = false;
  jumpConsumed = false;
}
function onMoveLeftDown() {
  if (levelCleared) { if (levelClearPhase === 'done') startGame(); return; }
  if (state === 'dead') { startGame(); return; }
  if (state === 'title') { startGame(); }
  moveLeftPressed = true;
}
function onMoveLeftUp() {
  moveLeftPressed = false;
}
function onMoveRightDown() {
  if (levelCleared) { if (levelClearPhase === 'done') startGame(); return; }
  if (state === 'dead') { startGame(); return; }
  if (state === 'title') { startGame(); }
  moveRightPressed = true;
}
function onMoveRightUp() {
  moveRightPressed = false;
}

// Keyboard
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    onJumpDown();
  }
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
    e.preventDefault();
    onMoveLeftDown();
  }
  if (e.code === 'ArrowRight' || e.code === 'KeyD') {
    e.preventDefault();
    onMoveRightDown();
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    onJumpUp();
  }
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
    onMoveLeftUp();
  }
  if (e.code === 'ArrowRight' || e.code === 'KeyD') {
    onMoveRightUp();
  }
});

// ── Mobile Buttons ─────────────────────────────────────
const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');
const btnJump = document.getElementById('btn-jump');

// Track active touch IDs per button to handle multi-touch correctly
let leftTouchIds = new Set();
let rightTouchIds = new Set();
let jumpTouchIds = new Set();

// Helper: setup touch events for a mobile button
function setupMobileBtn(el, touchSet, downFn, upFn) {
  el.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    for (const t of e.changedTouches) touchSet.add(t.identifier);
    el.classList.add('active');
    downFn();
  }, { passive: false });
  el.addEventListener('touchend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    for (const t of e.changedTouches) touchSet.delete(t.identifier);
    if (touchSet.size === 0) {
      el.classList.remove('active');
      upFn();
    }
  }, { passive: false });
  el.addEventListener('touchcancel', (e) => {
    for (const t of e.changedTouches) touchSet.delete(t.identifier);
    if (touchSet.size === 0) {
      el.classList.remove('active');
      upFn();
    }
  }, { passive: false });
}

setupMobileBtn(btnLeft, leftTouchIds, onMoveLeftDown, onMoveLeftUp);
setupMobileBtn(btnRight, rightTouchIds, onMoveRightDown, onMoveRightUp);
setupMobileBtn(btnJump, jumpTouchIds, onJumpDown, onJumpUp);

// ── Init ───────────────────────────────────────────────
loadSprite(); // attempt sprite mode; falls back to procedural on failure
initClouds();
initHills();
showOverlay('Plumber Runner', 'MOVE: Arrows/AD  |  JUMP: Space');
requestAnimationFrame(gameLoop);

// Expose self-test globally for console access
window.runCollisionSelfTest = runCollisionSelfTest;

// Auto-run self-test in debug mode
if (DEBUG_MODE) {
  setTimeout(() => {
    console.log('%cDebug mode active — running collision self-test...', 'color: #42d4f4');
    runCollisionSelfTest();
  }, 500);
}
</script>
</body>
</html>
